//! Cranelift code generation
//!
//! Translates HIR to Cranelift IR and generates native machine code.

use anyhow::{anyhow, Result};
use cranelift::prelude::*;
use cranelift_codegen::ir::AbiParam;
use cranelift_codegen::settings::{self, Configurable};
use cranelift_codegen::Context;
use cranelift_frontend::{FunctionBuilder, FunctionBuilderContext, Variable};
use cranelift_module::{DataDescription, Init, Linkage, Module};
use cranelift_object::{ObjectBuilder, ObjectModule};
use std::collections::{HashMap, HashSet};
use std::sync::atomic::{AtomicUsize, Ordering};

/// Global counter for generating unique temporary variable IDs
static TEMP_VAR_COUNTER: AtomicUsize = AtomicUsize::new(10000);

/// Get a unique temporary variable ID
fn next_temp_var_id() -> usize {
    TEMP_VAR_COUNTER.fetch_add(1, Ordering::Relaxed)
}

/// Global counter for generating unique regex data IDs
static REGEX_DATA_COUNTER: AtomicUsize = AtomicUsize::new(0);

/// Get a unique regex data ID
fn next_regex_data_id() -> usize {
    REGEX_DATA_COUNTER.fetch_add(1, Ordering::Relaxed)
}

/// Global counter for generating unique JS interop data IDs
static JS_INTEROP_DATA_COUNTER: AtomicUsize = AtomicUsize::new(0);

/// Get a unique JS interop data ID
fn next_js_data_id() -> usize {
    JS_INTEROP_DATA_COUNTER.fetch_add(1, Ordering::Relaxed)
}

use perry_hir::{
    ArrayElement, BinaryOp, CallArg, CatchClause, Class, ClassField, CompareOp, Decorator, Expr, Function, LogicalOp, Module as HirModule, Stmt, UnaryOp, UpdateOp,
};
use perry_types::LocalId;
use cranelift_codegen::ir::{Block, StackSlot, StackSlotData, StackSlotKind, TrapCode};

/// Information about a local variable
#[derive(Debug, Clone)]
struct LocalInfo {
    /// The Cranelift variable
    var: Variable,
    /// The variable name (for runtime lookup of dynamic constructors)
    name: Option<String>,
    /// If this is an object, what class is it? (None for primitives)
    class_name: Option<String>,
    /// Type arguments for generic class instances (e.g., Box<string> has type_args = [Type::String])
    type_args: Vec<perry_types::Type>,
    /// Is this stored as i64 (pointer) or f64 (number)?
    is_pointer: bool,
    /// Is this an array?
    is_array: bool,
    /// Is this a string?
    is_string: bool,
    /// Is this a bigint?
    is_bigint: bool,
    /// Is this a closure?
    is_closure: bool,
    /// Is this a boxed mutable capture? (stored as box pointer)
    is_boxed: bool,
    /// Is this a Map?
    is_map: bool,
    /// Is this a Set?
    is_set: bool,
    /// Is this a Buffer?
    is_buffer: bool,
    /// Is this an EventEmitter?
    is_event_emitter: bool,
    /// Is this a union type? (uses dynamic typing at runtime)
    is_union: bool,
    /// Is this a mixed-type array? (element type is union or any)
    is_mixed_array: bool,
    /// Is this an integer value? (for native i64 arithmetic optimization)
    is_integer: bool,
    /// Is this an integer-only array? (SMI array optimization)
    is_integer_array: bool,
    /// Is this variable stored as native i32? (loop counter optimization)
    is_i32: bool,
    /// Shadow i32 variable for integer values (optimization for array indexing)
    i32_shadow: Option<Variable>,
    /// Bounds check elimination: if this index variable is bounded by an array's length
    bounded_by_array: Option<LocalId>,
    /// Bounds check elimination: if this index variable is bounded by a constant
    bounded_by_constant: Option<i64>,
    /// Scalar-replaced fields (escape analysis): maps field names to scalar variables
    /// When set, PropertyGet/PropertySet use these variables instead of heap loads/stores
    scalar_fields: Option<HashMap<String, Variable>>,
    /// CSE: cached value of this variable squared (var * var)
    /// When set, Binary { op: Mul, left: LocalGet(id), right: LocalGet(id) } uses this
    squared_cache: Option<Variable>,
    /// CSE: cached products with other variables (var * other_var)
    /// Maps other_var_id -> cache_variable for x*y patterns
    product_cache: Option<HashMap<LocalId, Variable>>,
}

/// Check if a block has been filled with a terminating instruction
fn is_block_filled(builder: &FunctionBuilder, block: Block) -> bool {
    if let Some(inst) = builder.func.layout.last_inst(block) {
        builder.func.dfg.insts[inst].opcode().is_terminator()
    } else {
        false
    }
}

/// Convert a HIR Type to a Cranelift ABI type (standalone version)
fn type_to_cranelift_abi(ty: &perry_types::Type) -> types::Type {
    use perry_types::Type;
    match ty {
        // Numbers use f64
        Type::Number | Type::Int32 | Type::BigInt => types::F64,
        // Booleans can be f64 (0.0 or 1.0) for simplicity
        Type::Boolean => types::F64,
        // Strings, arrays, objects, promises are pointers (i64)
        Type::String | Type::Array(_) | Type::Object(_) |
        Type::Promise(_) | Type::Named(_) | Type::Generic { .. } => types::I64,
        // Void/Null/Undefined return f64 (will be 0)
        Type::Void | Type::Null => types::F64,
        // Any/Unknown use i64 (tagged values or pointers)
        Type::Any | Type::Unknown => types::I64,
        // Functions are pointers
        Type::Function(_) => types::I64,
        // Tuples use i64 (could be more complex)
        Type::Tuple(_) => types::I64,
        // Union types use f64 (NaN-boxed values can be numbers or pointers)
        Type::Union(_) => types::F64,
        // Never type - use f64 as fallback (never actually returned)
        Type::Never => types::F64,
        // TypeVar should be substituted before codegen; default to f64
        Type::TypeVar(_) => types::F64,
        // Symbol is an i64 id
        Type::Symbol => types::I64,
    }
}

/// Convert a Cranelift value to i64, bitcasting from f64 only if needed.
/// This is used when values that are logically pointers (strings, arrays, objects)
/// need to be passed to runtime functions that expect i64.
fn ensure_i64(builder: &mut FunctionBuilder, val: Value) -> Value {
    let val_type = builder.func.dfg.value_type(val);
    if val_type == types::I64 {
        val
    } else if val_type == types::I32 {
        // Extend i32 to i64
        builder.ins().uextend(types::I64, val)
    } else {
        builder.ins().bitcast(types::I64, MemFlags::new(), val)
    }
}

/// Convert a Cranelift value to f64, bitcasting from i64 only if needed.
/// This is used when values need to be stored uniformly as f64 or passed to
/// JS interop functions that expect NaN-boxed values.
fn ensure_f64(builder: &mut FunctionBuilder, val: Value) -> Value {
    let val_type = builder.func.dfg.value_type(val);
    if val_type == types::F64 {
        val
    } else if val_type == types::I32 {
        // Convert i32 to f64 (as a number, not bitcast)
        builder.ins().fcvt_from_sint(types::F64, val)
    } else {
        builder.ins().bitcast(types::F64, MemFlags::new(), val)
    }
}

/// Metadata about a compiled class
#[derive(Debug, Clone)]
struct ClassMeta {
    /// Class ID
    id: u32,
    /// Parent class name (for inheritance)
    parent_class: Option<String>,
    /// Native parent class (module, class_name) - e.g., ("events", "EventEmitter")
    native_parent: Option<(String, String)>,
    /// Number of own fields (not including inherited)
    own_field_count: u32,
    /// Total number of fields (including inherited)
    field_count: u32,
    /// Mapping from field name to index (includes inherited fields)
    field_indices: HashMap<String, u32>,
    /// Mapping from field name to type (includes inherited fields)
    field_types: HashMap<String, perry_types::Type>,
    /// Constructor function ID (if any)
    constructor_id: Option<cranelift_module::FuncId>,
    /// Method function IDs: method name -> func_id (includes inherited methods)
    method_ids: HashMap<String, cranelift_module::FuncId>,
    /// Getter function IDs: property name -> func_id
    getter_ids: HashMap<String, cranelift_module::FuncId>,
    /// Setter function IDs: property name -> func_id
    setter_ids: HashMap<String, cranelift_module::FuncId>,
    /// Static method function IDs: method name -> func_id
    static_method_ids: HashMap<String, cranelift_module::FuncId>,
    /// Static field global IDs: field name -> (data_id, has_init)
    static_field_ids: HashMap<String, cranelift_module::DataId>,
    /// Method return types: method name -> return type (for determining if method returns string)
    method_return_types: HashMap<String, perry_types::Type>,
    /// Type parameters of the class (e.g., ["T"] for class Box<T>)
    type_params: Vec<String>,
}

/// Enum member value (resolved at compile time)
#[derive(Clone)]
pub enum EnumMemberValue {
    Number(i64),
    String(String),
}

/// The main compiler that generates native code from HIR
pub struct Compiler {
    /// Cranelift module for the object file
    module: ObjectModule,
    /// Cranelift context for function compilation
    ctx: Context,
    /// Function builder context (reused across functions)
    func_ctx: FunctionBuilderContext,
    /// Mapping from HIR function IDs to Cranelift function IDs
    func_ids: HashMap<u32, cranelift_module::FuncId>,
    /// Mapping from external function names to their IDs
    extern_funcs: HashMap<String, cranelift_module::FuncId>,
    /// Class metadata: class name -> metadata
    classes: HashMap<String, ClassMeta>,
    /// Enum member values: (enum_name, member_name) -> value
    enums: HashMap<(String, String), EnumMemberValue>,
    /// String literal data: string content -> data ID
    string_data: HashMap<String, cranelift_module::DataId>,
    /// Closure function IDs: closure HIR func_id -> Cranelift func_id
    closure_func_ids: HashMap<u32, cranelift_module::FuncId>,
    /// Set of async function IDs (for proper return type handling)
    async_func_ids: std::collections::HashSet<u32>,
    /// Set of function IDs that return closures
    closure_returning_funcs: std::collections::HashSet<u32>,
    /// Wrapper functions for named functions used as callbacks: HIR func_id -> wrapper Cranelift func_id
    func_wrapper_ids: HashMap<u32, cranelift_module::FuncId>,
    /// HIR functions (needed for wrapper generation)
    hir_functions: Vec<Function>,
    /// Function parameter ABI types: func_id -> Vec<abi_type>
    func_param_types: HashMap<u32, Vec<types::Type>>,
    /// Function return ABI types: func_id -> abi_type
    func_return_types: HashMap<u32, types::Type>,
    /// Function HIR return types: func_id -> full HirType (for detecting Map, Set, etc.)
    func_hir_return_types: HashMap<u32, perry_types::Type>,
    /// Rest parameter info: func_id -> index of rest parameter (if any)
    /// The rest parameter collects all arguments from this index onwards into an array
    func_rest_param_index: HashMap<u32, usize>,
    /// Union parameter info: func_id -> Vec<bool> (true if parameter is union type)
    func_union_params: HashMap<u32, Vec<bool>>,
    /// Whether the JS runtime is needed for this module
    needs_js_runtime: bool,
    /// Whether dotenv/config was imported (needs auto-init call)
    needs_dotenv_init: bool,
    /// Whether this is the entry module (should generate main)
    is_entry_module: bool,
    /// Native module init function names to call from main (for entry module)
    native_module_inits: Vec<String>,
    /// JavaScript module specifiers that need to be loaded at runtime
    js_modules: Vec<String>,
    /// Exported native instance data IDs: variable name -> data ID
    exported_native_instance_ids: HashMap<String, cranelift_module::DataId>,
    /// Exported object literal data IDs: variable name -> data ID
    exported_object_ids: HashMap<String, cranelift_module::DataId>,
    /// Exported function data IDs: function name -> (data ID, FuncId)
    /// These are functions that need globals so they can be passed as values to other modules
    exported_function_ids: HashMap<String, (cranelift_module::DataId, u32)>,
    /// Module-level variable data IDs: LocalId -> data ID
    /// These are variables defined at module scope that need to be accessible from functions
    module_var_data_ids: HashMap<LocalId, cranelift_module::DataId>,
    /// Module-level variable info: LocalId -> LocalInfo
    /// Populated during compile_init, used by compile_function for GlobalGet
    module_level_locals: HashMap<LocalId, LocalInfo>,
    /// Imported function parameter counts: function name -> param count
    /// Used to ensure consistent wrapper signatures for functions with optional params
    imported_func_param_counts: HashMap<String, usize>,
}

impl Compiler {
    /// Create a new compiler for the host target
    pub fn new() -> Result<Self> {
        let mut flag_builder = settings::builder();
        flag_builder.set("use_colocated_libcalls", "false").unwrap();
        // Enable PIC for macOS compatibility
        flag_builder.set("is_pic", "true").unwrap();
        // Enable maximum optimization
        flag_builder.set("opt_level", "speed").unwrap();

        let isa_builder = cranelift_native::builder().map_err(|e| anyhow!("{}", e))?;
        let isa = isa_builder
            .finish(settings::Flags::new(flag_builder))
            .map_err(|e| anyhow!("{}", e))?;

        let builder = ObjectBuilder::new(
            isa,
            "perry_output",
            cranelift_module::default_libcall_names(),
        )?;
        let module = ObjectModule::new(builder);
        let ctx = module.make_context();

        Ok(Self {
            module,
            ctx,
            func_ctx: FunctionBuilderContext::new(),
            func_ids: HashMap::new(),
            extern_funcs: HashMap::new(),
            classes: HashMap::new(),
            enums: HashMap::new(),
            string_data: HashMap::new(),
            closure_func_ids: HashMap::new(),
            async_func_ids: std::collections::HashSet::new(),
            closure_returning_funcs: std::collections::HashSet::new(),
            func_wrapper_ids: HashMap::new(),
            hir_functions: Vec::new(),
            func_param_types: HashMap::new(),
            func_return_types: HashMap::new(),
            func_hir_return_types: HashMap::new(),
            func_rest_param_index: HashMap::new(),
            func_union_params: HashMap::new(),
            needs_js_runtime: false,
            needs_dotenv_init: false,
            is_entry_module: true,  // Default to true for single-module compilation
            native_module_inits: Vec::new(),
            js_modules: Vec::new(),
            exported_native_instance_ids: HashMap::new(),
            exported_object_ids: HashMap::new(),
            exported_function_ids: HashMap::new(),
            module_var_data_ids: HashMap::new(),
            module_level_locals: HashMap::new(),
            imported_func_param_counts: HashMap::new(),
        })
    }

    /// Set whether the JS runtime is needed for this module
    pub fn set_needs_js_runtime(&mut self, needs: bool) {
        self.needs_js_runtime = needs;
    }

    /// Set whether this is the entry module (generates main function)
    pub fn set_is_entry_module(&mut self, is_entry: bool) {
        self.is_entry_module = is_entry;
    }

    /// Add a native module init function to call from main (for entry module)
    pub fn add_native_module_init(&mut self, module_name: String) {
        // Sanitize the module name the same way as in compile_init
        let sanitized_name = module_name.replace(|c: char| !c.is_alphanumeric() && c != '_', "_");
        let func_name = format!("_perry_init_{}", sanitized_name);
        self.native_module_inits.push(func_name);
    }

    /// Add a JavaScript module that should be loaded at runtime
    pub fn add_js_module(&mut self, specifier: String) {
        self.js_modules.push(specifier);
    }

    /// Register an imported function's parameter count.
    /// This ensures wrapper functions use the correct full signature even when
    /// the function has optional parameters and is called with different arities.
    pub fn register_imported_func_param_count(&mut self, func_name: String, param_count: usize) {
        self.imported_func_param_counts.insert(func_name, param_count);
    }

    /// Register an imported class from another module.
    /// This declares the class's constructor and methods as imports so they can be called.
    /// The class definition must have been exported from the source module.
    /// If `local_alias` is provided and differs from the class name, the class is also
    /// registered under the alias so it can be found when used with that name in the code.
    pub fn register_imported_class(&mut self, class: &Class, local_alias: Option<&str>) -> Result<()> {
        // Skip if already registered (e.g., if class is defined locally)
        if self.classes.contains_key(&class.name) {
            // If there's an alias that differs from the class name, also register under the alias
            if let Some(alias) = local_alias {
                if alias != class.name && !self.classes.contains_key(alias) {
                    // Clone the existing metadata for the alias
                    if let Some(existing_meta) = self.classes.get(&class.name).cloned() {
                        self.classes.insert(alias.to_string(), existing_meta);
                    }
                }
            }
            return Ok(());
        }

        // Build field indices and types
        let mut field_indices = HashMap::new();
        let mut field_types = HashMap::new();
        for (i, field) in class.fields.iter().enumerate() {
            field_indices.insert(field.name.clone(), i as u32);
            field_types.insert(field.name.clone(), field.ty.clone());
        }

        // Collect method return types
        let mut method_return_types = HashMap::new();
        for method in &class.methods {
            method_return_types.insert(method.name.clone(), method.return_type.clone());
        }

        // Extract type parameter names
        let type_params: Vec<String> = class.type_params.iter().map(|tp| tp.name.clone()).collect();

        // Create the class metadata (constructor_id and method_ids will be filled below)
        // Use extends_name for imported classes where extends ClassId may not resolve locally
        self.classes.insert(class.name.clone(), ClassMeta {
            id: class.id,
            parent_class: class.extends_name.clone(),
            native_parent: class.native_extends.clone(),
            own_field_count: class.fields.len() as u32,
            field_count: class.fields.len() as u32,
            field_indices,
            field_types,
            constructor_id: None,
            method_ids: HashMap::new(),
            getter_ids: HashMap::new(),
            setter_ids: HashMap::new(),
            static_method_ids: HashMap::new(),
            static_field_ids: HashMap::new(),
            method_return_types,
            type_params,
        });

        // Declare the constructor as an import (if present)
        if let Some(ref ctor) = class.constructor {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // 'this' pointer
            for _ in &ctor.params {
                sig.params.push(AbiParam::new(types::F64));
            }
            // Constructor returns void

            let func_name = format!("{}_constructor", class.name);
            let func_id = self.module.declare_function(&func_name, Linkage::Import, &sig)?;

            if let Some(meta) = self.classes.get_mut(&class.name) {
                meta.constructor_id = Some(func_id);
            }
        }

        // Declare methods as imports
        for method in &class.methods {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // 'this' pointer
            for _ in &method.params {
                sig.params.push(AbiParam::new(types::F64));
            }
            sig.returns.push(AbiParam::new(types::F64));

            let func_name = format!("{}_{}", class.name, method.name);
            let func_id = self.module.declare_function(&func_name, Linkage::Import, &sig)?;

            if let Some(meta) = self.classes.get_mut(&class.name) {
                meta.method_ids.insert(method.name.clone(), func_id);
            }
        }

        // If there's a local alias that differs from the class name, also register under the alias
        // This allows code to use the alias name (e.g., `new Alias()` when import was `{ MyClass as Alias }`)
        if let Some(alias) = local_alias {
            if alias != class.name && !self.classes.contains_key(alias) {
                if let Some(existing_meta) = self.classes.get(&class.name).cloned() {
                    self.classes.insert(alias.to_string(), existing_meta);
                }
            }
        }

        Ok(())
    }

    /// Convert a HIR type to a Cranelift ABI type
    fn type_to_abi(&self, ty: &perry_types::Type) -> types::Type {
        use perry_types::Type;
        match ty {
            // Numbers use f64
            Type::Number | Type::Int32 => types::F64,
            // BigInt uses f64 (NaN-boxed pointer with BIGINT_TAG)
            Type::BigInt => types::F64,
            // Booleans can be f64 (0.0 or 1.0) for simplicity
            Type::Boolean => types::F64,
            // Strings, arrays, objects are pointers (i64)
            Type::String | Type::Array(_) | Type::Object(_) => types::I64,
            // Promises are pointers (i64)
            Type::Promise(_) => types::I64,
            // Named types: most are pointers, but Date is stored as f64 timestamp
            Type::Named(name) => {
                if name == "Date" {
                    types::F64  // Date is stored as f64 timestamp in runtime
                } else {
                    types::I64  // Other named types are object pointers
                }
            }
            // Generic types are pointers
            Type::Generic { .. } => types::I64,
            // Void/Null/Undefined return f64 (will be 0)
            Type::Void | Type::Null => types::F64,
            // Any/Unknown use f64 (NaN-boxed values for JS interop)
            Type::Any | Type::Unknown => types::F64,
            // Functions are pointers
            Type::Function(_) => types::I64,
            // Tuples use i64 (could be more complex)
            Type::Tuple(_) => types::I64,
            // Union types use f64 (NaN-boxed values can be numbers or pointers)
            Type::Union(_) => types::F64,
            // Never type - use f64 as fallback (never actually returned)
            Type::Never => types::F64,
            // TypeVar should be substituted before codegen; default to f64
            Type::TypeVar(_) => types::F64,
            // Symbol is an i64 id
            Type::Symbol => types::I64,
        }
    }

    /// Create global data slots for module-level variables
    /// These allow functions to access variables defined in init statements
    fn create_module_var_globals(&mut self, init_stmts: &[Stmt]) -> Result<()> {
        for stmt in init_stmts {
            if let Stmt::Let { id, name, .. } = stmt {
                // Create a global data slot for this variable
                // Each slot holds an f64 (8 bytes)
                let global_name = format!("__modvar_{}_{}", name, id);
                let data_id = self.module.declare_data(&global_name, Linkage::Local, true, false)?;
                let mut data_desc = DataDescription::new();
                data_desc.define_zeroinit(8); // 8 bytes for f64
                self.module.define_data(data_id, &data_desc)?;
                self.module_var_data_ids.insert(*id, data_id);
            }
        }
        Ok(())
    }

    /// Analyze module-level variable types from init statements
    /// This is needed before compile_function to know the types for loading from global slots
    fn analyze_module_var_types(&mut self, init_stmts: &[Stmt]) {
        use perry_types::Type as HirType;

        for stmt in init_stmts {
            if let Stmt::Let { id, name, ty, init, .. } = stmt {
                // Determine if this variable is a pointer type
                // Note: String is NOT included because strings are now NaN-boxed (f64 values)
                let is_pointer = matches!(ty, HirType::Array(_) |
                    HirType::Object(_) | HirType::Named(_) | HirType::Generic { .. } |
                    HirType::Function(_));

                // Also check the init expression type for better inference
                // Note: Expr::String is NOT included because strings are now NaN-boxed (f64 values)
                // Note: Native handle classes (EventEmitter, Decimal, etc.) use f64 (NaN-boxed), not i64 pointers
                let is_pointer_from_init = if let Some(init_expr) = init {
                    match init_expr {
                        Expr::New { class_name, .. } => {
                            // Native handle classes use f64, not i64
                            !matches!(class_name.as_str(),
                                "EventEmitter" | "Decimal" | "Big" | "BigNumber" | "LRUCache" | "Command" | "Redis")
                        }
                        Expr::Array(_) | Expr::Object(_) | Expr::ArraySpread(_) |
                        Expr::Closure { .. } | Expr::MapNew | Expr::SetNew |
                        // JS interop expressions return pointers
                        Expr::JsCallFunction { .. } | Expr::JsCallMethod { .. } |
                        Expr::JsGetExport { .. } | Expr::JsNew { .. } |
                        Expr::JsNewFromHandle { .. } | Expr::JsGetProperty { .. } |
                        // Call expressions might return objects/arrays
                        Expr::Call { .. } | Expr::NativeMethodCall { .. } => true,
                        _ => false,
                    }
                } else {
                    false
                };

                // Check if NativeMethodCall returns a string
                let is_string_from_native = matches!(init, Some(Expr::NativeMethodCall { module, method, .. })
                    if (module == "path" && matches!(method.as_str(), "dirname" | "basename" | "extname" | "join" | "resolve"))
                       || (module == "fs" && method == "readFileSync")
                       || (module == "uuid" && matches!(method.as_str(), "v4" | "v1" | "v7"))
                       || (module == "crypto" && matches!(method.as_str(), "sha256" | "md5" | "randomUUID" | "hmacSha256" | "randomBytes"))
                );
                // Check if Call expression returns a string (e.g., buffer.toString())
                let is_string_from_call = if let Some(Expr::Call { callee, .. }) = init {
                    if let Expr::PropertyGet { object, property } = callee.as_ref() {
                        // buffer.toString() returns string
                        if property == "toString" {
                            if let Expr::LocalGet(obj_id) = object.as_ref() {
                                self.module_level_locals.get(obj_id).map(|i| i.is_buffer).unwrap_or(false)
                            } else {
                                false
                            }
                        } else {
                            false
                        }
                    } else {
                        false
                    }
                } else {
                    false
                };
                let is_string = matches!(ty, HirType::String) || matches!(init, Some(Expr::String(_))) || is_string_from_native || is_string_from_call;
                let is_array = matches!(ty, HirType::Array(_)) || matches!(init, Some(Expr::Array(_))) || matches!(init, Some(Expr::ArraySpread(_))) || matches!(init, Some(Expr::ProcessArgv));
                let is_closure = matches!(ty, HirType::Function(_)) || matches!(init, Some(Expr::Closure { .. }));
                // Check for buffer expressions
                let is_buffer = matches!(init, Some(Expr::BufferFrom { .. }) | Some(Expr::BufferAlloc { .. }) |
                    Some(Expr::BufferAllocUnsafe(_)) | Some(Expr::BufferConcat(_)) |
                    Some(Expr::BufferSlice { .. }) | Some(Expr::ChildProcessExecSync { .. }));

                // Store the type info
                let info = LocalInfo {
                    var: Variable::new(0), // Will be overwritten in compile_function
                    name: Some(name.clone()),
                    class_name: None,
                    type_args: Vec::new(),
                    is_pointer: is_pointer || is_pointer_from_init,
                    is_array,
                    is_string,
                    is_bigint: false,
                    is_closure,
                    is_boxed: false,
                    is_map: matches!(init, Some(Expr::MapNew)),
                    is_set: matches!(init, Some(Expr::SetNew)),
                    is_buffer,
                    is_event_emitter: matches!(init, Some(Expr::New { class_name, .. }) if class_name == "EventEmitter"),
                    is_union: false,
                    is_mixed_array: false,
                    is_integer: false,
                    is_integer_array: false,
                    is_i32: false,
                    i32_shadow: None,
                    bounded_by_array: None,
                    bounded_by_constant: None,
                    scalar_fields: None,
                    squared_cache: None,
                    product_cache: None,
                };
                self.module_level_locals.insert(*id, info);
            }
        }
    }

    /// Compile a HIR module to an object file
    pub fn compile_module(mut self, hir: &HirModule) -> Result<Vec<u8>> {
        // Store HIR functions for wrapper generation
        self.hir_functions = hir.functions.clone();

        // Build function parameter and return types map for proper call-site type conversion
        for func in &hir.functions {
            let param_types: Vec<types::Type> = func.params.iter()
                .map(|p| self.type_to_abi(&p.ty))
                .collect();
            self.func_param_types.insert(func.id, param_types);

            // Track return type for correct variable typing when storing call results
            let return_type = if func.is_async {
                types::I64 // Async functions return Promise (i64 pointer)
            } else {
                self.type_to_abi(&func.return_type)
            };
            self.func_return_types.insert(func.id, return_type);

            // Store full HIR return type for detecting Map, Set, etc. at call sites
            self.func_hir_return_types.insert(func.id, func.return_type.clone());

            // Track which parameters are union types (for proper NaN-boxing at call sites)
            let union_params: Vec<bool> = func.params.iter()
                .map(|p| matches!(p.ty, perry_types::Type::Union(_)))
                .collect();
            self.func_union_params.insert(func.id, union_params);
        }

        // Process classes first to build metadata
        for class in &hir.classes {
            self.process_class(class, &hir.classes)?;
        }

        // Resolve class inheritance (merge parent fields into child classes)
        self.resolve_class_inheritance();

        // Process enums to store their member values
        for en in &hir.enums {
            self.process_enum(en)?;
        }

        // Check for dotenv/config side-effect import (auto-calls dotenv.config())
        for import in &hir.imports {
            if import.source == "dotenv/config" && import.is_native {
                self.needs_dotenv_init = true;
                break;
            }
        }

        // Identify functions that return closures by scanning their body for return statements
        for func in &hir.functions {
            if self.function_returns_closure(&func.body) {
                self.closure_returning_funcs.insert(func.id);
            }
        }

        // First pass: declare all functions
        for func in &hir.functions {
            self.declare_function(func)?;
        }

        // Declare class constructors and methods
        for class in &hir.classes {
            self.declare_class_constructor(class)?;
            self.declare_class_methods(class)?;
            self.declare_class_getters(class)?;
            self.declare_class_setters(class)?;
            self.declare_static_methods(class)?;
            self.declare_static_fields(class)?;
        }

        // Now that all methods are declared, resolve method inheritance
        self.resolve_method_inheritance();

        // Declare external runtime functions
        self.declare_runtime_functions()?;

        // Collect closures from ALL sources: functions, classes, and init statements
        // This MUST happen BEFORE compiling class methods that may contain closures
        // Tuple: (func_id, params, body, captures, mutable_captures, captures_this, enclosing_class)
        let mut all_closures: Vec<(u32, Vec<perry_hir::Param>, Vec<Stmt>, Vec<LocalId>, Vec<LocalId>, bool, Option<String>)> = Vec::new();

        // Collect from function bodies (no enclosing class)
        for func in &hir.functions {
            self.collect_closures_from_stmts_into(&func.body, &mut all_closures, None);
        }

        // Collect from class methods and constructors (pass class name for this capture)
        for class in &hir.classes {
            let class_name = class.name.as_str();
            for method in &class.methods {
                self.collect_closures_from_stmts_into(&method.body, &mut all_closures, Some(class_name));
            }
            for (_, getter) in &class.getters {
                self.collect_closures_from_stmts_into(&getter.body, &mut all_closures, Some(class_name));
            }
            for (_, setter) in &class.setters {
                self.collect_closures_from_stmts_into(&setter.body, &mut all_closures, Some(class_name));
            }
            for method in &class.static_methods {
                // Static methods don't have `this`, so pass None
                self.collect_closures_from_stmts_into(&method.body, &mut all_closures, None);
            }
            if let Some(ctor) = &class.constructor {
                self.collect_closures_from_stmts_into(&ctor.body, &mut all_closures, Some(class_name));
            }

            // Collect from class field initializers
            for field in &class.fields {
                if let Some(init) = &field.init {
                    self.collect_closures_from_expr(init, &mut all_closures, Some(class_name));
                }
            }

            // Collect from static field initializers (no enclosing class for static context)
            for field in &class.static_fields {
                if let Some(init) = &field.init {
                    self.collect_closures_from_expr(init, &mut all_closures, None);
                }
            }
        }

        // Collect from init statements (no enclosing class)
        self.collect_closures_from_stmts_into(&hir.init, &mut all_closures, None);

        // Collect from global variable initializers
        for global in &hir.globals {
            if let Some(init) = &global.init {
                self.collect_closures_from_expr(init, &mut all_closures, None);
            }
        }

        // Deduplicate closures by func_id (same closure may appear in class method and init statements)
        // Prefer entries with enclosing_class set (from class methods) over those without
        let mut seen_func_ids: std::collections::HashMap<u32, usize> = std::collections::HashMap::new();
        let mut deduped_closures: Vec<(u32, Vec<perry_hir::Param>, Vec<Stmt>, Vec<LocalId>, Vec<LocalId>, bool, Option<String>)> = Vec::new();
        for closure in all_closures {
            let func_id = closure.0;
            if let Some(&existing_idx) = seen_func_ids.get(&func_id) {
                // If existing has no enclosing_class but this one does, replace it
                if deduped_closures[existing_idx].6.is_none() && closure.6.is_some() {
                    deduped_closures[existing_idx] = closure;
                }
                // Otherwise keep the existing one
            } else {
                seen_func_ids.insert(func_id, deduped_closures.len());
                deduped_closures.push(closure);
            }
        }

        // Declare all closures first, then compile them
        // If captures_this, we need an extra slot for the `this` pointer
        for (func_id, params, _body, captures, _mutable_captures, captures_this, _enclosing_class) in &deduped_closures {
            let capture_count = if *captures_this { captures.len() + 1 } else { captures.len() };
            self.declare_closure(*func_id, params.len(), capture_count)?;
        }

        // Collect FuncRef expressions that need closure-compatible wrappers
        // NOTE: This must be done BEFORE compiling closures, as closures may use FuncRefs
        let mut func_refs_needing_wrappers: std::collections::HashSet<u32> = std::collections::HashSet::new();
        for func in &hir.functions {
            self.collect_func_refs_needing_wrappers_from_stmts(&func.body, &mut func_refs_needing_wrappers);
        }
        for class in &hir.classes {
            for method in &class.methods {
                self.collect_func_refs_needing_wrappers_from_stmts(&method.body, &mut func_refs_needing_wrappers);
            }
            for method in &class.static_methods {
                self.collect_func_refs_needing_wrappers_from_stmts(&method.body, &mut func_refs_needing_wrappers);
            }
            if let Some(ctor) = &class.constructor {
                self.collect_func_refs_needing_wrappers_from_stmts(&ctor.body, &mut func_refs_needing_wrappers);
            }
        }
        self.collect_func_refs_needing_wrappers_from_stmts(&hir.init, &mut func_refs_needing_wrappers);

        // Also collect from closure bodies (closures may contain FuncRefs)
        for (_, _, body, _, _, _, _) in &deduped_closures {
            self.collect_func_refs_needing_wrappers_from_stmts(body, &mut func_refs_needing_wrappers);
        }

        // Exported functions also need wrappers so they can be passed as values to other modules
        for (_, func_id) in &hir.exported_functions {
            func_refs_needing_wrappers.insert(*func_id);
        }

        // ALL functions should have wrappers generated so they can be used as values
        // This is necessary because collect_func_refs_from_expr doesn't traverse all expression types
        // and some functions may be passed as values in ways that aren't detected
        for func in &hir.functions {
            func_refs_needing_wrappers.insert(func.id);
        }

        // Generate wrappers for all FuncRefs that need them
        for func_id in &func_refs_needing_wrappers {
            self.get_or_create_func_wrapper(*func_id)?;
        }

        // Create global data slots for module-level variables that may be accessed from functions/methods/closures
        // IMPORTANT: This must be done BEFORE compiling closures/methods so the data IDs are available
        self.create_module_var_globals(&hir.init)?;

        // Pre-compute which module-level variables are pointers
        self.analyze_module_var_types(&hir.init);

        // Now compile closures (after wrappers are created and module vars are registered)
        for (func_id, params, body, captures, mutable_captures, captures_this, enclosing_class) in deduped_closures {
            self.compile_closure(func_id, &params, &body, &captures, &mutable_captures, captures_this, enclosing_class.as_deref())?;
        }

        // Compile class constructors and methods
        for class in &hir.classes {
            if let Some(ref ctor) = class.constructor {
                self.compile_class_constructor(class, ctor)?;
            }
            for method in &class.methods {
                self.compile_class_method(class, method)?;
            }
            // Compile getters
            for (prop_name, getter) in &class.getters {
                self.compile_class_getter(class, prop_name, getter)?;
            }
            // Compile setters
            for (prop_name, setter) in &class.setters {
                self.compile_class_setter(class, prop_name, setter)?;
            }
            // Compile static methods
            for method in &class.static_methods {
                self.compile_static_method(class, method)?;
            }
            // Compile static fields
            for field in &class.static_fields {
                self.compile_static_field(class, field)?;
            }
        }

        // Create exported globals for native instances (e.g., `export const pool = new Pool(...)`)
        // These will be filled in during compile_init and accessed by other modules
        for (export_name, _module_name, _class_name) in &hir.exported_native_instances {
            let global_name = format!("__export_{}", export_name);
            let data_id = self.module.declare_data(&global_name, Linkage::Export, true, false)?;
            // Create a data description with space for one f64 (8 bytes), initialized to 0
            let mut data_desc = DataDescription::new();
            data_desc.define_zeroinit(8);
            self.module.define_data(data_id, &data_desc)?;
            self.exported_native_instance_ids.insert(export_name.clone(), data_id);
        }

        // Create exported globals for object literals (e.g., `export const config = { ... }`)
        // These will be filled in during compile_init and accessed by other modules
        // Skip exports that are already defined as native instances to avoid duplicate definitions
        let native_instance_names: std::collections::HashSet<&String> = hir.exported_native_instances
            .iter()
            .map(|(name, _, _)| name)
            .collect();
        for export_name in &hir.exported_objects {
            // Skip if already defined as a native instance export
            if native_instance_names.contains(export_name) {
                continue;
            }
            let global_name = format!("__export_{}", export_name);
            let data_id = self.module.declare_data(&global_name, Linkage::Export, true, false)?;
            // Create a data description with space for one f64 (8 bytes), initialized to 0
            let mut data_desc = DataDescription::new();
            data_desc.define_zeroinit(8);
            self.module.define_data(data_id, &data_desc)?;
            self.exported_object_ids.insert(export_name.clone(), data_id);
        }

        // Create exported globals for functions (e.g., `export function foo() { ... }`)
        // These allow functions to be passed as values to other modules
        for (func_name, func_id) in &hir.exported_functions {
            let global_name = format!("__export_{}", func_name);
            let data_id = self.module.declare_data(&global_name, Linkage::Export, true, false)?;
            // Create a data description with space for one f64 (8 bytes), initialized to 0
            let mut data_desc = DataDescription::new();
            data_desc.define_zeroinit(8);
            self.module.define_data(data_id, &data_desc)?;
            self.exported_function_ids.insert(func_name.clone(), (data_id, *func_id));
        }

        // Second pass: compile all functions
        // Note: create_module_var_globals and analyze_module_var_types were already called
        // before compiling closures/methods above
        for func in &hir.functions {
            self.compile_function(func)?;
        }

        // Compile init statements as main (entry) or module init function (non-entry)
        // For non-entry modules, always generate the init function even if empty,
        // because the entry module will call it.
        // For entry module, generate main if there are init statements or other module inits to call.
        let should_compile_init = !hir.init.is_empty()
            || !self.is_entry_module
            || !self.native_module_inits.is_empty()
            || self.needs_js_runtime
            || self.needs_dotenv_init;

        if should_compile_init {
            self.compile_init(&hir.name, &hir.init, &hir.exported_native_instances, &hir.exported_objects, &hir.exported_functions)?;
        }

        // Emit object file
        let product = self.module.finish();
        Ok(product.emit()?)
    }

    fn process_class(&mut self, class: &Class, all_classes: &[Class]) -> Result<()> {
        // Find parent class name if this class extends another
        // First try to resolve by ClassId, then fall back to extends_name for imported classes
        let parent_class = class.extends.and_then(|parent_id| {
            all_classes.iter()
                .find(|c| c.id == parent_id)
                .map(|c| c.name.clone())
        }).or_else(|| class.extends_name.clone());

        // Native parent class (e.g., EventEmitter from 'events')
        let native_parent = class.native_extends.clone();

        // If extending a native class, add a hidden field to store the native handle
        let native_handle_field_count = if native_parent.is_some() { 1 } else { 0 };
        let own_field_count = class.fields.len() as u32 + native_handle_field_count;

        // Start with own fields only - inheritance will be resolved later
        // If there's a native parent, field 0 is reserved for the native handle
        let mut field_indices = HashMap::new();
        let mut field_types = HashMap::new();
        if native_parent.is_some() {
            field_indices.insert("__native_handle__".to_string(), 0);
        }
        for (i, field) in class.fields.iter().enumerate() {
            field_indices.insert(field.name.clone(), (i as u32) + native_handle_field_count);
            field_types.insert(field.name.clone(), field.ty.clone());
        }

        // Collect method return types for type-aware console.log handling
        let mut method_return_types = HashMap::new();
        for method in &class.methods {
            method_return_types.insert(method.name.clone(), method.return_type.clone());
        }

        // Extract type parameter names
        let type_params: Vec<String> = class.type_params.iter().map(|tp| tp.name.clone()).collect();

        self.classes.insert(class.name.clone(), ClassMeta {
            id: class.id,
            parent_class,
            native_parent,
            own_field_count,
            field_count: own_field_count,
            field_indices,
            field_types,
            constructor_id: None,
            method_ids: HashMap::new(),
            getter_ids: HashMap::new(),
            setter_ids: HashMap::new(),
            static_method_ids: HashMap::new(),
            static_field_ids: HashMap::new(),
            method_return_types,
            type_params,
        });

        Ok(())
    }

    fn resolve_class_inheritance(&mut self) {
        // Get list of class names to process
        let class_names: Vec<String> = self.classes.keys().cloned().collect();

        for class_name in &class_names {
            self.resolve_class_fields(class_name);
        }
    }

    fn resolve_class_fields(&mut self, class_name: &str) -> u32 {
        // Get a clone of the class meta to avoid borrow issues
        let class_meta = match self.classes.get(class_name) {
            Some(meta) => meta.clone(),
            None => return 0,
        };

        // If already resolved (field_count > own_field_count or no parent), return
        if class_meta.parent_class.is_none() {
            return class_meta.field_count;
        }

        let parent_name = class_meta.parent_class.clone().unwrap();

        // Recursively resolve parent first
        let parent_field_count = self.resolve_class_fields(&parent_name);

        // Get parent's field indices
        let parent_field_indices = self.classes.get(&parent_name)
            .map(|m| m.field_indices.clone())
            .unwrap_or_default();

        // Update current class: shift own field indices by parent's field count
        if let Some(meta) = self.classes.get_mut(class_name) {
            // Merge parent fields (they come first)
            let mut new_field_indices = parent_field_indices;

            // Add own fields with offset
            for (field_name, idx) in &class_meta.field_indices {
                new_field_indices.insert(field_name.clone(), idx + parent_field_count);
            }

            meta.field_indices = new_field_indices;
            meta.field_count = parent_field_count + class_meta.own_field_count;
        }

        self.classes.get(class_name).map(|m| m.field_count).unwrap_or(0)
    }

    /// Resolve method inheritance - copy parent methods to child classes
    /// This must be called AFTER all methods have been declared
    fn resolve_method_inheritance(&mut self) {
        let class_names: Vec<String> = self.classes.keys().cloned().collect();

        for class_name in &class_names {
            self.resolve_methods_for_class(class_name);
        }
    }

    fn resolve_methods_for_class(&mut self, class_name: &str) {
        let class_meta = match self.classes.get(class_name) {
            Some(meta) => meta.clone(),
            None => return,
        };

        // If no parent, nothing to inherit
        let parent_name = match &class_meta.parent_class {
            Some(name) => name.clone(),
            None => return,
        };

        // Recursively resolve parent first
        self.resolve_methods_for_class(&parent_name);

        // Get parent's method IDs
        let parent_method_ids = self.classes.get(&parent_name)
            .map(|m| m.method_ids.clone())
            .unwrap_or_default();

        // Inherit parent methods (child methods override parent)
        if let Some(meta) = self.classes.get_mut(class_name) {
            for (method_name, method_id) in parent_method_ids {
                if !meta.method_ids.contains_key(&method_name) {
                    meta.method_ids.insert(method_name, method_id);
                }
            }
        }
    }

    fn process_enum(&mut self, en: &perry_hir::Enum) -> Result<()> {
        for member in &en.members {
            let value = match &member.value {
                perry_hir::EnumValue::Number(n) => EnumMemberValue::Number(*n),
                perry_hir::EnumValue::String(s) => EnumMemberValue::String(s.clone()),
            };
            self.enums.insert((en.name.clone(), member.name.clone()), value);
        }
        Ok(())
    }

    fn declare_class_methods(&mut self, class: &Class) -> Result<()> {
        // Export methods for exported classes so other modules can call them
        let linkage = if class.is_exported { Linkage::Export } else { Linkage::Local };

        for method in &class.methods {
            let mut sig = self.module.make_signature();

            // Methods take 'this' as first parameter (i64 pointer)
            sig.params.push(AbiParam::new(types::I64));

            // Then regular parameters (all f64 for now)
            for _ in &method.params {
                sig.params.push(AbiParam::new(types::F64));
            }

            // Return type (f64 for now)
            sig.returns.push(AbiParam::new(types::F64));

            let func_name = format!("{}_{}", class.name, method.name);
            let func_id = self.module.declare_function(&func_name, linkage, &sig)?;

            if let Some(meta) = self.classes.get_mut(&class.name) {
                meta.method_ids.insert(method.name.clone(), func_id);
            }
        }
        Ok(())
    }

    fn compile_class_method(&mut self, class: &Class, method: &Function) -> Result<()> {
        let func_name = format!("{}_{}", class.name, method.name);
        let func_id = self.classes.get(&class.name)
            .and_then(|m| m.method_ids.get(&method.name).copied())
            .ok_or_else(|| anyhow!("Method not declared: {}::{}", class.name, method.name))?;

        // Set up the function signature
        self.ctx.func.signature.params.clear();
        self.ctx.func.signature.returns.clear();

        // 'this' as first parameter
        self.ctx.func.signature.params.push(AbiParam::new(types::I64));

        for _ in &method.params {
            self.ctx.func.signature.params.push(AbiParam::new(types::F64));
        }
        self.ctx.func.signature.returns.push(AbiParam::new(types::F64));

        let class_meta = self.classes.get(&class.name).cloned()
            .ok_or_else(|| anyhow!("Class metadata not found: {}", class.name))?;


        // Collect mutable captures before FunctionBuilder block
        let boxed_vars = self.collect_mutable_captures_from_stmts(&method.body);

        // Prepare decorator data before creating the FunctionBuilder
        let decorator_data = self.prepare_decorators(&method.decorators, &method.name)?;
        let print_func_id = self.extern_funcs.get("js_string_print").copied();

        {
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.append_block_params_for_function_params(entry_block);
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // 'this' is the first parameter (i64 pointer)
            let this_var = Variable::new(0);
            builder.declare_var(this_var, types::I64);
            let this_val = builder.block_params(entry_block)[0];
            builder.def_var(this_var, this_val);

            // Create variables for other parameters
            let mut locals: HashMap<LocalId, LocalInfo> = HashMap::new();
            let mut next_var = 1usize;
            for (i, param) in method.params.iter().enumerate() {
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, types::F64);
                let val = builder.block_params(entry_block)[i + 1]; // +1 to skip 'this'
                builder.def_var(var, val);
                // Check parameter types for correct handling of string methods, array methods, etc.
                let is_closure = matches!(param.ty, perry_types::Type::Function(_));
                let is_string = matches!(param.ty, perry_types::Type::String);
                let is_array = matches!(param.ty, perry_types::Type::Array(_));
                let is_pointer = is_closure || is_string || is_array;
                locals.insert(param.id, LocalInfo {
                    var,
                    name: Some(param.name.clone()),
                    class_name: None,
                    type_args: Vec::new(),
                    is_pointer,
                    is_array,
                    is_string,
                    is_bigint: false,
                    is_closure,
                    is_boxed: false,
                    is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                    is_mixed_array: false,
                    is_integer: false,
                    is_integer_array: false,
                    is_i32: false,
                    i32_shadow: None,
                    bounded_by_array: None,
                    bounded_by_constant: None,
                    scalar_fields: None,
                    squared_cache: None, product_cache: None,
                });
            }

            // Load module-level variables from their global slots
            // These are variables defined at module scope that the method may reference
            for (local_id, data_id) in &self.module_var_data_ids {
                // Get the type info from module_level_locals (populated during compile_init)
                let (var_type, local_info_template) = if let Some(info) = self.module_level_locals.get(local_id) {
                    // Variable is stored as i64 only if is_pointer && !is_union
                    let vt = if info.is_pointer && !info.is_union { types::I64 } else { types::F64 };
                    (vt, info.clone())
                } else {
                    // Fallback to f64 if type info not available
                    (types::F64, LocalInfo {
                        var: Variable::new(0), // Will be overwritten
                        name: None,
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false,
                        is_array: false,
                        is_string: false,
                        is_bigint: false,
                        is_closure: false,
                        is_boxed: false,
                        is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                        is_mixed_array: false,
                        is_integer: false,
                        is_integer_array: false,
                        is_i32: false,
                        i32_shadow: None,
                        bounded_by_array: None,
                        bounded_by_constant: None,
                        scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    })
                };

                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, var_type);

                // Load the value from the global data slot
                let global_val = self.module.declare_data_in_func(*data_id, builder.func);
                let ptr = builder.ins().global_value(types::I64, global_val);
                let val = builder.ins().load(var_type, MemFlags::new(), ptr, 0);
                builder.def_var(var, val);

                // Insert into locals so LocalGet can find it
                let mut info = local_info_template;
                info.var = var;
                locals.insert(*local_id, info);
            }

            // Compile method body with 'this' context
            let this_ctx = ThisContext {
                this_var,
                class_meta: class_meta.clone(),
            };

            // Handle decorators: inject decorator behavior before method body
            for data_id in &decorator_data {
                let local_data = self.module.declare_data_in_func(*data_id, builder.func);
                let str_ptr = builder.ins().symbol_value(types::I64, local_data);

                if let Some(print_id) = print_func_id {
                    let print_func_ref = self.module.declare_func_in_func(print_id, builder.func);
                    builder.ins().call(print_func_ref, &[str_ptr]);
                }
            }

            for stmt in &method.body {
                compile_stmt(
                    &mut builder,
                    &mut self.module,
                    &self.func_ids,
                    &self.closure_func_ids,
                    &self.func_wrapper_ids,
                    &self.extern_funcs,
                    &self.async_func_ids,
                    &self.closure_returning_funcs,
                    &self.classes,
                    &self.enums,
                    &self.func_param_types,
                    &self.func_union_params,
                    &self.func_return_types,
                    &self.func_hir_return_types,
                    &self.func_rest_param_index,
                    &self.imported_func_param_counts,
                    &mut locals,
                    &mut next_var,
                    stmt,
                    Some(&this_ctx),
                    None,
                    &boxed_vars,
                )?;
            }

            // If no explicit return, return 0 with correct type
            let current_block = builder.current_block().unwrap();
            if !is_block_filled(&builder, current_block) {
                let ret_type = builder.func.signature.returns.first().map(|p| p.value_type).unwrap_or(types::F64);
                let zero = match ret_type {
                    types::I64 => builder.ins().iconst(types::I64, 0),
                    types::I32 => builder.ins().iconst(types::I32, 0),
                    _ => builder.ins().f64const(0.0),
                };
                builder.ins().return_(&[zero]);
            }

            builder.finalize();
        }

        self.module.define_function(func_id, &mut self.ctx)?;
        self.module.clear_context(&mut self.ctx);

        Ok(())
    }

    /// Prepare decorator data (string constants, etc.) before code generation
    /// Returns a list of data IDs for strings to print
    fn prepare_decorators(
        &mut self,
        decorators: &[Decorator],
        method_name: &str,
    ) -> Result<Vec<cranelift_module::DataId>> {
        let mut data_ids = Vec::new();

        for decorator in decorators {
            match decorator.name.as_str() {
                "log" => {
                    // @log decorator: print "Calling <method_name>" before method execution
                    let msg = format!("Calling {}", method_name);

                    // Create or get the string data for the message
                    let data_id = if let Some(&existing) = self.string_data.get(&msg) {
                        existing
                    } else {
                        let mut data_desc = DataDescription::new();
                        let msg_bytes = msg.as_bytes();

                        // Build the string structure: [len: u32, cap: u32, data...]
                        // StringHeader is only 8 bytes (length + capacity), then data follows immediately
                        let total_len = 8 + msg_bytes.len();
                        let mut buffer = vec![0u8; total_len];

                        // Length (first 4 bytes)
                        let len_bytes = (msg_bytes.len() as u32).to_le_bytes();
                        buffer[0..4].copy_from_slice(&len_bytes);

                        // Capacity (next 4 bytes, same as length for static strings)
                        buffer[4..8].copy_from_slice(&len_bytes);

                        // String data (rest of the buffer, immediately after header)
                        buffer[8..].copy_from_slice(msg_bytes);

                        data_desc.define(buffer.into_boxed_slice());

                        let data_name = format!("decorator_str_{}", self.string_data.len());
                        let new_data_id = self.module.declare_data(&data_name, Linkage::Local, false, false)?;
                        self.module.define_data(new_data_id, &data_desc)?;
                        self.string_data.insert(msg.clone(), new_data_id);
                        new_data_id
                    };

                    data_ids.push(data_id);
                }
                _ => {
                    // Unknown decorator - ignore for now
                    // In a full implementation, we would call the decorator function
                }
            }
        }
        Ok(data_ids)
    }

    fn declare_class_getters(&mut self, class: &Class) -> Result<()> {
        for (prop_name, getter) in &class.getters {
            let mut sig = self.module.make_signature();

            // Getters take 'this' as first parameter (i64 pointer)
            sig.params.push(AbiParam::new(types::I64));

            // No other parameters for getters

            // Return type (f64 for now)
            sig.returns.push(AbiParam::new(types::F64));

            let func_name = format!("{}_get_{}", class.name, prop_name);
            let func_id = self.module.declare_function(&func_name, Linkage::Local, &sig)?;

            if let Some(meta) = self.classes.get_mut(&class.name) {
                meta.getter_ids.insert(prop_name.clone(), func_id);
            }
        }
        Ok(())
    }

    fn declare_class_setters(&mut self, class: &Class) -> Result<()> {
        for (prop_name, setter) in &class.setters {
            let mut sig = self.module.make_signature();

            // Setters take 'this' as first parameter (i64 pointer)
            sig.params.push(AbiParam::new(types::I64));

            // Then one value parameter
            for _ in &setter.params {
                sig.params.push(AbiParam::new(types::F64));
            }

            // Return type void (f64 for consistency)
            sig.returns.push(AbiParam::new(types::F64));

            let func_name = format!("{}_set_{}", class.name, prop_name);
            let func_id = self.module.declare_function(&func_name, Linkage::Local, &sig)?;

            if let Some(meta) = self.classes.get_mut(&class.name) {
                meta.setter_ids.insert(prop_name.clone(), func_id);
            }
        }
        Ok(())
    }

    fn compile_class_getter(&mut self, class: &Class, prop_name: &str, getter: &Function) -> Result<()> {
        let func_id = self.classes.get(&class.name)
            .and_then(|m| m.getter_ids.get(prop_name).copied())
            .ok_or_else(|| anyhow!("Getter not declared: {}::get_{}", class.name, prop_name))?;

        // Set up the function signature
        self.ctx.func.signature.params.clear();
        self.ctx.func.signature.returns.clear();

        // 'this' as first parameter
        self.ctx.func.signature.params.push(AbiParam::new(types::I64));

        // No other parameters for getters
        self.ctx.func.signature.returns.push(AbiParam::new(types::F64));

        let class_meta = self.classes.get(&class.name).cloned()
            .ok_or_else(|| anyhow!("Class metadata not found: {}", class.name))?;

        // Collect mutable captures before FunctionBuilder block
        let boxed_vars = self.collect_mutable_captures_from_stmts(&getter.body);

        {
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.append_block_params_for_function_params(entry_block);
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // 'this' is the first parameter (i64 pointer)
            let this_var = Variable::new(0);
            builder.declare_var(this_var, types::I64);
            let this_val = builder.block_params(entry_block)[0];
            builder.def_var(this_var, this_val);

            // No other parameters for getters
            let mut locals: HashMap<LocalId, LocalInfo> = HashMap::new();
            let mut next_var = 1usize;

            // Load module-level variables from their global slots
            for (local_id, data_id) in &self.module_var_data_ids {
                let (var_type, local_info_template) = if let Some(info) = self.module_level_locals.get(local_id) {
                    // Variable is stored as i64 only if is_pointer && !is_union
                    let vt = if info.is_pointer && !info.is_union { types::I64 } else { types::F64 };
                    (vt, info.clone())
                } else {
                    (types::F64, LocalInfo {
                        var: Variable::new(0),
                        name: None,
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false, is_array: false, is_string: false, is_bigint: false,
                        is_closure: false, is_boxed: false, is_map: false, is_set: false,
                        is_buffer: false, is_event_emitter: false, is_union: false, is_mixed_array: false, is_integer: false,
                        is_integer_array: false, is_i32: false, i32_shadow: None,
                        bounded_by_array: None, bounded_by_constant: None, scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    })
                };
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, var_type);
                let global_val = self.module.declare_data_in_func(*data_id, builder.func);
                let ptr = builder.ins().global_value(types::I64, global_val);
                let val = builder.ins().load(var_type, MemFlags::new(), ptr, 0);
                builder.def_var(var, val);
                let mut info = local_info_template;
                info.var = var;
                locals.insert(*local_id, info);
            }

            // Compile getter body with 'this' context
            let this_ctx = ThisContext {
                this_var,
                class_meta: class_meta.clone(),
            };

            for stmt in &getter.body {
                compile_stmt(
                    &mut builder,
                    &mut self.module,
                    &self.func_ids,
                    &self.closure_func_ids,
                    &self.func_wrapper_ids,
                    &self.extern_funcs,
                    &self.async_func_ids,
                    &self.closure_returning_funcs,
                    &self.classes,
                    &self.enums,
                    &self.func_param_types,
                    &self.func_union_params,
                    &self.func_return_types,
                    &self.func_hir_return_types,
                    &self.func_rest_param_index,
                    &self.imported_func_param_counts,
                    &mut locals,
                    &mut next_var,
                    stmt,
                    Some(&this_ctx),
                    None,
                    &boxed_vars,
                )?;
            }

            // If no explicit return, return 0 with correct type
            let current_block = builder.current_block().unwrap();
            if !is_block_filled(&builder, current_block) {
                let ret_type = builder.func.signature.returns.first().map(|p| p.value_type).unwrap_or(types::F64);
                let zero = match ret_type {
                    types::I64 => builder.ins().iconst(types::I64, 0),
                    types::I32 => builder.ins().iconst(types::I32, 0),
                    _ => builder.ins().f64const(0.0),
                };
                builder.ins().return_(&[zero]);
            }

            builder.finalize();
        }

        self.module.define_function(func_id, &mut self.ctx)?;
        self.module.clear_context(&mut self.ctx);

        Ok(())
    }

    fn compile_class_setter(&mut self, class: &Class, prop_name: &str, setter: &Function) -> Result<()> {
        let func_id = self.classes.get(&class.name)
            .and_then(|m| m.setter_ids.get(prop_name).copied())
            .ok_or_else(|| anyhow!("Setter not declared: {}::set_{}", class.name, prop_name))?;

        // Set up the function signature
        self.ctx.func.signature.params.clear();
        self.ctx.func.signature.returns.clear();

        // 'this' as first parameter
        self.ctx.func.signature.params.push(AbiParam::new(types::I64));

        // Value parameter
        for _ in &setter.params {
            self.ctx.func.signature.params.push(AbiParam::new(types::F64));
        }
        self.ctx.func.signature.returns.push(AbiParam::new(types::F64));

        let class_meta = self.classes.get(&class.name).cloned()
            .ok_or_else(|| anyhow!("Class metadata not found: {}", class.name))?;

        // Collect mutable captures before FunctionBuilder block
        let boxed_vars = self.collect_mutable_captures_from_stmts(&setter.body);

        {
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.append_block_params_for_function_params(entry_block);
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // 'this' is the first parameter (i64 pointer)
            let this_var = Variable::new(0);
            builder.declare_var(this_var, types::I64);
            let this_val = builder.block_params(entry_block)[0];
            builder.def_var(this_var, this_val);

            // Create variables for value parameters
            let mut locals: HashMap<LocalId, LocalInfo> = HashMap::new();
            let mut next_var = 1usize;
            for (i, param) in setter.params.iter().enumerate() {
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, types::F64);
                let val = builder.block_params(entry_block)[i + 1]; // +1 to skip 'this'
                builder.def_var(var, val);
                // Check parameter types for correct handling of string methods, array methods, etc.
                let is_closure = matches!(param.ty, perry_types::Type::Function(_));
                let is_string = matches!(param.ty, perry_types::Type::String);
                let is_array = matches!(param.ty, perry_types::Type::Array(_));
                let is_pointer = is_closure || is_string || is_array;
                locals.insert(param.id, LocalInfo {
                    var,
                    name: Some(param.name.clone()),
                    class_name: None,
                    type_args: Vec::new(),
                    is_pointer,
                    is_array,
                    is_string,
                    is_bigint: false,
                    is_closure,
                    is_boxed: false,
                    is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                    is_mixed_array: false,
                    is_integer: false,
                    is_integer_array: false,
                    is_i32: false,
                    i32_shadow: None,
                    bounded_by_array: None,
                    bounded_by_constant: None,
                    scalar_fields: None,
                    squared_cache: None, product_cache: None,
                });
            }

            // Load module-level variables from their global slots
            for (local_id, data_id) in &self.module_var_data_ids {
                let (var_type, local_info_template) = if let Some(info) = self.module_level_locals.get(local_id) {
                    // Variable is stored as i64 only if is_pointer && !is_union
                    let vt = if info.is_pointer && !info.is_union { types::I64 } else { types::F64 };
                    (vt, info.clone())
                } else {
                    (types::F64, LocalInfo {
                        var: Variable::new(0),
                        name: None,
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false, is_array: false, is_string: false, is_bigint: false,
                        is_closure: false, is_boxed: false, is_map: false, is_set: false,
                        is_buffer: false, is_event_emitter: false, is_union: false, is_mixed_array: false, is_integer: false,
                        is_integer_array: false, is_i32: false, i32_shadow: None,
                        bounded_by_array: None, bounded_by_constant: None, scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    })
                };
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, var_type);
                let global_val = self.module.declare_data_in_func(*data_id, builder.func);
                let ptr = builder.ins().global_value(types::I64, global_val);
                let val = builder.ins().load(var_type, MemFlags::new(), ptr, 0);
                builder.def_var(var, val);
                let mut info = local_info_template;
                info.var = var;
                locals.insert(*local_id, info);
            }

            // Compile setter body with 'this' context
            let this_ctx = ThisContext {
                this_var,
                class_meta: class_meta.clone(),
            };

            for stmt in &setter.body {
                compile_stmt(
                    &mut builder,
                    &mut self.module,
                    &self.func_ids,
                    &self.closure_func_ids,
                    &self.func_wrapper_ids,
                    &self.extern_funcs,
                    &self.async_func_ids,
                    &self.closure_returning_funcs,
                    &self.classes,
                    &self.enums,
                    &self.func_param_types,
                    &self.func_union_params,
                    &self.func_return_types,
                    &self.func_hir_return_types,
                    &self.func_rest_param_index,
                    &self.imported_func_param_counts,
                    &mut locals,
                    &mut next_var,
                    stmt,
                    Some(&this_ctx),
                    None,
                    &boxed_vars,
                )?;
            }

            // If no explicit return, return 0 with correct type
            let current_block = builder.current_block().unwrap();
            if !is_block_filled(&builder, current_block) {
                let ret_type = builder.func.signature.returns.first().map(|p| p.value_type).unwrap_or(types::F64);
                let zero = match ret_type {
                    types::I64 => builder.ins().iconst(types::I64, 0),
                    types::I32 => builder.ins().iconst(types::I32, 0),
                    _ => builder.ins().f64const(0.0),
                };
                builder.ins().return_(&[zero]);
            }

            builder.finalize();
        }

        self.module.define_function(func_id, &mut self.ctx)?;
        self.module.clear_context(&mut self.ctx);

        Ok(())
    }

    fn declare_static_methods(&mut self, class: &Class) -> Result<()> {
        for method in &class.static_methods {
            let mut sig = self.module.make_signature();

            // Static methods do NOT take 'this' - they're regular functions
            for _ in &method.params {
                sig.params.push(AbiParam::new(types::F64));
            }

            // Return type (f64 for now)
            sig.returns.push(AbiParam::new(types::F64));

            let func_name = format!("{}_{}_static", class.name, method.name);
            let func_id = self.module.declare_function(&func_name, Linkage::Local, &sig)?;

            if let Some(meta) = self.classes.get_mut(&class.name) {
                meta.static_method_ids.insert(method.name.clone(), func_id);
            }
        }
        Ok(())
    }

    fn declare_static_fields(&mut self, class: &Class) -> Result<()> {
        for field in &class.static_fields {
            // Static fields are global variables stored as 8 bytes (f64)
            let data_name = format!("{}_{}_static_field", class.name, field.name);
            let data_id = self.module.declare_data(&data_name, Linkage::Local, true, false)?;

            if let Some(meta) = self.classes.get_mut(&class.name) {
                meta.static_field_ids.insert(field.name.clone(), data_id);
            }
        }
        Ok(())
    }

    fn compile_static_method(&mut self, class: &Class, method: &Function) -> Result<()> {
        let func_name = format!("{}_{}_static", class.name, method.name);
        let func_id = self.classes.get(&class.name)
            .and_then(|m| m.static_method_ids.get(&method.name).copied())
            .ok_or_else(|| anyhow!("Static method not declared: {}::{}", class.name, method.name))?;

        // Set up the function signature
        self.ctx.func.signature.params.clear();
        self.ctx.func.signature.returns.clear();

        // Static methods do NOT have 'this'
        for _ in &method.params {
            self.ctx.func.signature.params.push(AbiParam::new(types::F64));
        }
        self.ctx.func.signature.returns.push(AbiParam::new(types::F64));

        // Collect mutable captures before FunctionBuilder block
        let boxed_vars = self.collect_mutable_captures_from_stmts(&method.body);

        {
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.append_block_params_for_function_params(entry_block);
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // Create variables for parameters (no 'this')
            let mut locals: HashMap<LocalId, LocalInfo> = HashMap::new();
            let mut next_var = 0usize;
            for (i, param) in method.params.iter().enumerate() {
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, types::F64);
                let val = builder.block_params(entry_block)[i];
                builder.def_var(var, val);
                // Check parameter types for correct handling of string methods, array methods, etc.
                let is_closure = matches!(param.ty, perry_types::Type::Function(_));
                let is_string = matches!(param.ty, perry_types::Type::String);
                let is_array = matches!(param.ty, perry_types::Type::Array(_));
                let is_pointer = is_closure || is_string || is_array;
                locals.insert(param.id, LocalInfo {
                    var,
                    name: Some(param.name.clone()),
                    class_name: None,
                    type_args: Vec::new(),
                    is_pointer,
                    is_array,
                    is_string,
                    is_bigint: false,
                    is_closure,
                    is_boxed: false,
                    is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                    is_mixed_array: false,
                    is_integer: false,
                    is_integer_array: false,
                    is_i32: false,
                    i32_shadow: None,
                    bounded_by_array: None,
                    bounded_by_constant: None,
                    scalar_fields: None,
                    squared_cache: None, product_cache: None,
                });
            }

            // Load module-level variables from their global slots
            for (local_id, data_id) in &self.module_var_data_ids {
                let (var_type, local_info_template) = if let Some(info) = self.module_level_locals.get(local_id) {
                    // Variable is stored as i64 only if is_pointer && !is_union
                    let vt = if info.is_pointer && !info.is_union { types::I64 } else { types::F64 };
                    (vt, info.clone())
                } else {
                    (types::F64, LocalInfo {
                        var: Variable::new(0),
                        name: None,
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false, is_array: false, is_string: false, is_bigint: false,
                        is_closure: false, is_boxed: false, is_map: false, is_set: false,
                        is_buffer: false, is_event_emitter: false, is_union: false, is_mixed_array: false, is_integer: false,
                        is_integer_array: false, is_i32: false, i32_shadow: None,
                        bounded_by_array: None, bounded_by_constant: None, scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    })
                };
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, var_type);
                let global_val = self.module.declare_data_in_func(*data_id, builder.func);
                let ptr = builder.ins().global_value(types::I64, global_val);
                let val = builder.ins().load(var_type, MemFlags::new(), ptr, 0);
                builder.def_var(var, val);
                let mut info = local_info_template;
                info.var = var;
                locals.insert(*local_id, info);
            }

            // Compile method body WITHOUT 'this' context
            for stmt in &method.body {
                compile_stmt(
                    &mut builder,
                    &mut self.module,
                    &self.func_ids,
                    &self.closure_func_ids,
                    &self.func_wrapper_ids,
                    &self.extern_funcs,
                    &self.async_func_ids,
                    &self.closure_returning_funcs,
                    &self.classes,
                    &self.enums,
                    &self.func_param_types,
                    &self.func_union_params,
                    &self.func_return_types,
                    &self.func_hir_return_types,
                    &self.func_rest_param_index,
                    &self.imported_func_param_counts,
                    &mut locals,
                    &mut next_var,
                    stmt,
                    None, // No 'this' context for static methods
                    None,
                    &boxed_vars,
                )?;
            }

            // If no explicit return, return 0 with correct type
            let current_block = builder.current_block().unwrap();
            if !is_block_filled(&builder, current_block) {
                let ret_type = builder.func.signature.returns.first().map(|p| p.value_type).unwrap_or(types::F64);
                let zero = match ret_type {
                    types::I64 => builder.ins().iconst(types::I64, 0),
                    types::I32 => builder.ins().iconst(types::I32, 0),
                    _ => builder.ins().f64const(0.0),
                };
                builder.ins().return_(&[zero]);
            }

            builder.finalize();
        }

        self.module.define_function(func_id, &mut self.ctx)?;
        self.module.clear_context(&mut self.ctx);

        Ok(())
    }

    fn compile_static_field(&mut self, class: &Class, field: &ClassField) -> Result<()> {
        let data_id = self.classes.get(&class.name)
            .and_then(|m| m.static_field_ids.get(&field.name).copied())
            .ok_or_else(|| anyhow!("Static field not declared: {}::{}", class.name, field.name))?;

        // Create data description and define the static field
        let mut data_desc = DataDescription::new();

        // Initialize with the field's init value or 0.0
        // For booleans, use NaN-boxed tags
        const TAG_TRUE: u64 = 0x7FFC_0000_0000_0004;
        const TAG_FALSE: u64 = 0x7FFC_0000_0000_0003;
        let init_value: f64 = match &field.init {
            Some(Expr::Number(n)) => *n,
            Some(Expr::Integer(n)) => *n as f64,
            Some(Expr::Bool(b)) => f64::from_bits(if *b { TAG_TRUE } else { TAG_FALSE }),
            _ => 0.0, // Default to 0.0 for other types
        };

        data_desc.init = Init::Bytes {
            contents: init_value.to_le_bytes().to_vec().into_boxed_slice(),
        };
        self.module.define_data(data_id, &data_desc)?;

        Ok(())
    }

    fn declare_class_constructor(&mut self, class: &Class) -> Result<()> {
        if let Some(ref ctor) = class.constructor {
            let mut sig = self.module.make_signature();

            // Constructor takes 'this' pointer as first parameter, then user params
            sig.params.push(AbiParam::new(types::I64)); // 'this' pointer
            for _ in &ctor.params {
                sig.params.push(AbiParam::new(types::F64));
            }
            // Constructor returns void - the object is passed in

            let func_name = format!("{}_constructor", class.name);
            // Export constructors for exported classes so other modules can call them
            let linkage = if class.is_exported { Linkage::Export } else { Linkage::Local };
            let func_id = self.module.declare_function(&func_name, linkage, &sig)?;

            if let Some(meta) = self.classes.get_mut(&class.name) {
                meta.constructor_id = Some(func_id);
            }
        }
        Ok(())
    }

    fn compile_class_constructor(&mut self, class: &Class, ctor: &Function) -> Result<()> {
        let func_name = format!("{}_constructor", class.name);
        let func_id = self.classes.get(&class.name)
            .and_then(|m| m.constructor_id)
            .ok_or_else(|| anyhow!("Constructor not declared for class {}", class.name))?;

        // Set up the function signature
        self.ctx.func.signature.params.clear();
        self.ctx.func.signature.returns.clear();

        // First parameter is 'this' pointer
        self.ctx.func.signature.params.push(AbiParam::new(types::I64));
        for _ in &ctor.params {
            self.ctx.func.signature.params.push(AbiParam::new(types::F64));
        }
        // Constructor returns void - the object is passed in

        let class_meta = self.classes.get(&class.name).cloned()
            .ok_or_else(|| anyhow!("Class metadata not found: {}", class.name))?;

        // Collect mutable captures before FunctionBuilder block
        let boxed_vars = self.collect_mutable_captures_from_stmts(&ctor.body);

        {
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.append_block_params_for_function_params(entry_block);
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // 'this' is passed as the first parameter
            let obj_ptr = builder.block_params(entry_block)[0];

            // 'this' is the object pointer
            let mut locals: HashMap<LocalId, LocalInfo> = HashMap::new();
            let this_var = Variable::new(0);
            builder.declare_var(this_var, types::I64);
            builder.def_var(this_var, obj_ptr);

            // Create variables for user parameters (starting from index 1 in block params)
            let mut next_var = 1usize;
            for (i, param) in ctor.params.iter().enumerate() {
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, types::F64);
                let val = builder.block_params(entry_block)[i + 1]; // +1 to skip 'this'
                builder.def_var(var, val);
                // Check parameter types for correct handling of string methods, array methods, etc.
                let is_closure = matches!(param.ty, perry_types::Type::Function(_));
                let is_string = matches!(param.ty, perry_types::Type::String);
                let is_array = matches!(param.ty, perry_types::Type::Array(_));
                let is_pointer = is_closure || is_string || is_array;
                locals.insert(param.id, LocalInfo {
                    var,
                    name: Some(param.name.clone()),
                    class_name: None,
                    type_args: Vec::new(),
                    is_pointer,
                    is_array,
                    is_string,
                    is_bigint: false,
                    is_closure,
                    is_boxed: false,
                    is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                    is_mixed_array: false,
                    is_integer: false,
                    is_integer_array: false,
                    is_i32: false,
                    i32_shadow: None,
                    bounded_by_array: None,
                    bounded_by_constant: None,
                    scalar_fields: None,
                    squared_cache: None, product_cache: None,
                });
            }

            // Load module-level variables from their global slots
            for (local_id, data_id) in &self.module_var_data_ids {
                let (var_type, local_info_template) = if let Some(info) = self.module_level_locals.get(local_id) {
                    // Variable is stored as i64 only if is_pointer && !is_union
                    let vt = if info.is_pointer && !info.is_union { types::I64 } else { types::F64 };
                    (vt, info.clone())
                } else {
                    (types::F64, LocalInfo {
                        var: Variable::new(0),
                        name: None,
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false, is_array: false, is_string: false, is_bigint: false,
                        is_closure: false, is_boxed: false, is_map: false, is_set: false,
                        is_buffer: false, is_event_emitter: false, is_union: false, is_mixed_array: false, is_integer: false,
                        is_integer_array: false, is_i32: false, i32_shadow: None,
                        bounded_by_array: None, bounded_by_constant: None, scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    })
                };
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, var_type);
                let global_val = self.module.declare_data_in_func(*data_id, builder.func);
                let ptr = builder.ins().global_value(types::I64, global_val);
                let val = builder.ins().load(var_type, MemFlags::new(), ptr, 0);
                builder.def_var(var, val);
                let mut info = local_info_template;
                info.var = var;
                locals.insert(*local_id, info);
            }

            // Compile constructor body with special handling for 'this'
            for stmt in &ctor.body {
                compile_stmt_with_this(
                    &mut builder,
                    &mut self.module,
                    &self.func_ids,
                    &self.closure_func_ids,
                    &self.func_wrapper_ids,
                    &self.extern_funcs,
                    &self.async_func_ids,
                    &self.closure_returning_funcs,
                    &self.classes,
                    &self.enums,
                    &self.func_param_types,
                    &self.func_union_params,
                    &self.func_return_types,
                    &self.func_hir_return_types,
                    &self.func_rest_param_index,
                    &self.imported_func_param_counts,
                    &mut locals,
                    &mut next_var,
                    stmt,
                    this_var,
                    &class_meta,
                    None,
                    &boxed_vars,
                )?;
            }

            // Return void
            builder.ins().return_(&[]);

            builder.finalize();
        }

        self.module.define_function(func_id, &mut self.ctx)?;
        self.module.clear_context(&mut self.ctx);

        Ok(())
    }

    fn declare_runtime_functions(&mut self) -> Result<()> {
        // Declare js_console_log_number(f64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_console_log_number",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_log_number".to_string(), func_id);
        }

        // Declare js_console_log_dynamic(f64) -> void (for union types)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_console_log_dynamic",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_log_dynamic".to_string(), func_id);
        }

        // Declare js_console_error_number(f64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_console_error_number",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_error_number".to_string(), func_id);
        }

        // Declare js_console_error_dynamic(f64) -> void (for union types)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_console_error_dynamic",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_error_dynamic".to_string(), func_id);
        }

        // Declare js_console_warn_number(f64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_console_warn_number",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_warn_number".to_string(), func_id);
        }

        // Declare js_console_warn_dynamic(f64) -> void (for union types)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_console_warn_dynamic",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_warn_dynamic".to_string(), func_id);
        }

        // Declare js_string_error(i64) -> void (for console.error with strings)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function(
                "js_string_error",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_error".to_string(), func_id);
        }

        // Declare js_string_warn(i64) -> void (for console.warn with strings)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function(
                "js_string_warn",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_warn".to_string(), func_id);
        }

        // Declare js_bigint_error(i64) -> void (for console.error with bigints)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function(
                "js_bigint_error",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_error".to_string(), func_id);
        }

        // Declare js_bigint_warn(i64) -> void (for console.warn with bigints)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function(
                "js_bigint_warn",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_warn".to_string(), func_id);
        }

        // Declare js_console_log_spread(arr: *const ArrayHeader) -> void (for console.log with spread)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_console_log_spread",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_log_spread".to_string(), func_id);
        }

        // Declare js_console_error_spread(arr: *const ArrayHeader) -> void (for console.error with spread)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_console_error_spread",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_error_spread".to_string(), func_id);
        }

        // Declare js_console_warn_spread(arr: *const ArrayHeader) -> void (for console.warn with spread)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_console_warn_spread",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_console_warn_spread".to_string(), func_id);
        }

        // Declare js_array_print(arr: *const ArrayHeader) -> void (for console.log with array)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_array_print",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_print".to_string(), func_id);
        }

        // Declare js_nanbox_pointer(i64) -> f64 (for union types with pointers)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // raw pointer
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed pointer
            let func_id = self.module.declare_function(
                "js_nanbox_pointer",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_nanbox_pointer".to_string(), func_id);
        }

        // Declare js_nanbox_string(i64) -> f64 (for union types with strings)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // raw string pointer
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed string (uses STRING_TAG)
            let func_id = self.module.declare_function(
                "js_nanbox_string",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_nanbox_string".to_string(), func_id);
        }

        // Declare js_nanbox_bigint(i64) -> f64 (for BigInt values)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // raw BigInt pointer
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed BigInt (uses BIGINT_TAG)
            let func_id = self.module.declare_function(
                "js_nanbox_bigint",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_nanbox_bigint".to_string(), func_id);
        }

        // Declare js_nanbox_get_string_pointer(f64) -> i64 (extract string pointer from NaN-boxed value)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed string value
            sig.returns.push(AbiParam::new(types::I64)); // raw string pointer
            let func_id = self.module.declare_function(
                "js_nanbox_get_string_pointer",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_nanbox_get_string_pointer".to_string(), func_id);
        }

        // Declare js_get_string_pointer_unified(f64) -> i64 (extract string pointer from either NaN-boxed or raw pointer)
        // This handles both properly NaN-boxed strings and raw pointers stored via bitcast
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // f64 value (NaN-boxed or bitcast pointer)
            sig.returns.push(AbiParam::new(types::I64)); // raw string pointer
            let func_id = self.module.declare_function(
                "js_get_string_pointer_unified",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_get_string_pointer_unified".to_string(), func_id);
        }

        // Declare js_nanbox_get_pointer(f64) -> i64 (extract pointer from NaN-boxed value)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed pointer value
            sig.returns.push(AbiParam::new(types::I64)); // raw pointer
            let func_id = self.module.declare_function(
                "js_nanbox_get_pointer",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_nanbox_get_pointer".to_string(), func_id);
        }

        // Declare js_nanbox_get_bigint(f64) -> i64 (extract BigInt pointer from NaN-boxed value)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed BigInt value
            sig.returns.push(AbiParam::new(types::I64)); // raw BigInt pointer
            let func_id = self.module.declare_function(
                "js_nanbox_get_bigint",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_nanbox_get_bigint".to_string(), func_id);
        }

        // Declare js_is_truthy(f64) -> i32 (check if value is truthy in JavaScript terms)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed value
            sig.returns.push(AbiParam::new(types::I32)); // 1 if truthy, 0 if falsy
            let func_id = self.module.declare_function(
                "js_is_truthy",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_is_truthy".to_string(), func_id);
        }

        // Declare js_object_alloc(class_id: i32, field_count: i32) -> *mut ObjectHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // class_id
            sig.params.push(AbiParam::new(types::I32)); // field_count
            sig.returns.push(AbiParam::new(types::I64)); // object pointer
            let func_id = self.module.declare_function(
                "js_object_alloc",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_alloc".to_string(), func_id);
        }

        // Declare js_object_alloc_with_parent(class_id: i32, parent_class_id: i32, field_count: i32) -> *mut ObjectHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // class_id
            sig.params.push(AbiParam::new(types::I32)); // parent_class_id
            sig.params.push(AbiParam::new(types::I32)); // field_count
            sig.returns.push(AbiParam::new(types::I64)); // object pointer
            let func_id = self.module.declare_function(
                "js_object_alloc_with_parent",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_alloc_with_parent".to_string(), func_id);
        }

        // Declare js_object_alloc_fast(class_id: i32, field_count: i32) -> *mut ObjectHeader (i64)
        // Fast bump allocation without field initialization
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // class_id
            sig.params.push(AbiParam::new(types::I32)); // field_count
            sig.returns.push(AbiParam::new(types::I64)); // object pointer
            let func_id = self.module.declare_function(
                "js_object_alloc_fast",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_alloc_fast".to_string(), func_id);
        }

        // Declare js_object_alloc_fast_with_parent(class_id: i32, parent_class_id: i32, field_count: i32) -> *mut ObjectHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // class_id
            sig.params.push(AbiParam::new(types::I32)); // parent_class_id
            sig.params.push(AbiParam::new(types::I32)); // field_count
            sig.returns.push(AbiParam::new(types::I64)); // object pointer
            let func_id = self.module.declare_function(
                "js_object_alloc_fast_with_parent",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_alloc_fast_with_parent".to_string(), func_id);
        }

        // Declare js_create_native_module_namespace(module_name_ptr: i64, module_name_len: i64) -> f64
        // Creates a native module namespace object for `import * as X from 'module'`
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // module_name_ptr
            sig.params.push(AbiParam::new(types::I64)); // module_name_len
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed object
            let func_id = self.module.declare_function(
                "js_create_native_module_namespace",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_create_native_module_namespace".to_string(), func_id);
        }

        // Declare js_instanceof(value: f64, class_id: i32) -> f64 (boolean as 1.0/0.0)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // value (NaN-boxed pointer)
            sig.params.push(AbiParam::new(types::I32)); // class_id
            sig.returns.push(AbiParam::new(types::F64)); // boolean result
            let func_id = self.module.declare_function(
                "js_instanceof",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_instanceof".to_string(), func_id);
        }

        // Declare js_object_has_property(obj: f64, key: f64) -> f64 (boolean as 1.0/0.0)
        // Used for the 'in' operator: "key" in obj
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // object (NaN-boxed pointer)
            sig.params.push(AbiParam::new(types::F64)); // key (NaN-boxed string)
            sig.returns.push(AbiParam::new(types::F64)); // boolean result
            let func_id = self.module.declare_function(
                "js_object_has_property",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_has_property".to_string(), func_id);
        }

        // Declare js_object_get_field(obj: i64, field_index: i32) -> f64 (JSValue as f64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.params.push(AbiParam::new(types::I32)); // field index
            sig.returns.push(AbiParam::new(types::F64)); // field value
            let func_id = self.module.declare_function(
                "js_object_get_field_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_get_field_f64".to_string(), func_id);
        }

        // Declare js_object_set_field(obj: i64, field_index: i32, value: f64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.params.push(AbiParam::new(types::I32)); // field index
            sig.params.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(
                "js_object_set_field_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_set_field_f64".to_string(), func_id);
        }

        // js_object_keys(obj: i64) -> *mut ArrayHeader (array of string keys)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.returns.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_object_keys",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_keys".to_string(), func_id);
        }

        // js_dynamic_object_keys(ptr: i64) -> *mut ArrayHeader (handles Error objects too)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.returns.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_dynamic_object_keys",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_dynamic_object_keys".to_string(), func_id);
        }

        // js_object_values(obj: i64) -> *mut ArrayHeader (array of values)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.returns.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_object_values",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_values".to_string(), func_id);
        }

        // js_object_entries(obj: i64) -> *mut ArrayHeader (array of [key, value] pairs)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.returns.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_object_entries",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_entries".to_string(), func_id);
        }

        // js_array_is_array(value: f64) -> f64 (1.0 if array, 0.0 otherwise)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::F64)); // boolean result
            let func_id = self.module.declare_function(
                "js_array_is_array",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_is_array".to_string(), func_id);
        }

        // js_object_get_field_by_name_f64(obj: i64, key_str: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.params.push(AbiParam::new(types::I64)); // key string pointer
            sig.returns.push(AbiParam::new(types::F64)); // field value
            let func_id = self.module.declare_function(
                "js_object_get_field_by_name_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_get_field_by_name_f64".to_string(), func_id);
        }

        // js_object_set_field_by_name(obj: i64, key_str: i64, value: f64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.params.push(AbiParam::new(types::I64)); // key string pointer
            sig.params.push(AbiParam::new(types::F64)); // value to set
            let func_id = self.module.declare_function(
                "js_object_set_field_by_name",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_set_field_by_name".to_string(), func_id);
        }

        // js_object_set_keys(obj: i64, keys_array: i64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.params.push(AbiParam::new(types::I64)); // keys array pointer
            let func_id = self.module.declare_function(
                "js_object_set_keys",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_object_set_keys".to_string(), func_id);
        }

        // Array runtime functions
        // js_array_from_f64(elements: *const f64, count: u32) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // elements pointer
            sig.params.push(AbiParam::new(types::I32)); // count
            sig.returns.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_array_from_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_from_f64".to_string(), func_id);
        }

        // js_array_length(arr: *const ArrayHeader) -> u32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.returns.push(AbiParam::new(types::I32)); // length
            let func_id = self.module.declare_function(
                "js_array_length",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_length".to_string(), func_id);
        }

        // js_array_get_f64(arr: *const ArrayHeader, index: u32) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.returns.push(AbiParam::new(types::F64)); // element value
            let func_id = self.module.declare_function(
                "js_array_get_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_get_f64".to_string(), func_id);
        }

        // js_array_set_f64(arr: *mut ArrayHeader, index: u32, value: f64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.params.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(
                "js_array_set_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_set_f64".to_string(), func_id);
        }

        // js_array_set_f64_extend(arr: *mut ArrayHeader, index: u32, value: f64) -> *mut ArrayHeader
        // This version extends the array if needed (JavaScript semantics)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I64)); // new array pointer
            let func_id = self.module.declare_function(
                "js_array_set_f64_extend",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_set_f64_extend".to_string(), func_id);
        }

        // js_array_alloc(capacity: u32) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // capacity
            sig.returns.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_array_alloc",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_alloc".to_string(), func_id);
        }

        // js_array_push_f64(arr: *mut ArrayHeader, value: f64) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I64)); // new array pointer
            let func_id = self.module.declare_function(
                "js_array_push_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_push_f64".to_string(), func_id);
        }

        // js_array_pop_f64(arr: *mut ArrayHeader) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.returns.push(AbiParam::new(types::F64)); // popped value
            let func_id = self.module.declare_function(
                "js_array_pop_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_pop_f64".to_string(), func_id);
        }

        // js_array_shift_f64(arr: *mut ArrayHeader) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.returns.push(AbiParam::new(types::F64)); // shifted value
            let func_id = self.module.declare_function(
                "js_array_shift_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_shift_f64".to_string(), func_id);
        }

        // js_array_unshift_f64(arr: *mut ArrayHeader, value: f64) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I64)); // new array pointer
            let func_id = self.module.declare_function(
                "js_array_unshift_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_unshift_f64".to_string(), func_id);
        }

        // js_array_indexOf_f64(arr: *const ArrayHeader, value: f64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I32)); // index (-1 if not found)
            let func_id = self.module.declare_function(
                "js_array_indexOf_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_indexOf_f64".to_string(), func_id);
        }

        // js_array_includes_f64(arr: *const ArrayHeader, value: f64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I32)); // 1 if found, 0 if not
            let func_id = self.module.declare_function(
                "js_array_includes_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_includes_f64".to_string(), func_id);
        }

        // js_array_includes_jsvalue(arr: *const ArrayHeader, value: f64) -> i32
        // Uses deep equality comparison for NaN-boxed values (handles string content comparison)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::F64)); // value (NaN-boxed)
            sig.returns.push(AbiParam::new(types::I32)); // 1 if found, 0 if not
            let func_id = self.module.declare_function(
                "js_array_includes_jsvalue",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_includes_jsvalue".to_string(), func_id);
        }

        // js_array_slice(arr: *const ArrayHeader, start: i32, end: i32) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I32)); // start index
            sig.params.push(AbiParam::new(types::I32)); // end index
            sig.returns.push(AbiParam::new(types::I64)); // new array pointer
            let func_id = self.module.declare_function(
                "js_array_slice",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_slice".to_string(), func_id);
        }

        // js_array_splice(arr: *mut ArrayHeader, start: i32, delete_count: i32, items: *const f64, items_count: u32, out_arr: *mut *mut ArrayHeader) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I32)); // start index
            sig.params.push(AbiParam::new(types::I32)); // delete count
            sig.params.push(AbiParam::new(types::I64)); // items pointer
            sig.params.push(AbiParam::new(types::I32)); // items count
            sig.params.push(AbiParam::new(types::I64)); // out_arr pointer (for updated array)
            sig.returns.push(AbiParam::new(types::I64)); // deleted elements array pointer
            let func_id = self.module.declare_function(
                "js_array_splice",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_splice".to_string(), func_id);
        }

        // js_array_concat(dest: *mut ArrayHeader, src: *const ArrayHeader) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // destination array pointer
            sig.params.push(AbiParam::new(types::I64)); // source array pointer
            sig.returns.push(AbiParam::new(types::I64)); // new destination array pointer
            let func_id = self.module.declare_function(
                "js_array_concat",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_concat".to_string(), func_id);
        }

        // === JSValue-based array functions for mixed-type arrays ===

        // js_array_from_jsvalue(elements: *const u64, count: u32) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // elements pointer (u64 array)
            sig.params.push(AbiParam::new(types::I32)); // count
            sig.returns.push(AbiParam::new(types::I64)); // array pointer
            let func_id = self.module.declare_function(
                "js_array_from_jsvalue",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_from_jsvalue".to_string(), func_id);
        }

        // js_array_get_jsvalue(arr: *const ArrayHeader, index: u32) -> u64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.returns.push(AbiParam::new(types::I64)); // JSValue bits (u64)
            let func_id = self.module.declare_function(
                "js_array_get_jsvalue",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_get_jsvalue".to_string(), func_id);
        }

        // js_array_set_jsvalue(arr: *mut ArrayHeader, index: u32, value: u64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.params.push(AbiParam::new(types::I64)); // JSValue bits (u64)
            let func_id = self.module.declare_function(
                "js_array_set_jsvalue",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_set_jsvalue".to_string(), func_id);
        }

        // js_array_push_jsvalue(arr: *mut ArrayHeader, value: u64) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I64)); // JSValue bits (u64)
            sig.returns.push(AbiParam::new(types::I64)); // new array pointer
            let func_id = self.module.declare_function(
                "js_array_push_jsvalue",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_push_jsvalue".to_string(), func_id);
        }

        // js_dynamic_array_get(arr_value: f64, index: i32) -> f64
        // Unified array access that handles both JS handle arrays and native arrays
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // array value (may be JS handle or native ptr)
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.returns.push(AbiParam::new(types::F64)); // element value as f64
            let func_id = self.module.declare_function(
                "js_dynamic_array_get",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_dynamic_array_get".to_string(), func_id);
        }

        // js_dynamic_array_length(arr_value: f64) -> i32
        // Unified array length that handles both JS handle arrays and native arrays
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // array value (may be JS handle or native ptr)
            sig.returns.push(AbiParam::new(types::I32)); // length
            let func_id = self.module.declare_function(
                "js_dynamic_array_length",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_dynamic_array_length".to_string(), func_id);
        }

        // js_dynamic_object_get_property(obj_value: f64, property_name_ptr: i64, property_name_len: usize) -> f64
        // Unified property access that handles both JS handle objects and native objects
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // object value (may be JS handle or native ptr)
            sig.params.push(AbiParam::new(types::I64)); // property name ptr
            sig.params.push(AbiParam::new(types::I64)); // property name length
            sig.returns.push(AbiParam::new(types::F64)); // property value as f64
            let func_id = self.module.declare_function(
                "js_dynamic_object_get_property",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_dynamic_object_get_property".to_string(), func_id);
        }

        // js_array_forEach(arr: *const ArrayHeader, callback: *const ClosureHeader) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I64)); // callback closure pointer
            // No return value
            let func_id = self.module.declare_function(
                "js_array_forEach",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_forEach".to_string(), func_id);
        }

        // js_array_map(arr: *const ArrayHeader, callback: *const ClosureHeader) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I64)); // callback closure pointer
            sig.returns.push(AbiParam::new(types::I64)); // new array pointer
            let func_id = self.module.declare_function(
                "js_array_map",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_map".to_string(), func_id);
        }

        // js_array_filter(arr: *const ArrayHeader, callback: *const ClosureHeader) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I64)); // callback closure pointer
            sig.returns.push(AbiParam::new(types::I64)); // new array pointer
            let func_id = self.module.declare_function(
                "js_array_filter",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_filter".to_string(), func_id);
        }

        // js_array_find(arr: *const ArrayHeader, callback: *const ClosureHeader) -> f64 (element or NaN)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I64)); // callback closure pointer
            sig.returns.push(AbiParam::new(types::F64)); // element or NaN if not found
            let func_id = self.module.declare_function(
                "js_array_find",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_find".to_string(), func_id);
        }

        // js_array_findIndex(arr: *const ArrayHeader, callback: *const ClosureHeader) -> i32 (index or -1)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I64)); // callback closure pointer
            sig.returns.push(AbiParam::new(types::I32)); // index or -1
            let func_id = self.module.declare_function(
                "js_array_findIndex",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_findIndex".to_string(), func_id);
        }

        // js_dynamic_array_find(arr_value: f64, callback: *const ClosureHeader) -> f64
        // Handles both JS handle arrays and native arrays
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // array value (may be NaN-boxed or JS handle)
            sig.params.push(AbiParam::new(types::I64)); // callback closure pointer
            sig.returns.push(AbiParam::new(types::F64)); // element or NaN if not found
            let func_id = self.module.declare_function(
                "js_dynamic_array_find",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_dynamic_array_find".to_string(), func_id);
        }

        // js_dynamic_array_findIndex(arr_value: f64, callback: *const ClosureHeader) -> f64
        // Handles both JS handle arrays and native arrays
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // array value (may be NaN-boxed or JS handle)
            sig.params.push(AbiParam::new(types::I64)); // callback closure pointer
            sig.returns.push(AbiParam::new(types::F64)); // index as f64 or -1.0
            let func_id = self.module.declare_function(
                "js_dynamic_array_findIndex",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_dynamic_array_findIndex".to_string(), func_id);
        }

        // js_array_reduce(arr, callback, has_initial, initial) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I64)); // callback closure pointer
            sig.params.push(AbiParam::new(types::I32)); // has_initial flag
            sig.params.push(AbiParam::new(types::F64)); // initial value
            sig.returns.push(AbiParam::new(types::F64)); // result
            let func_id = self.module.declare_function(
                "js_array_reduce",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_reduce".to_string(), func_id);
        }

        // js_array_join(arr, separator) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array pointer
            sig.params.push(AbiParam::new(types::I64)); // separator string pointer (nullable)
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function(
                "js_array_join",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_array_join".to_string(), func_id);
        }

        // js_array_length (for getting length after push to return)
        // Already declared above

        // Map runtime functions
        // js_map_alloc(capacity: u32) -> *mut MapHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // capacity
            sig.returns.push(AbiParam::new(types::I64)); // map pointer
            let func_id = self.module.declare_function(
                "js_map_alloc",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_map_alloc".to_string(), func_id);
        }

        // js_map_size(map: *const MapHeader) -> u32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // map pointer
            sig.returns.push(AbiParam::new(types::I32)); // size
            let func_id = self.module.declare_function(
                "js_map_size",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_map_size".to_string(), func_id);
        }

        // js_map_set(map: *mut MapHeader, key: f64, value: f64) -> *mut MapHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // map pointer
            sig.params.push(AbiParam::new(types::F64)); // key (as JSValue bits)
            sig.params.push(AbiParam::new(types::F64)); // value (as JSValue bits)
            sig.returns.push(AbiParam::new(types::I64)); // new map pointer
            let func_id = self.module.declare_function(
                "js_map_set",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_map_set".to_string(), func_id);
        }

        // js_map_get(map: *const MapHeader, key: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // map pointer
            sig.params.push(AbiParam::new(types::F64)); // key
            sig.returns.push(AbiParam::new(types::F64)); // value (as JSValue bits)
            let func_id = self.module.declare_function(
                "js_map_get",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_map_get".to_string(), func_id);
        }

        // js_map_has(map: *const MapHeader, key: f64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // map pointer
            sig.params.push(AbiParam::new(types::F64)); // key
            sig.returns.push(AbiParam::new(types::I32)); // 1 if found, 0 if not
            let func_id = self.module.declare_function(
                "js_map_has",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_map_has".to_string(), func_id);
        }

        // js_map_delete(map: *mut MapHeader, key: f64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // map pointer
            sig.params.push(AbiParam::new(types::F64)); // key
            sig.returns.push(AbiParam::new(types::I32)); // 1 if deleted, 0 if not found
            let func_id = self.module.declare_function(
                "js_map_delete",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_map_delete".to_string(), func_id);
        }

        // js_map_clear(map: *mut MapHeader) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // map pointer
            // No return value
            let func_id = self.module.declare_function(
                "js_map_clear",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_map_clear".to_string(), func_id);
        }

        // Set runtime functions
        // js_set_alloc(capacity: u32) -> *mut SetHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // capacity
            sig.returns.push(AbiParam::new(types::I64)); // set pointer
            let func_id = self.module.declare_function(
                "js_set_alloc",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_set_alloc".to_string(), func_id);
        }

        // js_set_size(set: *const SetHeader) -> u32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // set pointer
            sig.returns.push(AbiParam::new(types::I32)); // size
            let func_id = self.module.declare_function(
                "js_set_size",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_set_size".to_string(), func_id);
        }

        // js_set_add(set: *mut SetHeader, value: f64) -> *mut SetHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // set pointer
            sig.params.push(AbiParam::new(types::F64)); // value (as JSValue bits)
            sig.returns.push(AbiParam::new(types::I64)); // new set pointer
            let func_id = self.module.declare_function(
                "js_set_add",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_set_add".to_string(), func_id);
        }

        // js_set_has(set: *const SetHeader, value: f64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // set pointer
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I32)); // 1 if found, 0 if not
            let func_id = self.module.declare_function(
                "js_set_has",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_set_has".to_string(), func_id);
        }

        // js_set_delete(set: *mut SetHeader, value: f64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // set pointer
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I32)); // 1 if deleted, 0 if not found
            let func_id = self.module.declare_function(
                "js_set_delete",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_set_delete".to_string(), func_id);
        }

        // js_set_clear(set: *mut SetHeader) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // set pointer
            // No return value
            let func_id = self.module.declare_function(
                "js_set_clear",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_set_clear".to_string(), func_id);
        }

        // String runtime functions
        // js_string_from_bytes(data: *const u8, len: u32) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data pointer
            sig.params.push(AbiParam::new(types::I32)); // length
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function(
                "js_string_from_bytes",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_from_bytes".to_string(), func_id);
        }

        // js_string_length(s: *const StringHeader) -> u32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::I32)); // length
            let func_id = self.module.declare_function(
                "js_string_length",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_length".to_string(), func_id);
        }

        // js_string_concat(a: *const StringHeader, b: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_concat",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_concat".to_string(), func_id);
        }

        // js_string_append(dest: *mut StringHeader, src: *const StringHeader) -> *mut StringHeader
        // In-place append with reallocation if needed - for `str = str + x` patterns
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // dest pointer (mutable)
            sig.params.push(AbiParam::new(types::I64)); // src pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer (may be reallocated)
            let func_id = self.module.declare_function(
                "js_string_append",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_append".to_string(), func_id);
        }

        // js_number_to_string(value: f64) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // number value
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_number_to_string",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_number_to_string".to_string(), func_id);
        }

        // js_jsvalue_to_string(value: f64) -> *mut StringHeader
        // Converts any NaN-boxed value to string (handles strings, numbers, etc.)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed value
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_jsvalue_to_string",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_jsvalue_to_string".to_string(), func_id);
        }

        // js_ensure_string_ptr(value: f64) -> i64
        // Ensures a value is a native string pointer - handles raw pointers, NaN-boxed strings, and JS handles
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // value (may be raw pointer, NaN-boxed, or JS handle)
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function(
                "js_ensure_string_ptr",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_ensure_string_ptr".to_string(), func_id);
        }

        // js_string_slice(s: *const StringHeader, start: i32, end: i32) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I32)); // start
            sig.params.push(AbiParam::new(types::I32)); // end
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_slice",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_slice".to_string(), func_id);
        }

        // js_string_substring(s: *const StringHeader, start: i32, end: i32) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I32)); // start
            sig.params.push(AbiParam::new(types::I32)); // end
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_substring",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_substring".to_string(), func_id);
        }

        // js_string_char_at(s: *const StringHeader, index: i32) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.returns.push(AbiParam::new(types::I64)); // result pointer (single-char string)
            let func_id = self.module.declare_function(
                "js_string_char_at",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_char_at".to_string(), func_id);
        }

        // js_string_char_code_at(s: *const StringHeader, index: i32) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.returns.push(AbiParam::new(types::F64)); // UTF-16 code unit or NaN
            let func_id = self.module.declare_function(
                "js_string_char_code_at",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_char_code_at".to_string(), func_id);
        }

        // js_string_pad_start(s: *const StringHeader, target_length: u32, pad_string: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I32)); // target length
            sig.params.push(AbiParam::new(types::I64)); // pad string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_pad_start",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_pad_start".to_string(), func_id);
        }

        // js_string_pad_end(s: *const StringHeader, target_length: u32, pad_string: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I32)); // target length
            sig.params.push(AbiParam::new(types::I64)); // pad string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_pad_end",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_pad_end".to_string(), func_id);
        }

        // js_string_alloc_space() -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_alloc_space",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_alloc_space".to_string(), func_id);
        }

        // js_string_trim(s: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_trim",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_trim".to_string(), func_id);
        }

        // js_string_to_lower_case(s: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_to_lower_case",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_to_lower_case".to_string(), func_id);
        }

        // js_string_to_upper_case(s: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_string_to_upper_case",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_to_upper_case".to_string(), func_id);
        }

        // js_string_index_of(haystack: *const StringHeader, needle: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // haystack pointer
            sig.params.push(AbiParam::new(types::I64)); // needle pointer
            sig.returns.push(AbiParam::new(types::I32)); // index or -1
            let func_id = self.module.declare_function(
                "js_string_index_of",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_index_of".to_string(), func_id);
        }

        // js_string_index_of_from(haystack: *const StringHeader, needle: *const StringHeader, from_index: i32) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // haystack pointer
            sig.params.push(AbiParam::new(types::I64)); // needle pointer
            sig.params.push(AbiParam::new(types::I32)); // from_index
            sig.returns.push(AbiParam::new(types::I32)); // index or -1
            let func_id = self.module.declare_function(
                "js_string_index_of_from",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_index_of_from".to_string(), func_id);
        }

        // js_string_split(s: *const StringHeader, delimiter: *const StringHeader) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I64)); // delimiter pointer
            sig.returns.push(AbiParam::new(types::I64)); // result array pointer
            let func_id = self.module.declare_function(
                "js_string_split",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_split".to_string(), func_id);
        }

        // js_string_starts_with(s: *const StringHeader, prefix: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I64)); // prefix pointer
            sig.returns.push(AbiParam::new(types::I32)); // 0 or 1
            let func_id = self.module.declare_function(
                "js_string_starts_with",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_starts_with".to_string(), func_id);
        }

        // js_string_ends_with(s: *const StringHeader, suffix: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I64)); // suffix pointer
            sig.returns.push(AbiParam::new(types::I32)); // 0 or 1
            let func_id = self.module.declare_function(
                "js_string_ends_with",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_ends_with".to_string(), func_id);
        }

        // js_string_repeat(s: *const StringHeader, count: i32) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I32)); // count
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function(
                "js_string_repeat",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_repeat".to_string(), func_id);
        }

        // js_string_print(s: *const StringHeader)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function(
                "js_string_print",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_string_print".to_string(), func_id);
        }

        // js_getenv(name_ptr: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // name string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer (or null)
            let func_id = self.module.declare_function(
                "js_getenv",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_getenv".to_string(), func_id);
        }

        // js_process_exit(code: f64) -> void (never returns)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // exit code
            let func_id = self.module.declare_function(
                "js_process_exit",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_process_exit".to_string(), func_id);
        }

        // File system runtime functions
        // js_fs_read_file_sync(path_ptr: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.returns.push(AbiParam::new(types::I64)); // content string pointer (or null)
            let func_id = self.module.declare_function(
                "js_fs_read_file_sync",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_fs_read_file_sync".to_string(), func_id);
        }

        // js_fs_write_file_sync(path_ptr: *const StringHeader, content_ptr: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.params.push(AbiParam::new(types::I64)); // content string pointer
            sig.returns.push(AbiParam::new(types::I32)); // 1 on success, 0 on failure
            let func_id = self.module.declare_function(
                "js_fs_write_file_sync",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_fs_write_file_sync".to_string(), func_id);
        }

        // js_fs_append_file_sync(path_ptr: *const StringHeader, content_ptr: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.params.push(AbiParam::new(types::I64)); // content string pointer
            sig.returns.push(AbiParam::new(types::I32)); // 1 on success, 0 on failure
            let func_id = self.module.declare_function(
                "js_fs_append_file_sync",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_fs_append_file_sync".to_string(), func_id);
        }

        // js_fs_exists_sync(path_ptr: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.returns.push(AbiParam::new(types::I32)); // 1 if exists, 0 if not
            let func_id = self.module.declare_function(
                "js_fs_exists_sync",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_fs_exists_sync".to_string(), func_id);
        }

        // js_fs_mkdir_sync(path_ptr: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.returns.push(AbiParam::new(types::I32)); // 1 on success, 0 on failure
            let func_id = self.module.declare_function(
                "js_fs_mkdir_sync",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_fs_mkdir_sync".to_string(), func_id);
        }

        // js_fs_unlink_sync(path_ptr: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.returns.push(AbiParam::new(types::I32)); // 1 on success, 0 on failure
            let func_id = self.module.declare_function(
                "js_fs_unlink_sync",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_fs_unlink_sync".to_string(), func_id);
        }

        // Path runtime functions
        // js_path_join(a: *const StringHeader, b: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a string pointer
            sig.params.push(AbiParam::new(types::I64)); // b string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function(
                "js_path_join",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_path_join".to_string(), func_id);
        }

        // js_path_dirname(path: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function(
                "js_path_dirname",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_path_dirname".to_string(), func_id);
        }

        // js_path_basename(path: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function(
                "js_path_basename",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_path_basename".to_string(), func_id);
        }

        // js_path_extname(path: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function(
                "js_path_extname",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_path_extname".to_string(), func_id);
        }

        // js_path_resolve(path: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function(
                "js_path_resolve",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_path_resolve".to_string(), func_id);
        }

        // BigInt runtime functions
        // js_bigint_from_string(data: *const u8, len: u32) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data pointer
            sig.params.push(AbiParam::new(types::I32)); // length
            sig.returns.push(AbiParam::new(types::I64)); // bigint pointer
            let func_id = self.module.declare_function(
                "js_bigint_from_string",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_from_string".to_string(), func_id);
        }

        // js_bigint_from_i64(value: i64) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // value
            sig.returns.push(AbiParam::new(types::I64)); // bigint pointer
            let func_id = self.module.declare_function(
                "js_bigint_from_i64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_from_i64".to_string(), func_id);
        }

        // js_bigint_add(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_add",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_add".to_string(), func_id);
        }

        // js_bigint_sub(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_sub",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_sub".to_string(), func_id);
        }

        // js_bigint_mul(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_mul",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_mul".to_string(), func_id);
        }

        // js_bigint_div(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_div",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_div".to_string(), func_id);
        }

        // js_bigint_mod(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_mod",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_mod".to_string(), func_id);
        }

        // js_bigint_pow(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_pow",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_pow".to_string(), func_id);
        }

        // js_bigint_shl(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_shl",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_shl".to_string(), func_id);
        }

        // js_bigint_shr(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_shr",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_shr".to_string(), func_id);
        }

        // js_bigint_and(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_and",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_and".to_string(), func_id);
        }

        // js_bigint_or(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_or",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_or".to_string(), func_id);
        }

        // js_bigint_xor(a: *const BigIntHeader, b: *const BigIntHeader) -> *mut BigIntHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I64)); // result pointer
            let func_id = self.module.declare_function(
                "js_bigint_xor",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_xor".to_string(), func_id);
        }

        // js_bigint_cmp(a: *const BigIntHeader, b: *const BigIntHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a pointer
            sig.params.push(AbiParam::new(types::I64)); // b pointer
            sig.returns.push(AbiParam::new(types::I32)); // -1, 0, or 1
            let func_id = self.module.declare_function(
                "js_bigint_cmp",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_cmp".to_string(), func_id);
        }

        // js_bigint_print(a: *const BigIntHeader)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // bigint pointer
            let func_id = self.module.declare_function(
                "js_bigint_print",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_print".to_string(), func_id);
        }

        // js_bigint_to_string(a: *const BigIntHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // bigint pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function(
                "js_bigint_to_string",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_bigint_to_string".to_string(), func_id);
        }

        // Closure runtime functions
        // js_closure_alloc(func_ptr: *const u8, capture_count: u32) -> *mut ClosureHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // func_ptr
            sig.params.push(AbiParam::new(types::I32)); // capture_count
            sig.returns.push(AbiParam::new(types::I64)); // closure pointer
            let func_id = self.module.declare_function(
                "js_closure_alloc",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_closure_alloc".to_string(), func_id);
        }

        // js_closure_set_capture_f64(closure: *mut ClosureHeader, index: u32, value: f64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // closure pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.params.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(
                "js_closure_set_capture_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_closure_set_capture_f64".to_string(), func_id);
        }

        // js_closure_get_capture_f64(closure: *const ClosureHeader, index: u32) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // closure pointer
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.returns.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(
                "js_closure_get_capture_f64",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_closure_get_capture_f64".to_string(), func_id);
        }

        // js_closure_call0(closure: *const ClosureHeader) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // closure pointer
            sig.returns.push(AbiParam::new(types::F64)); // return value
            let func_id = self.module.declare_function(
                "js_closure_call0",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_closure_call0".to_string(), func_id);
        }

        // js_closure_call1(closure: *const ClosureHeader, arg0: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // closure pointer
            sig.params.push(AbiParam::new(types::F64)); // arg0
            sig.returns.push(AbiParam::new(types::F64)); // return value
            let func_id = self.module.declare_function(
                "js_closure_call1",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_closure_call1".to_string(), func_id);
        }

        // js_closure_call2(closure: *const ClosureHeader, arg0: f64, arg1: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // closure pointer
            sig.params.push(AbiParam::new(types::F64)); // arg0
            sig.params.push(AbiParam::new(types::F64)); // arg1
            sig.returns.push(AbiParam::new(types::F64)); // return value
            let func_id = self.module.declare_function(
                "js_closure_call2",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_closure_call2".to_string(), func_id);
        }

        // js_closure_call3(closure: *const ClosureHeader, arg0: f64, arg1: f64, arg2: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // closure pointer
            sig.params.push(AbiParam::new(types::F64)); // arg0
            sig.params.push(AbiParam::new(types::F64)); // arg1
            sig.params.push(AbiParam::new(types::F64)); // arg2
            sig.returns.push(AbiParam::new(types::F64)); // return value
            let func_id = self.module.declare_function(
                "js_closure_call3",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_closure_call3".to_string(), func_id);
        }

        // js_closure_call4(closure: *const ClosureHeader, arg0: f64, arg1: f64, arg2: f64, arg3: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // closure pointer
            sig.params.push(AbiParam::new(types::F64)); // arg0
            sig.params.push(AbiParam::new(types::F64)); // arg1
            sig.params.push(AbiParam::new(types::F64)); // arg2
            sig.params.push(AbiParam::new(types::F64)); // arg3
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_closure_call4",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_closure_call4".to_string(), func_id);
        }

        // Box runtime functions for mutable captured variables
        // js_box_alloc(initial_value: f64) -> *mut Box
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // initial value
            sig.returns.push(AbiParam::new(types::I64)); // box pointer
            let func_id = self.module.declare_function(
                "js_box_alloc",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_box_alloc".to_string(), func_id);
        }

        // js_box_get(ptr: *mut Box) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // box pointer
            sig.returns.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(
                "js_box_get",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_box_get".to_string(), func_id);
        }

        // js_box_set(ptr: *mut Box, value: f64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // box pointer
            sig.params.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(
                "js_box_set",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_box_set".to_string(), func_id);
        }

        // Exception handling runtime functions
        // js_try_push() -> *mut i32 (pointer to jmp_buf)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // pointer
            let func_id = self.module.declare_function(
                "js_try_push",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_try_push".to_string(), func_id);
        }

        // setjmp(env: *mut i32) -> i32 (0 if normal entry, non-zero if from longjmp)
        // This is a libc function that must be called directly from generated code
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // pointer
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function(
                "setjmp",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("setjmp".to_string(), func_id);
        }

        // js_try_end()
        {
            let sig = self.module.make_signature();
            let func_id = self.module.declare_function(
                "js_try_end",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_try_end".to_string(), func_id);
        }

        // js_throw(value: f64) -> !
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_throw",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_throw".to_string(), func_id);
        }

        // js_get_exception() -> f64
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_get_exception",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_get_exception".to_string(), func_id);
        }

        // js_clear_exception()
        {
            let sig = self.module.make_signature();
            let func_id = self.module.declare_function(
                "js_clear_exception",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_clear_exception".to_string(), func_id);
        }

        // js_enter_finally()
        {
            let sig = self.module.make_signature();
            let func_id = self.module.declare_function(
                "js_enter_finally",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_enter_finally".to_string(), func_id);
        }

        // js_leave_finally()
        {
            let sig = self.module.make_signature();
            let func_id = self.module.declare_function(
                "js_leave_finally",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_leave_finally".to_string(), func_id);
        }

        // js_has_exception() -> i32
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function(
                "js_has_exception",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_has_exception".to_string(), func_id);
        }

        // Promise runtime functions
        // js_promise_new() -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function(
                "js_promise_new",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_new".to_string(), func_id);
        }

        // js_promise_resolve(promise: i64, value: f64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.params.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(
                "js_promise_resolve",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_resolve".to_string(), func_id);
        }

        // js_promise_resolve_with_promise(outer: i64, inner: i64)
        // Used when returning a Promise from an async function - chains the promises
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // outer promise pointer
            sig.params.push(AbiParam::new(types::I64)); // inner promise pointer
            let func_id = self.module.declare_function(
                "js_promise_resolve_with_promise",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_resolve_with_promise".to_string(), func_id);
        }

        // js_promise_state(promise: i64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.returns.push(AbiParam::new(types::I32)); // state
            let func_id = self.module.declare_function(
                "js_promise_state",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_state".to_string(), func_id);
        }

        // js_promise_value(promise: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.returns.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(
                "js_promise_value",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_value".to_string(), func_id);
        }

        // js_promise_reason(promise: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.returns.push(AbiParam::new(types::F64)); // reason
            let func_id = self.module.declare_function(
                "js_promise_reason",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_reason".to_string(), func_id);
        }

        // js_promise_result(promise: i64) -> f64
        // Returns value if fulfilled, reason if rejected
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.returns.push(AbiParam::new(types::F64)); // result (value or reason)
            let func_id = self.module.declare_function(
                "js_promise_result",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_result".to_string(), func_id);
        }

        // js_promise_resolved(value: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I64)); // promise pointer
            let func_id = self.module.declare_function(
                "js_promise_resolved",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_resolved".to_string(), func_id);
        }

        // js_promise_rejected(reason: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // reason
            sig.returns.push(AbiParam::new(types::I64)); // promise pointer
            let func_id = self.module.declare_function(
                "js_promise_rejected",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_rejected".to_string(), func_id);
        }

        // js_promise_all(promises_arr: i64) -> i64
        // Takes an array of promises, returns a promise that resolves with array of results
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array of promises pointer
            sig.returns.push(AbiParam::new(types::I64)); // result promise pointer
            let func_id = self.module.declare_function(
                "js_promise_all",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_all".to_string(), func_id);
        }

        // js_promise_run_microtasks() -> i32
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function(
                "js_promise_run_microtasks",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_run_microtasks".to_string(), func_id);
        }

        // js_promise_schedule_resolve(promise: i64, value: f64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_promise_schedule_resolve",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_schedule_resolve".to_string(), func_id);
        }

        // js_promise_new_with_executor(executor: i64) -> i64
        // Create a Promise with an executor callback (resolve, reject) => void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // executor closure pointer
            sig.returns.push(AbiParam::new(types::I64)); // promise pointer
            let func_id = self.module.declare_function(
                "js_promise_new_with_executor",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_new_with_executor".to_string(), func_id);
        }

        // js_promise_reject(promise: i64, reason: f64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.params.push(AbiParam::new(types::F64)); // reason
            let func_id = self.module.declare_function(
                "js_promise_reject",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_reject".to_string(), func_id);
        }

        // js_promise_then(promise: i64, on_fulfilled: i64, on_rejected: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.params.push(AbiParam::new(types::I64)); // on_fulfilled callback (nullable)
            sig.params.push(AbiParam::new(types::I64)); // on_rejected callback (nullable)
            sig.returns.push(AbiParam::new(types::I64)); // new promise
            let func_id = self.module.declare_function(
                "js_promise_then",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_then".to_string(), func_id);
        }

        // js_promise_catch(promise: i64, on_rejected: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.params.push(AbiParam::new(types::I64)); // on_rejected callback (nullable)
            sig.returns.push(AbiParam::new(types::I64)); // new promise
            let func_id = self.module.declare_function(
                "js_promise_catch",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_catch".to_string(), func_id);
        }

        // js_promise_finally(promise: i64, on_finally: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // promise pointer
            sig.params.push(AbiParam::new(types::I64)); // on_finally callback (nullable)
            sig.returns.push(AbiParam::new(types::I64)); // new promise
            let func_id = self.module.declare_function(
                "js_promise_finally",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_promise_finally".to_string(), func_id);
        }

        // Timer functions
        // js_set_timeout(delay_ms: f64) -> *mut Promise (i64)
        // Native setTimeout that returns a Promise directly
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function(
                "js_set_timeout",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_set_timeout".to_string(), func_id);
        }

        // js_set_timeout_callback(callback: i64, delay_ms: f64) -> i64
        // JS-style setTimeout that takes a callback function
        // Also exposed as "setTimeout" for TypeScript compatibility
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // callback (closure pointer)
            sig.params.push(AbiParam::new(types::F64)); // delay_ms
            sig.returns.push(AbiParam::new(types::I64)); // timer ID (or 0)
            let func_id = self.module.declare_function(
                "js_set_timeout_callback",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_set_timeout_callback".to_string(), func_id);
            // Also register as "setTimeout" for TypeScript code (2-arg version)
            self.extern_funcs.insert("setTimeout".to_string(), func_id);
        }

        // js_sleep_ms(ms: f64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(
                "js_sleep_ms",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_sleep_ms".to_string(), func_id);
        }

        // setInterval(callback: i64, interval_ms: f64) -> i64
        // JS-style setInterval that takes a callback function and interval
        // Returns an interval ID for use with clearInterval
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // callback (closure pointer)
            sig.params.push(AbiParam::new(types::F64)); // interval_ms
            sig.returns.push(AbiParam::new(types::I64)); // interval ID
            let func_id = self.module.declare_function(
                "setInterval",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("setInterval".to_string(), func_id);
        }

        // clearInterval(interval_id: i64)
        // Stops an interval timer by its ID
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // interval_id
            let func_id = self.module.declare_function(
                "clearInterval",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("clearInterval".to_string(), func_id);
        }

        // js_interval_timer_tick() -> i32
        // Process expired interval timers
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function(
                "js_interval_timer_tick",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_interval_timer_tick".to_string(), func_id);
        }

        // js_interval_timer_has_pending() -> i32
        // Check if there are pending interval timers
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function(
                "js_interval_timer_has_pending",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_interval_timer_has_pending".to_string(), func_id);
        }

        // ========================================================================
        // MySQL2 stdlib functions
        // ========================================================================

        // js_mysql2_create_connection(config: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // config object pointer
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_create_connection",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_create_connection".to_string(), func_id);
        }

        // js_mysql2_connection_end(conn: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_connection_end",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_connection_end".to_string(), func_id);
        }

        // js_mysql2_connection_query(conn: i64, sql: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            sig.params.push(AbiParam::new(types::I64)); // sql string pointer
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_connection_query",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_connection_query".to_string(), func_id);
        }

        // js_mysql2_connection_execute(conn: i64, sql: i64, params: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            sig.params.push(AbiParam::new(types::I64)); // sql string pointer
            sig.params.push(AbiParam::new(types::I64)); // params array (as JSValue bits)
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_connection_execute",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_connection_execute".to_string(), func_id);
        }

        // js_mysql2_connection_begin_transaction(conn: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_connection_begin_transaction",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_connection_begin_transaction".to_string(), func_id);
        }

        // js_mysql2_connection_commit(conn: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_connection_commit",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_connection_commit".to_string(), func_id);
        }

        // js_mysql2_connection_rollback(conn: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_connection_rollback",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_connection_rollback".to_string(), func_id);
        }

        // js_mysql2_create_pool(config: i64) -> i64 (Handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // config object pointer
            sig.returns.push(AbiParam::new(types::I64)); // pool handle
            let func_id = self.module.declare_function(
                "js_mysql2_create_pool",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_create_pool".to_string(), func_id);
        }

        // js_mysql2_pool_query(pool: i64, sql: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // pool handle
            sig.params.push(AbiParam::new(types::I64)); // sql string pointer
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_pool_query",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_pool_query".to_string(), func_id);
        }

        // js_mysql2_pool_execute(pool: i64, sql: i64, params: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // pool handle
            sig.params.push(AbiParam::new(types::I64)); // sql string pointer
            sig.params.push(AbiParam::new(types::I64)); // params array (as JSValue bits)
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_pool_execute",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_pool_execute".to_string(), func_id);
        }

        // js_mysql2_pool_end(pool: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // pool handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_pool_end",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_pool_end".to_string(), func_id);
        }

        // js_mysql2_pool_get_connection(pool: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // pool handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_pool_get_connection",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_pool_get_connection".to_string(), func_id);
        }

        // js_mysql2_pool_connection_release(conn: i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            let func_id = self.module.declare_function(
                "js_mysql2_pool_connection_release",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_pool_connection_release".to_string(), func_id);
        }

        // js_mysql2_pool_connection_query(conn: i64, sql: i64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            sig.params.push(AbiParam::new(types::I64)); // sql string pointer
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_pool_connection_query",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_pool_connection_query".to_string(), func_id);
        }

        // js_mysql2_pool_connection_execute(conn: i64, sql: i64, params: f64) -> *mut Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // connection handle
            sig.params.push(AbiParam::new(types::I64)); // sql string pointer
            sig.params.push(AbiParam::new(types::F64)); // params array (JSValue)
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            let func_id = self.module.declare_function(
                "js_mysql2_pool_connection_execute",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_mysql2_pool_connection_execute".to_string(), func_id);
        }

        // js_stdlib_process_pending() -> i32 (number of resolutions processed)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function(
                "js_stdlib_process_pending",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_stdlib_process_pending".to_string(), func_id);
        }

        // ========================================================================
        // UUID Functions
        // ========================================================================

        // js_uuid_v4() -> *mut StringHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function(
                "js_uuid_v4",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_uuid_v4".to_string(), func_id);
        }

        // js_uuid_v1() -> *mut StringHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function(
                "js_uuid_v1",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_uuid_v1".to_string(), func_id);
        }

        // js_uuid_v7() -> *mut StringHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function(
                "js_uuid_v7",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_uuid_v7".to_string(), func_id);
        }

        // js_uuid_validate(str: i64) -> f64 (boolean as 0.0/1.0)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::F64)); // boolean as f64
            let func_id = self.module.declare_function(
                "js_uuid_validate",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_uuid_validate".to_string(), func_id);
        }

        // js_uuid_version(str: i64) -> f64 (version number)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::F64)); // version number
            let func_id = self.module.declare_function(
                "js_uuid_version",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_uuid_version".to_string(), func_id);
        }

        // js_uuid_nil() -> *mut StringHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function(
                "js_uuid_nil",
                Linkage::Import,
                &sig,
            )?;
            self.extern_funcs.insert("js_uuid_nil".to_string(), func_id);
        }

        // ========================================================================
        // Bcrypt Functions
        // ========================================================================

        // js_bcrypt_hash(password: i64, salt_rounds: f64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password string ptr
            sig.params.push(AbiParam::new(types::F64)); // salt rounds
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_bcrypt_hash", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_bcrypt_hash".to_string(), func_id);
        }

        // js_bcrypt_compare(password: i64, hash: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password string ptr
            sig.params.push(AbiParam::new(types::I64)); // hash string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_bcrypt_compare", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_bcrypt_compare".to_string(), func_id);
        }

        // js_bcrypt_gen_salt(rounds: f64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // rounds
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_bcrypt_gen_salt", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_bcrypt_gen_salt".to_string(), func_id);
        }

        // js_bcrypt_hash_sync(password: i64, salt_rounds: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password string ptr
            sig.params.push(AbiParam::new(types::F64)); // salt rounds
            sig.returns.push(AbiParam::new(types::I64)); // string ptr
            let func_id = self.module.declare_function("js_bcrypt_hash_sync", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_bcrypt_hash_sync".to_string(), func_id);
        }

        // js_bcrypt_compare_sync(password: i64, hash: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password string ptr
            sig.params.push(AbiParam::new(types::I64)); // hash string ptr
            sig.returns.push(AbiParam::new(types::F64)); // boolean as f64
            let func_id = self.module.declare_function("js_bcrypt_compare_sync", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_bcrypt_compare_sync".to_string(), func_id);
        }

        // ========================================================================
        // Redis (ioredis) Functions
        // ========================================================================

        // js_ioredis_new(config: i64) -> Handle (i64) - synchronous, connects lazily
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // config ptr
            sig.returns.push(AbiParam::new(types::I64)); // Handle (not Promise)
            let func_id = self.module.declare_function("js_ioredis_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_new".to_string(), func_id);
        }

        // js_ioredis_set(handle: i64, key: i64, value: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key string ptr
            sig.params.push(AbiParam::new(types::I64)); // value string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ioredis_set", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_set".to_string(), func_id);
        }

        // js_ioredis_get(handle: i64, key: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ioredis_get", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_get".to_string(), func_id);
        }

        // js_ioredis_del(handle: i64, key: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ioredis_del", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_del".to_string(), func_id);
        }

        // js_ioredis_exists(handle: i64, key: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ioredis_exists", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_exists".to_string(), func_id);
        }

        // js_ioredis_incr(handle: i64, key: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ioredis_incr", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_incr".to_string(), func_id);
        }

        // js_ioredis_decr(handle: i64, key: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ioredis_decr", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_decr".to_string(), func_id);
        }

        // js_ioredis_expire(handle: i64, key: i64, seconds: f64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key string ptr
            sig.params.push(AbiParam::new(types::F64)); // seconds
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ioredis_expire", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_expire".to_string(), func_id);
        }

        // js_ioredis_quit(handle: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ioredis_quit", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ioredis_quit".to_string(), func_id);
        }

        // ========================================================================
        // Crypto Functions
        // ========================================================================

        // js_crypto_sha256(data: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data string ptr
            sig.returns.push(AbiParam::new(types::I64)); // hex string ptr
            let func_id = self.module.declare_function("js_crypto_sha256", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_sha256".to_string(), func_id);
        }

        // js_crypto_md5(data: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data string ptr
            sig.returns.push(AbiParam::new(types::I64)); // hex string ptr
            let func_id = self.module.declare_function("js_crypto_md5", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_md5".to_string(), func_id);
        }

        // js_crypto_random_bytes_hex(size: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // size
            sig.returns.push(AbiParam::new(types::I64)); // hex string ptr
            let func_id = self.module.declare_function("js_crypto_random_bytes_hex", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_random_bytes_hex".to_string(), func_id);
        }

        // js_crypto_random_uuid() -> i64
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // uuid string ptr
            let func_id = self.module.declare_function("js_crypto_random_uuid", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_random_uuid".to_string(), func_id);
        }

        // js_crypto_hmac_sha256(key: i64, data: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // key string ptr
            sig.params.push(AbiParam::new(types::I64)); // data string ptr
            sig.returns.push(AbiParam::new(types::I64)); // hex string ptr
            let func_id = self.module.declare_function("js_crypto_hmac_sha256", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_hmac_sha256".to_string(), func_id);
        }

        // ========================================================================
        // OS Functions
        // ========================================================================

        // js_os_platform() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_platform", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_platform".to_string(), func_id);
        }

        // js_os_arch() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_arch", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_arch".to_string(), func_id);
        }

        // js_os_hostname() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_hostname", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_hostname".to_string(), func_id);
        }

        // js_os_homedir() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_homedir", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_homedir".to_string(), func_id);
        }

        // js_os_tmpdir() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_tmpdir", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_tmpdir".to_string(), func_id);
        }

        // js_os_totalmem() -> f64
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_os_totalmem", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_totalmem".to_string(), func_id);
        }

        // js_os_freemem() -> f64
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_os_freemem", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_freemem".to_string(), func_id);
        }

        // js_os_uptime() -> f64
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_os_uptime", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_uptime".to_string(), func_id);
        }

        // js_process_uptime() -> f64
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_process_uptime", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_process_uptime".to_string(), func_id);
        }

        // js_process_cwd() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_process_cwd", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_process_cwd".to_string(), func_id);
        }

        // js_process_argv() -> i64 (array ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_process_argv", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_process_argv".to_string(), func_id);
        }

        // js_os_type() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_type", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_type".to_string(), func_id);
        }

        // js_os_release() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_release", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_release".to_string(), func_id);
        }

        // js_os_eol() -> i64 (string ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_eol", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_eol".to_string(), func_id);
        }

        // js_os_cpus() -> i64 (array ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_cpus", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_cpus".to_string(), func_id);
        }

        // js_os_network_interfaces() -> i64 (object ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_network_interfaces", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_network_interfaces".to_string(), func_id);
        }

        // js_os_user_info() -> i64 (object ptr)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_os_user_info", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_os_user_info".to_string(), func_id);
        }

        // ========================================================================
        // Buffer Functions
        // ========================================================================

        // js_buffer_from_string(str_ptr: i64, encoding: i32) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string ptr
            sig.params.push(AbiParam::new(types::I32)); // encoding
            sig.returns.push(AbiParam::new(types::I64)); // buffer ptr
            let func_id = self.module.declare_function("js_buffer_from_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_from_string".to_string(), func_id);
        }

        // js_buffer_from_array(arr_ptr: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array ptr
            sig.returns.push(AbiParam::new(types::I64)); // buffer ptr
            let func_id = self.module.declare_function("js_buffer_from_array", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_from_array".to_string(), func_id);
        }

        // js_buffer_alloc(size: i32, fill: i32) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // size
            sig.params.push(AbiParam::new(types::I32)); // fill
            sig.returns.push(AbiParam::new(types::I64)); // buffer ptr
            let func_id = self.module.declare_function("js_buffer_alloc", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_alloc".to_string(), func_id);
        }

        // js_buffer_alloc_unsafe(size: i32) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // size
            sig.returns.push(AbiParam::new(types::I64)); // buffer ptr
            let func_id = self.module.declare_function("js_buffer_alloc_unsafe", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_alloc_unsafe".to_string(), func_id);
        }

        // js_buffer_concat(arr_ptr: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array ptr
            sig.returns.push(AbiParam::new(types::I64)); // buffer ptr
            let func_id = self.module.declare_function("js_buffer_concat", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_concat".to_string(), func_id);
        }

        // js_buffer_is_buffer(ptr: i64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // ptr
            sig.returns.push(AbiParam::new(types::I32)); // boolean
            let func_id = self.module.declare_function("js_buffer_is_buffer", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_is_buffer".to_string(), func_id);
        }

        // js_buffer_byte_length(str_ptr: i64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string ptr
            sig.returns.push(AbiParam::new(types::I32)); // length
            let func_id = self.module.declare_function("js_buffer_byte_length", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_byte_length".to_string(), func_id);
        }

        // js_buffer_to_string(buf_ptr: i64, encoding: i32) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // buffer ptr
            sig.params.push(AbiParam::new(types::I32)); // encoding
            sig.returns.push(AbiParam::new(types::I64)); // string ptr
            let func_id = self.module.declare_function("js_buffer_to_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_to_string".to_string(), func_id);
        }

        // js_buffer_length(buf_ptr: i64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // buffer ptr
            sig.returns.push(AbiParam::new(types::I32)); // length
            let func_id = self.module.declare_function("js_buffer_length", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_length".to_string(), func_id);
        }

        // js_buffer_slice(buf_ptr: i64, start: i32, end: i32) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // buffer ptr
            sig.params.push(AbiParam::new(types::I32)); // start
            sig.params.push(AbiParam::new(types::I32)); // end
            sig.returns.push(AbiParam::new(types::I64)); // new buffer ptr
            let func_id = self.module.declare_function("js_buffer_slice", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_slice".to_string(), func_id);
        }

        // js_buffer_copy(src: i64, dst: i64, target_start: i32, source_start: i32, source_end: i32) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // src buffer ptr
            sig.params.push(AbiParam::new(types::I64)); // dst buffer ptr
            sig.params.push(AbiParam::new(types::I32)); // target_start
            sig.params.push(AbiParam::new(types::I32)); // source_start
            sig.params.push(AbiParam::new(types::I32)); // source_end
            sig.returns.push(AbiParam::new(types::I32)); // bytes copied
            let func_id = self.module.declare_function("js_buffer_copy", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_copy".to_string(), func_id);
        }

        // js_buffer_write(buf_ptr: i64, str_ptr: i64, offset: i32, encoding: i32) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // buffer ptr
            sig.params.push(AbiParam::new(types::I64)); // string ptr
            sig.params.push(AbiParam::new(types::I32)); // offset
            sig.params.push(AbiParam::new(types::I32)); // encoding
            sig.returns.push(AbiParam::new(types::I32)); // bytes written
            let func_id = self.module.declare_function("js_buffer_write", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_write".to_string(), func_id);
        }

        // js_buffer_equals(buf1: i64, buf2: i64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // buffer 1 ptr
            sig.params.push(AbiParam::new(types::I64)); // buffer 2 ptr
            sig.returns.push(AbiParam::new(types::I32)); // boolean
            let func_id = self.module.declare_function("js_buffer_equals", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_equals".to_string(), func_id);
        }

        // js_buffer_get(buf_ptr: i64, index: i32) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // buffer ptr
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.returns.push(AbiParam::new(types::I32)); // byte value
            let func_id = self.module.declare_function("js_buffer_get", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_get".to_string(), func_id);
        }

        // js_buffer_set(buf_ptr: i64, index: i32, value: i32) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // buffer ptr
            sig.params.push(AbiParam::new(types::I32)); // index
            sig.params.push(AbiParam::new(types::I32)); // value
            let func_id = self.module.declare_function("js_buffer_set", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_buffer_set".to_string(), func_id);
        }

        // ========================================================================
        // Child Process Functions
        // ========================================================================

        // js_child_process_exec_sync(cmd_ptr: i64, options_ptr: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // command string ptr
            sig.params.push(AbiParam::new(types::I64)); // options object ptr
            sig.returns.push(AbiParam::new(types::I64)); // buffer ptr
            let func_id = self.module.declare_function("js_child_process_exec_sync", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_child_process_exec_sync".to_string(), func_id);
        }

        // js_child_process_spawn_sync(cmd_ptr: i64, args_ptr: i64, options_ptr: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // command string ptr
            sig.params.push(AbiParam::new(types::I64)); // args array ptr
            sig.params.push(AbiParam::new(types::I64)); // options object ptr
            sig.returns.push(AbiParam::new(types::I64)); // result object ptr
            let func_id = self.module.declare_function("js_child_process_spawn_sync", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_child_process_spawn_sync".to_string(), func_id);
        }

        // ========================================================================
        // Net Functions
        // ========================================================================

        // js_net_create_server(options_ptr: i64, connection_listener_ptr: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // options object ptr
            sig.params.push(AbiParam::new(types::I64)); // connection listener ptr
            sig.returns.push(AbiParam::new(types::F64)); // server handle
            let func_id = self.module.declare_function("js_net_create_server", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_net_create_server".to_string(), func_id);
        }

        // js_net_create_connection(port: i32, host_ptr: i64, connect_listener_ptr: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I32)); // port
            sig.params.push(AbiParam::new(types::I64)); // host string ptr
            sig.params.push(AbiParam::new(types::I64)); // connect listener ptr
            sig.returns.push(AbiParam::new(types::F64)); // socket handle
            let func_id = self.module.declare_function("js_net_create_connection", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_net_create_connection".to_string(), func_id);
        }

        // ========================================================================
        // Zlib Functions
        // ========================================================================

        // js_zlib_gzip_sync(data: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data ptr
            sig.returns.push(AbiParam::new(types::I64)); // compressed ptr
            let func_id = self.module.declare_function("js_zlib_gzip_sync", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_zlib_gzip_sync".to_string(), func_id);
        }

        // js_zlib_gunzip_sync(data: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data ptr
            sig.returns.push(AbiParam::new(types::I64)); // decompressed ptr
            let func_id = self.module.declare_function("js_zlib_gunzip_sync", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_zlib_gunzip_sync".to_string(), func_id);
        }

        // js_zlib_deflate_sync(data: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data ptr
            sig.returns.push(AbiParam::new(types::I64)); // compressed ptr
            let func_id = self.module.declare_function("js_zlib_deflate_sync", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_zlib_deflate_sync".to_string(), func_id);
        }

        // js_zlib_inflate_sync(data: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data ptr
            sig.returns.push(AbiParam::new(types::I64)); // decompressed ptr
            let func_id = self.module.declare_function("js_zlib_inflate_sync", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_zlib_inflate_sync".to_string(), func_id);
        }

        // js_zlib_gzip(data: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_zlib_gzip", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_zlib_gzip".to_string(), func_id);
        }

        // js_zlib_gunzip(data: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_zlib_gunzip", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_zlib_gunzip".to_string(), func_id);
        }

        // ========================================================================
        // Fetch Functions (node-fetch)
        // ========================================================================

        // js_fetch_get(url: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_fetch_get", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_get".to_string(), func_id);
        }

        // js_fetch_post(url: i64, body: i64, content_type: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url string ptr
            sig.params.push(AbiParam::new(types::I64)); // body string ptr
            sig.params.push(AbiParam::new(types::I64)); // content_type string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_fetch_post", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_post".to_string(), func_id);
        }

        // js_fetch_with_options(url: i64, method: i64, body: i64, headers_json: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url string ptr
            sig.params.push(AbiParam::new(types::I64)); // method string ptr
            sig.params.push(AbiParam::new(types::I64)); // body string ptr (nullable)
            sig.params.push(AbiParam::new(types::I64)); // headers JSON string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_fetch_with_options", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_with_options".to_string(), func_id);
            // Also register as "fetch" for global fetch calls
            self.extern_funcs.insert("fetch".to_string(), func_id);
        }

        // js_fetch_text(url: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_fetch_text", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_text".to_string(), func_id);
        }

        // js_fetch_response_status(handle: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::F64)); // status
            let func_id = self.module.declare_function("js_fetch_response_status", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_response_status".to_string(), func_id);
        }

        // js_fetch_response_ok(handle: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::F64)); // ok (boolean)
            let func_id = self.module.declare_function("js_fetch_response_ok", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_response_ok".to_string(), func_id);
        }

        // js_fetch_response_status_text(handle: i64) -> *mut StringHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // StringHeader ptr
            let func_id = self.module.declare_function("js_fetch_response_status_text", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_response_status_text".to_string(), func_id);
        }

        // js_fetch_response_text(handle: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_fetch_response_text", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_response_text".to_string(), func_id);
        }

        // js_fetch_response_json(handle: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_fetch_response_json", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fetch_response_json".to_string(), func_id);
        }

        // ========================================================================
        // WebSocket Functions (ws)
        // ========================================================================

        // js_ws_connect(url: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url string ptr
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ws_connect", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ws_connect".to_string(), func_id);
        }

        // js_ws_send(handle: i64, message: i64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // message string ptr
            let func_id = self.module.declare_function("js_ws_send", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ws_send".to_string(), func_id);
        }

        // js_ws_close(handle: i64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_ws_close", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ws_close".to_string(), func_id);
        }

        // js_ws_is_open(handle: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::F64)); // is_open (boolean)
            let func_id = self.module.declare_function("js_ws_is_open", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ws_is_open".to_string(), func_id);
        }

        // js_ws_receive(handle: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // message string ptr
            let func_id = self.module.declare_function("js_ws_receive", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ws_receive".to_string(), func_id);
        }

        // js_ws_wait_for_message(handle: i64, timeout_ms: f64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // timeout_ms
            sig.returns.push(AbiParam::new(types::I64)); // Promise ptr
            let func_id = self.module.declare_function("js_ws_wait_for_message", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ws_wait_for_message".to_string(), func_id);
        }

        // ========================================================================
        // EventEmitter Functions (events)
        // ========================================================================

        // js_event_emitter_new() -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_event_emitter_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_event_emitter_new".to_string(), func_id);
        }

        // js_event_emitter_on(handle: i64, event_name: i64, callback: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // event name string ptr
            sig.params.push(AbiParam::new(types::I64)); // callback closure ptr
            sig.returns.push(AbiParam::new(types::I64)); // returns handle for chaining
            let func_id = self.module.declare_function("js_event_emitter_on", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_event_emitter_on".to_string(), func_id);
        }

        // js_event_emitter_emit(handle: i64, event_name: i64, arg: f64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // event name string ptr
            sig.params.push(AbiParam::new(types::F64)); // argument
            sig.returns.push(AbiParam::new(types::F64)); // returns bool as f64
            let func_id = self.module.declare_function("js_event_emitter_emit", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_event_emitter_emit".to_string(), func_id);
        }

        // js_event_emitter_emit0(handle: i64, event_name: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // event name string ptr
            sig.returns.push(AbiParam::new(types::F64)); // returns bool as f64
            let func_id = self.module.declare_function("js_event_emitter_emit0", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_event_emitter_emit0".to_string(), func_id);
        }

        // js_event_emitter_remove_listener(handle: i64, event_name: i64, callback: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // event name string ptr
            sig.params.push(AbiParam::new(types::I64)); // callback closure ptr
            sig.returns.push(AbiParam::new(types::I64)); // returns handle for chaining
            let func_id = self.module.declare_function("js_event_emitter_remove_listener", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_event_emitter_remove_listener".to_string(), func_id);
        }

        // js_event_emitter_remove_all_listeners(handle: i64, event_name: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // event name string ptr (or null)
            sig.returns.push(AbiParam::new(types::I64)); // returns handle for chaining
            let func_id = self.module.declare_function("js_event_emitter_remove_all_listeners", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_event_emitter_remove_all_listeners".to_string(), func_id);
        }

        // js_event_emitter_listener_count(handle: i64, event_name: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // event name string ptr
            sig.returns.push(AbiParam::new(types::F64)); // count
            let func_id = self.module.declare_function("js_event_emitter_listener_count", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_event_emitter_listener_count".to_string(), func_id);
        }

        // ========================================================================
        // LRUCache
        // ========================================================================

        // js_lru_cache_new(max_size: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // max_size
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_lru_cache_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lru_cache_new".to_string(), func_id);
        }

        // js_lru_cache_get(handle: i64, key: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // key
            sig.returns.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function("js_lru_cache_get", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lru_cache_get".to_string(), func_id);
        }

        // js_lru_cache_set(handle: i64, key: f64, value: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // key
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I64)); // returns handle
            let func_id = self.module.declare_function("js_lru_cache_set", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lru_cache_set".to_string(), func_id);
        }

        // js_lru_cache_has(handle: i64, key: f64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // key
            sig.returns.push(AbiParam::new(types::F64)); // bool as f64
            let func_id = self.module.declare_function("js_lru_cache_has", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lru_cache_has".to_string(), func_id);
        }

        // js_lru_cache_delete(handle: i64, key: f64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // key
            sig.returns.push(AbiParam::new(types::F64)); // bool as f64
            let func_id = self.module.declare_function("js_lru_cache_delete", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lru_cache_delete".to_string(), func_id);
        }

        // js_lru_cache_clear(handle: i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_lru_cache_clear", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lru_cache_clear".to_string(), func_id);
        }

        // js_lru_cache_size(handle: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::F64)); // size
            let func_id = self.module.declare_function("js_lru_cache_size", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lru_cache_size".to_string(), func_id);
        }

        // js_lru_cache_peek(handle: i64, key: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // key
            sig.returns.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function("js_lru_cache_peek", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lru_cache_peek".to_string(), func_id);
        }

        // ========================================================================
        // Commander
        // ========================================================================

        // js_commander_new() -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_commander_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_new".to_string(), func_id);
        }

        // js_commander_name(handle: i64, name: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // name string
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_commander_name", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_name".to_string(), func_id);
        }

        // js_commander_description(handle: i64, desc: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // description string
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_commander_description", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_description".to_string(), func_id);
        }

        // js_commander_version(handle: i64, version: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // version string
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_commander_version", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_version".to_string(), func_id);
        }

        // js_commander_option(handle: i64, flags: i64, desc: i64, default: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // flags string
            sig.params.push(AbiParam::new(types::I64)); // description string
            sig.params.push(AbiParam::new(types::I64)); // default value string (or null)
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_commander_option", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_option".to_string(), func_id);
        }

        // js_commander_parse(handle: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_commander_parse", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_parse".to_string(), func_id);
        }

        // js_commander_opts(handle: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_commander_opts", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_opts".to_string(), func_id);
        }

        // js_commander_get_option(handle: i64, name: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // name string
            sig.returns.push(AbiParam::new(types::I64)); // value string
            let func_id = self.module.declare_function("js_commander_get_option", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_get_option".to_string(), func_id);
        }

        // js_commander_get_option_number(handle: i64, name: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // name string
            sig.returns.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function("js_commander_get_option_number", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_get_option_number".to_string(), func_id);
        }

        // js_commander_get_option_bool(handle: i64, name: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // name string
            sig.returns.push(AbiParam::new(types::F64)); // bool as f64
            let func_id = self.module.declare_function("js_commander_get_option_bool", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_commander_get_option_bool".to_string(), func_id);
        }

        // ========================================================================
        // Decimal (Big.js / Decimal.js / BigNumber.js)
        // ========================================================================

        // js_decimal_from_number(value: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_decimal_from_number", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_from_number".to_string(), func_id);
        }

        // js_decimal_from_string(value: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // value string
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_decimal_from_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_from_string".to_string(), func_id);
        }

        // js_decimal_plus(handle: i64, other: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // other handle
            sig.returns.push(AbiParam::new(types::I64)); // result handle
            let func_id = self.module.declare_function("js_decimal_plus", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_plus".to_string(), func_id);
        }

        // js_decimal_plus_number(handle: i64, other: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // other number
            sig.returns.push(AbiParam::new(types::I64)); // result handle
            let func_id = self.module.declare_function("js_decimal_plus_number", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_plus_number".to_string(), func_id);
        }

        // js_decimal_minus(handle: i64, other: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // other handle
            sig.returns.push(AbiParam::new(types::I64)); // result handle
            let func_id = self.module.declare_function("js_decimal_minus", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_minus".to_string(), func_id);
        }

        // js_decimal_times(handle: i64, other: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // other handle
            sig.returns.push(AbiParam::new(types::I64)); // result handle
            let func_id = self.module.declare_function("js_decimal_times", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_times".to_string(), func_id);
        }

        // js_decimal_div(handle: i64, other: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // other handle
            sig.returns.push(AbiParam::new(types::I64)); // result handle
            let func_id = self.module.declare_function("js_decimal_div", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_div".to_string(), func_id);
        }

        // js_decimal_to_fixed(handle: i64, decimals: f64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // decimals
            sig.returns.push(AbiParam::new(types::I64)); // result string
            let func_id = self.module.declare_function("js_decimal_to_fixed", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_to_fixed".to_string(), func_id);
        }

        // js_decimal_to_string(handle: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // result string
            let func_id = self.module.declare_function("js_decimal_to_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_to_string".to_string(), func_id);
        }

        // js_decimal_to_number(handle: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::F64)); // result
            let func_id = self.module.declare_function("js_decimal_to_number", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_to_number".to_string(), func_id);
        }

        // js_decimal_sqrt(handle: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // result handle
            let func_id = self.module.declare_function("js_decimal_sqrt", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_sqrt".to_string(), func_id);
        }

        // js_decimal_abs(handle: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::I64)); // result handle
            let func_id = self.module.declare_function("js_decimal_abs", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_abs".to_string(), func_id);
        }

        // js_decimal_eq(handle: i64, other: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // other handle
            sig.returns.push(AbiParam::new(types::F64)); // bool as f64
            let func_id = self.module.declare_function("js_decimal_eq", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_eq".to_string(), func_id);
        }

        // js_decimal_lt(handle: i64, other: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // other handle
            sig.returns.push(AbiParam::new(types::F64)); // bool as f64
            let func_id = self.module.declare_function("js_decimal_lt", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_lt".to_string(), func_id);
        }

        // js_decimal_gt(handle: i64, other: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // other handle
            sig.returns.push(AbiParam::new(types::F64)); // bool as f64
            let func_id = self.module.declare_function("js_decimal_gt", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_decimal_gt".to_string(), func_id);
        }

        // ========================================================================
        // Tier 3: dotenv, jsonwebtoken, nanoid, slugify, validator
        // ========================================================================

        // js_dotenv_config() -> f64
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64)); // success flag
            let func_id = self.module.declare_function("js_dotenv_config", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dotenv_config".to_string(), func_id);
        }

        // js_dotenv_config_path(path: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path string
            sig.returns.push(AbiParam::new(types::F64)); // success flag
            let func_id = self.module.declare_function("js_dotenv_config_path", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dotenv_config_path".to_string(), func_id);
        }

        // js_dotenv_parse(content: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // content string
            sig.returns.push(AbiParam::new(types::I64)); // JSON string
            let func_id = self.module.declare_function("js_dotenv_parse", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dotenv_parse".to_string(), func_id);
        }

        // js_jwt_sign(payload: i64, secret: i64, expiry: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // payload
            sig.params.push(AbiParam::new(types::I64)); // secret
            sig.params.push(AbiParam::new(types::F64)); // expiry seconds
            sig.returns.push(AbiParam::new(types::I64)); // token string
            let func_id = self.module.declare_function("js_jwt_sign", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_jwt_sign".to_string(), func_id);
        }

        // js_jwt_verify(token: i64, secret: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // token
            sig.params.push(AbiParam::new(types::I64)); // secret
            sig.returns.push(AbiParam::new(types::I64)); // payload or null
            let func_id = self.module.declare_function("js_jwt_verify", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_jwt_verify".to_string(), func_id);
        }

        // js_jwt_decode(token: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // token
            sig.returns.push(AbiParam::new(types::I64)); // decoded payload
            let func_id = self.module.declare_function("js_jwt_decode", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_jwt_decode".to_string(), func_id);
        }

        // js_nanoid(size: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // size
            sig.returns.push(AbiParam::new(types::I64)); // id string
            let func_id = self.module.declare_function("js_nanoid", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_nanoid".to_string(), func_id);
        }

        // js_nanoid_custom(alphabet: i64, size: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // alphabet
            sig.params.push(AbiParam::new(types::F64)); // size
            sig.returns.push(AbiParam::new(types::I64)); // id string
            let func_id = self.module.declare_function("js_nanoid_custom", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_nanoid_custom".to_string(), func_id);
        }

        // js_slugify(str: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.returns.push(AbiParam::new(types::I64)); // slug
            let func_id = self.module.declare_function("js_slugify", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_slugify".to_string(), func_id);
        }

        // js_slugify_strict(str: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.returns.push(AbiParam::new(types::I64)); // slug
            let func_id = self.module.declare_function("js_slugify_strict", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_slugify_strict".to_string(), func_id);
        }

        // Validator functions - all take i64 string and return f64 boolean
        for name in &[
            "js_validator_is_email", "js_validator_is_url", "js_validator_is_uuid",
            "js_validator_is_alpha", "js_validator_is_alphanumeric", "js_validator_is_numeric",
            "js_validator_is_hexadecimal", "js_validator_is_int", "js_validator_is_float",
            "js_validator_is_empty", "js_validator_is_json", "js_validator_is_lowercase",
            "js_validator_is_uppercase",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_validator_contains(str: i64, substr: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_validator_contains", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_validator_contains".to_string(), func_id);
        }

        // js_validator_equals(str1: i64, str2: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_validator_equals", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_validator_equals".to_string(), func_id);
        }

        // js_validator_is_length(str: i64, min: f64, max: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_validator_is_length", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_validator_is_length".to_string(), func_id);
        }

        // ========================================================================
        // Tier 4: pg (PostgreSQL)
        // ========================================================================

        // js_pg_connect(config: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // config object
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_pg_connect", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_pg_connect".to_string(), func_id);
        }

        // js_pg_client_end(client: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // client handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_pg_client_end", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_pg_client_end".to_string(), func_id);
        }

        // js_pg_client_query(client: i64, sql: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // client handle
            sig.params.push(AbiParam::new(types::I64)); // sql string
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_pg_client_query", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_pg_client_query".to_string(), func_id);
        }

        // js_pg_client_query_params(client: i64, sql: i64, params: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // client handle
            sig.params.push(AbiParam::new(types::I64)); // sql string
            sig.params.push(AbiParam::new(types::I64)); // params array
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_pg_client_query_params", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_pg_client_query_params".to_string(), func_id);
        }

        // js_pg_create_pool(config: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // config object
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_pg_create_pool", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_pg_create_pool".to_string(), func_id);
        }

        // js_pg_pool_query(pool: i64, sql: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // pool handle
            sig.params.push(AbiParam::new(types::I64)); // sql string
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_pg_pool_query", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_pg_pool_query".to_string(), func_id);
        }

        // js_pg_pool_end(pool: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // pool handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_pg_pool_end", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_pg_pool_end".to_string(), func_id);
        }

        // ========================================================================
        // Tier 4: nodemailer
        // ========================================================================

        // js_nodemailer_create_transport(config: i64) -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // config object
            sig.returns.push(AbiParam::new(types::F64)); // handle
            let func_id = self.module.declare_function("js_nodemailer_create_transport", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_nodemailer_create_transport".to_string(), func_id);
        }

        // js_nodemailer_send_mail(transport: i64, options: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // transport handle
            sig.params.push(AbiParam::new(types::I64)); // mail options
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_nodemailer_send_mail", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_nodemailer_send_mail".to_string(), func_id);
        }

        // js_nodemailer_verify(transport: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // transport handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_nodemailer_verify", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_nodemailer_verify".to_string(), func_id);
        }

        // ========================================================================
        // Tier 4: crypto extended (AES, pbkdf2, scrypt)
        // ========================================================================

        // js_crypto_aes256_encrypt(data: i64, key: i64, iv: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data
            sig.params.push(AbiParam::new(types::I64)); // key
            sig.params.push(AbiParam::new(types::I64)); // iv
            sig.returns.push(AbiParam::new(types::I64)); // encrypted (base64)
            let func_id = self.module.declare_function("js_crypto_aes256_encrypt", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_aes256_encrypt".to_string(), func_id);
        }

        // js_crypto_aes256_decrypt(data: i64, key: i64, iv: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // data (base64)
            sig.params.push(AbiParam::new(types::I64)); // key
            sig.params.push(AbiParam::new(types::I64)); // iv
            sig.returns.push(AbiParam::new(types::I64)); // decrypted
            let func_id = self.module.declare_function("js_crypto_aes256_decrypt", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_aes256_decrypt".to_string(), func_id);
        }

        // js_crypto_pbkdf2(password: i64, salt: i64, iterations: f64, keyLength: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password
            sig.params.push(AbiParam::new(types::I64)); // salt
            sig.params.push(AbiParam::new(types::F64)); // iterations
            sig.params.push(AbiParam::new(types::F64)); // keyLength
            sig.returns.push(AbiParam::new(types::I64)); // derived key (hex)
            let func_id = self.module.declare_function("js_crypto_pbkdf2", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_pbkdf2".to_string(), func_id);
        }

        // js_crypto_scrypt(password: i64, salt: i64, keyLength: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password
            sig.params.push(AbiParam::new(types::I64)); // salt
            sig.params.push(AbiParam::new(types::F64)); // keyLength
            sig.returns.push(AbiParam::new(types::I64)); // derived key (hex)
            let func_id = self.module.declare_function("js_crypto_scrypt", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_scrypt".to_string(), func_id);
        }

        // js_crypto_scrypt_custom(password: i64, salt: i64, keyLength: f64, logN: f64, r: f64, p: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password
            sig.params.push(AbiParam::new(types::I64)); // salt
            sig.params.push(AbiParam::new(types::F64)); // keyLength
            sig.params.push(AbiParam::new(types::F64)); // logN
            sig.params.push(AbiParam::new(types::F64)); // r
            sig.params.push(AbiParam::new(types::F64)); // p
            sig.returns.push(AbiParam::new(types::I64)); // derived key (hex)
            let func_id = self.module.declare_function("js_crypto_scrypt_custom", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_crypto_scrypt_custom".to_string(), func_id);
        }

        // ========================================================================
        // Tier 4: dayjs/date-fns
        // ========================================================================

        // js_dayjs_now() -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_dayjs_now", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_now".to_string(), func_id);
        }

        // js_dayjs_from_timestamp(timestamp: f64) -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_dayjs_from_timestamp", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_from_timestamp".to_string(), func_id);
        }

        // js_dayjs_parse(dateStr: i64) -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_dayjs_parse", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_parse".to_string(), func_id);
        }

        // js_dayjs_format(handle: i64, pattern: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_dayjs_format", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_format".to_string(), func_id);
        }

        // js_dayjs_to_iso_string(handle: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_dayjs_to_iso_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_to_iso_string".to_string(), func_id);
        }

        // Dayjs getter methods (handle: i64) -> f64
        for name in &[
            "js_dayjs_value_of", "js_dayjs_unix", "js_dayjs_year", "js_dayjs_month",
            "js_dayjs_date", "js_dayjs_day", "js_dayjs_hour", "js_dayjs_minute",
            "js_dayjs_second", "js_dayjs_millisecond", "js_dayjs_is_valid",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_dayjs_add(handle: i64, value: f64, unit: i64) -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_dayjs_add", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_add".to_string(), func_id);
        }

        // js_dayjs_subtract(handle: i64, value: f64, unit: i64) -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_dayjs_subtract", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_subtract".to_string(), func_id);
        }

        // js_dayjs_start_of(handle: i64, unit: i64) -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_dayjs_start_of", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_start_of".to_string(), func_id);
        }

        // js_dayjs_end_of(handle: i64, unit: i64) -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_dayjs_end_of", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_end_of".to_string(), func_id);
        }

        // js_dayjs_diff(handle: i64, other: i64, unit: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_dayjs_diff", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dayjs_diff".to_string(), func_id);
        }

        // Dayjs comparison methods (handle: i64, other: i64) -> f64
        for name in &["js_dayjs_is_before", "js_dayjs_is_after", "js_dayjs_is_same"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // date-fns compatible functions
        // js_datefns_format(timestamp: f64, pattern: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_datefns_format", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_datefns_format".to_string(), func_id);
        }

        // js_datefns_parse_iso(dateStr: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_datefns_parse_iso", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_datefns_parse_iso".to_string(), func_id);
        }

        // date-fns add functions (timestamp: f64, amount: f64) -> f64
        for name in &["js_datefns_add_days", "js_datefns_add_months", "js_datefns_add_years"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // date-fns difference functions (left: f64, right: f64) -> f64
        for name in &[
            "js_datefns_difference_in_days", "js_datefns_difference_in_hours",
            "js_datefns_difference_in_minutes", "js_datefns_is_after", "js_datefns_is_before",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // date-fns startOf/endOf functions (timestamp: f64) -> f64
        for name in &["js_datefns_start_of_day", "js_datefns_end_of_day"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: axios (HTTP client)
        // ========================================================================

        // js_axios_get(url: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_axios_get", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_axios_get".to_string(), func_id);
        }

        // js_axios_post(url: i64, body: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url
            sig.params.push(AbiParam::new(types::I64)); // body
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_axios_post", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_axios_post".to_string(), func_id);
        }

        // js_axios_put(url: i64, body: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url
            sig.params.push(AbiParam::new(types::I64)); // body
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_axios_put", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_axios_put".to_string(), func_id);
        }

        // js_axios_delete(url: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_axios_delete", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_axios_delete".to_string(), func_id);
        }

        // js_axios_request(config: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // config (JSON)
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_axios_request", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_axios_request".to_string(), func_id);
        }

        // js_axios_create(config: i64) -> f64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // config (JSON)
            sig.returns.push(AbiParam::new(types::F64)); // handle
            let func_id = self.module.declare_function("js_axios_create", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_axios_create".to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: argon2 (password hashing)
        // ========================================================================

        // js_argon2_hash(password: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_argon2_hash", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_argon2_hash".to_string(), func_id);
        }

        // js_argon2_hash_options(password: i64, options: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // password
            sig.params.push(AbiParam::new(types::I64)); // options (JSON)
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_argon2_hash_options", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_argon2_hash_options".to_string(), func_id);
        }

        // js_argon2_verify(hash: i64, password: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // hash
            sig.params.push(AbiParam::new(types::I64)); // password
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_argon2_verify", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_argon2_verify".to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: mongodb
        // ========================================================================

        // js_mongodb_connect(uri: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // uri
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_mongodb_connect", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_mongodb_connect".to_string(), func_id);
        }

        // js_mongodb_client_db(client: i64, name: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // client handle
            sig.params.push(AbiParam::new(types::I64)); // name
            sig.returns.push(AbiParam::new(types::I64)); // db handle
            let func_id = self.module.declare_function("js_mongodb_client_db", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_mongodb_client_db".to_string(), func_id);
        }

        // js_mongodb_db_collection(db: i64, name: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // db handle
            sig.params.push(AbiParam::new(types::I64)); // name
            sig.returns.push(AbiParam::new(types::I64)); // collection handle
            let func_id = self.module.declare_function("js_mongodb_db_collection", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_mongodb_db_collection".to_string(), func_id);
        }

        // MongoDB collection methods (coll: i64, filter: i64) -> Promise (i64)
        for name in &[
            "js_mongodb_collection_find_one", "js_mongodb_collection_find",
            "js_mongodb_collection_delete_one", "js_mongodb_collection_delete_many",
            "js_mongodb_collection_count",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // collection handle
            sig.params.push(AbiParam::new(types::I64)); // filter (JSON)
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_mongodb_collection_insert_one(coll: i64, doc: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // collection handle
            sig.params.push(AbiParam::new(types::I64)); // doc (JSON)
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_mongodb_collection_insert_one", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_mongodb_collection_insert_one".to_string(), func_id);
        }

        // js_mongodb_collection_insert_many(coll: i64, docs: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // collection handle
            sig.params.push(AbiParam::new(types::I64)); // docs (JSON array)
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_mongodb_collection_insert_many", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_mongodb_collection_insert_many".to_string(), func_id);
        }

        // MongoDB update methods (coll: i64, filter: i64, update: i64) -> Promise (i64)
        for name in &["js_mongodb_collection_update_one", "js_mongodb_collection_update_many"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // collection handle
            sig.params.push(AbiParam::new(types::I64)); // filter (JSON)
            sig.params.push(AbiParam::new(types::I64)); // update (JSON)
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_mongodb_client_close(client: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // client handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_mongodb_client_close", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_mongodb_client_close".to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: sqlite (better-sqlite3 compatible)
        // ========================================================================

        // js_sqlite_open(path: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path
            sig.returns.push(AbiParam::new(types::I64)); // db handle
            let func_id = self.module.declare_function("js_sqlite_open", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sqlite_open".to_string(), func_id);
        }

        // js_sqlite_prepare(db: i64, sql: i64) -> i64 (statement handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // db handle
            sig.params.push(AbiParam::new(types::I64)); // sql
            sig.returns.push(AbiParam::new(types::I64)); // statement handle
            let func_id = self.module.declare_function("js_sqlite_prepare", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sqlite_prepare".to_string(), func_id);
        }

        // SQLite statement methods (stmt: i64, params: i64) -> i64
        for name in &["js_sqlite_stmt_run", "js_sqlite_stmt_get", "js_sqlite_stmt_all"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // statement handle
            sig.params.push(AbiParam::new(types::I64)); // params (JSON)
            sig.returns.push(AbiParam::new(types::I64)); // result
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_sqlite_exec(db: i64, sql: i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // db handle
            sig.params.push(AbiParam::new(types::I64)); // sql
            let func_id = self.module.declare_function("js_sqlite_exec", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sqlite_exec".to_string(), func_id);
        }

        // js_sqlite_close(db: i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // db handle
            let func_id = self.module.declare_function("js_sqlite_close", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sqlite_close".to_string(), func_id);
        }

        // js_sqlite_transaction(db: i64) -> i64 (transaction handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // db handle
            sig.returns.push(AbiParam::new(types::I64)); // transaction handle
            let func_id = self.module.declare_function("js_sqlite_transaction", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sqlite_transaction".to_string(), func_id);
        }

        // SQLite transaction methods (tx: i64)
        for name in &["js_sqlite_transaction_commit", "js_sqlite_transaction_rollback"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // transaction handle
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: sharp (image processing)
        // ========================================================================

        // js_sharp_from_file(path: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path
            sig.returns.push(AbiParam::new(types::I64)); // image handle
            let func_id = self.module.declare_function("js_sharp_from_file", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sharp_from_file".to_string(), func_id);
        }

        // js_sharp_from_buffer(buffer: i64, len: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // buffer
            sig.params.push(AbiParam::new(types::F64)); // length
            sig.returns.push(AbiParam::new(types::I64)); // image handle
            let func_id = self.module.declare_function("js_sharp_from_buffer", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sharp_from_buffer".to_string(), func_id);
        }

        // js_sharp_resize(handle: i64, width: f64, height: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // image handle
            sig.params.push(AbiParam::new(types::F64)); // width
            sig.params.push(AbiParam::new(types::F64)); // height
            sig.returns.push(AbiParam::new(types::I64)); // new image handle
            let func_id = self.module.declare_function("js_sharp_resize", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sharp_resize".to_string(), func_id);
        }

        // Sharp methods (handle: i64, value: f64) -> i64 (handle)
        for name in &["js_sharp_rotate", "js_sharp_blur", "js_sharp_quality"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // image handle
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.returns.push(AbiParam::new(types::I64)); // new image handle
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // Sharp methods (handle: i64) -> i64 (handle)
        for name in &["js_sharp_grayscale", "js_sharp_flip", "js_sharp_flop", "js_sharp_negate"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // image handle
            sig.returns.push(AbiParam::new(types::I64)); // new image handle
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_sharp_to_format(handle: i64, format: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // image handle
            sig.params.push(AbiParam::new(types::I64)); // format
            sig.returns.push(AbiParam::new(types::I64)); // new image handle
            let func_id = self.module.declare_function("js_sharp_to_format", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sharp_to_format".to_string(), func_id);
        }

        // js_sharp_to_file(handle: i64, path: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // image handle
            sig.params.push(AbiParam::new(types::I64)); // path
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_sharp_to_file", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sharp_to_file".to_string(), func_id);
        }

        // js_sharp_to_buffer(handle: i64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // image handle
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_sharp_to_buffer", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sharp_to_buffer".to_string(), func_id);
        }

        // js_sharp_metadata(handle: i64) -> i64 (JSON string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // image handle
            sig.returns.push(AbiParam::new(types::I64)); // JSON metadata
            let func_id = self.module.declare_function("js_sharp_metadata", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_sharp_metadata".to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: cheerio (HTML parsing)
        // ========================================================================

        // js_cheerio_load(html: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // html
            sig.returns.push(AbiParam::new(types::I64)); // document handle
            let func_id = self.module.declare_function("js_cheerio_load", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_load".to_string(), func_id);
        }

        // js_cheerio_load_fragment(html: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // html
            sig.returns.push(AbiParam::new(types::I64)); // document handle
            let func_id = self.module.declare_function("js_cheerio_load_fragment", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_load_fragment".to_string(), func_id);
        }

        // js_cheerio_select(doc: i64, selector: i64) -> i64 (selection handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // document handle
            sig.params.push(AbiParam::new(types::I64)); // selector
            sig.returns.push(AbiParam::new(types::I64)); // selection handle
            let func_id = self.module.declare_function("js_cheerio_select", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_select".to_string(), func_id);
        }

        // Cheerio selection methods (sel: i64) -> i64 (string)
        for name in &["js_cheerio_selection_text", "js_cheerio_selection_html"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.returns.push(AbiParam::new(types::I64)); // string
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_cheerio_selection_attr(sel: i64, attr: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.params.push(AbiParam::new(types::I64)); // attribute name
            sig.returns.push(AbiParam::new(types::I64)); // attribute value
            let func_id = self.module.declare_function("js_cheerio_selection_attr", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_selection_attr".to_string(), func_id);
        }

        // js_cheerio_selection_length(sel: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.returns.push(AbiParam::new(types::F64)); // length
            let func_id = self.module.declare_function("js_cheerio_selection_length", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_selection_length".to_string(), func_id);
        }

        // Cheerio selection navigation (sel: i64) -> i64 (selection handle)
        for name in &["js_cheerio_selection_first", "js_cheerio_selection_last", "js_cheerio_selection_parent"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.returns.push(AbiParam::new(types::I64)); // new selection handle
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_cheerio_selection_eq(sel: i64, index: f64) -> i64 (selection handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.params.push(AbiParam::new(types::F64)); // index
            sig.returns.push(AbiParam::new(types::I64)); // new selection handle
            let func_id = self.module.declare_function("js_cheerio_selection_eq", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_selection_eq".to_string(), func_id);
        }

        // Cheerio selection find/children (sel: i64, selector: i64) -> i64 (selection handle)
        for name in &["js_cheerio_selection_find", "js_cheerio_selection_children"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.params.push(AbiParam::new(types::I64)); // selector
            sig.returns.push(AbiParam::new(types::I64)); // new selection handle
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_cheerio_selection_has_class(sel: i64, class: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.params.push(AbiParam::new(types::I64)); // class name
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_cheerio_selection_has_class", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_selection_has_class".to_string(), func_id);
        }

        // js_cheerio_selection_is(sel: i64, selector: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.params.push(AbiParam::new(types::I64)); // selector
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_cheerio_selection_is", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_selection_is".to_string(), func_id);
        }

        // Cheerio array methods (sel: i64) -> i64 (array)
        for name in &["js_cheerio_selection_to_array", "js_cheerio_selection_texts"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.returns.push(AbiParam::new(types::I64)); // array
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_cheerio_selection_attrs(sel: i64, attr: i64) -> i64 (array)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // selection handle
            sig.params.push(AbiParam::new(types::I64)); // attribute name
            sig.returns.push(AbiParam::new(types::I64)); // array
            let func_id = self.module.declare_function("js_cheerio_selection_attrs", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cheerio_selection_attrs".to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: lodash (utility functions)
        // ========================================================================

        // Lodash array functions (arr: i64, n: f64) -> i64 (array)
        for name in &[
            "js_lodash_drop", "js_lodash_drop_right", "js_lodash_take", "js_lodash_take_right",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array
            sig.params.push(AbiParam::new(types::F64)); // n
            sig.returns.push(AbiParam::new(types::I64)); // new array
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_lodash_chunk(arr: i64, size: f64) -> i64 (array)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array
            sig.params.push(AbiParam::new(types::F64)); // size
            sig.returns.push(AbiParam::new(types::I64)); // chunked array
            let func_id = self.module.declare_function("js_lodash_chunk", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lodash_chunk".to_string(), func_id);
        }

        // Lodash array functions (arr: i64) -> i64 (array)
        for name in &[
            "js_lodash_compact", "js_lodash_flatten", "js_lodash_initial",
            "js_lodash_tail", "js_lodash_uniq", "js_lodash_reverse",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array
            sig.returns.push(AbiParam::new(types::I64)); // new array
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // Lodash array functions (arr: i64, arr2: i64) -> i64 (array)
        for name in &["js_lodash_concat", "js_lodash_difference"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array1
            sig.params.push(AbiParam::new(types::I64)); // array2
            sig.returns.push(AbiParam::new(types::I64)); // new array
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // Lodash array getters (arr: i64) -> f64
        for name in &["js_lodash_first", "js_lodash_last", "js_lodash_size"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // array
            sig.returns.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // Lodash string functions (str: i64) -> i64 (string)
        for name in &[
            "js_lodash_camel_case", "js_lodash_capitalize", "js_lodash_kebab_case",
            "js_lodash_lower_case", "js_lodash_snake_case", "js_lodash_start_case",
            "js_lodash_upper_case", "js_lodash_upper_first", "js_lodash_lower_first",
            "js_lodash_trim", "js_lodash_trim_start", "js_lodash_trim_end",
            "js_lodash_escape", "js_lodash_unescape",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.returns.push(AbiParam::new(types::I64)); // new string
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_lodash_pad(str: i64, length: f64) -> i64 (string)
        for name in &["js_lodash_pad", "js_lodash_pad_start", "js_lodash_pad_end"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.params.push(AbiParam::new(types::F64)); // length
            sig.returns.push(AbiParam::new(types::I64)); // padded string
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_lodash_repeat(str: i64, n: f64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.params.push(AbiParam::new(types::F64)); // n
            sig.returns.push(AbiParam::new(types::I64)); // repeated string
            let func_id = self.module.declare_function("js_lodash_repeat", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lodash_repeat".to_string(), func_id);
        }

        // js_lodash_truncate(str: i64, length: f64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.params.push(AbiParam::new(types::F64)); // length
            sig.returns.push(AbiParam::new(types::I64)); // truncated string
            let func_id = self.module.declare_function("js_lodash_truncate", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lodash_truncate".to_string(), func_id);
        }

        // js_lodash_starts_with(str: i64, target: i64) -> f64 (bool)
        for name in &["js_lodash_starts_with", "js_lodash_ends_with", "js_lodash_includes"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.params.push(AbiParam::new(types::I64)); // target
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_lodash_split(str: i64, separator: i64) -> i64 (array)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.params.push(AbiParam::new(types::I64)); // separator
            sig.returns.push(AbiParam::new(types::I64)); // array
            let func_id = self.module.declare_function("js_lodash_split", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lodash_split".to_string(), func_id);
        }

        // js_lodash_replace(str: i64, pattern: i64, replacement: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.params.push(AbiParam::new(types::I64)); // pattern
            sig.params.push(AbiParam::new(types::I64)); // replacement
            sig.returns.push(AbiParam::new(types::I64)); // new string
            let func_id = self.module.declare_function("js_lodash_replace", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lodash_replace".to_string(), func_id);
        }

        // Lodash number functions
        // js_lodash_clamp(value: f64, lower: f64, upper: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.params.push(AbiParam::new(types::F64)); // lower
            sig.params.push(AbiParam::new(types::F64)); // upper
            sig.returns.push(AbiParam::new(types::F64)); // clamped value
            let func_id = self.module.declare_function("js_lodash_clamp", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lodash_clamp".to_string(), func_id);
        }

        // js_lodash_in_range(value: f64, start: f64, end: f64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.params.push(AbiParam::new(types::F64)); // start
            sig.params.push(AbiParam::new(types::F64)); // end
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_lodash_in_range", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lodash_in_range".to_string(), func_id);
        }

        // js_lodash_random(lower: f64, upper: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // lower
            sig.params.push(AbiParam::new(types::F64)); // upper
            sig.returns.push(AbiParam::new(types::F64)); // random value
            let func_id = self.module.declare_function("js_lodash_random", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_lodash_random".to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: moment (date manipulation)
        // ========================================================================

        // js_moment_now() -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_moment_now", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_moment_now".to_string(), func_id);
        }

        // js_moment_from_timestamp(timestamp: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // timestamp
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_moment_from_timestamp", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_moment_from_timestamp".to_string(), func_id);
        }

        // js_moment_parse(dateStr: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // date string
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_moment_parse", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_moment_parse".to_string(), func_id);
        }

        // js_moment_format(handle: i64, pattern: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // pattern
            sig.returns.push(AbiParam::new(types::I64)); // formatted string
            let func_id = self.module.declare_function("js_moment_format", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_moment_format".to_string(), func_id);
        }

        // Moment getters (handle: i64) -> f64
        for name in &[
            "js_moment_value_of", "js_moment_unix", "js_moment_year", "js_moment_month",
            "js_moment_date", "js_moment_day", "js_moment_hour", "js_moment_minute",
            "js_moment_second", "js_moment_millisecond", "js_moment_is_valid",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.returns.push(AbiParam::new(types::F64)); // value
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_moment_add(handle: i64, value: f64, unit: i64) -> i64 (handle)
        for name in &["js_moment_add", "js_moment_subtract"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::F64)); // value
            sig.params.push(AbiParam::new(types::I64)); // unit
            sig.returns.push(AbiParam::new(types::I64)); // new handle
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_moment_start_of(handle: i64, unit: i64) -> i64 (handle)
        for name in &["js_moment_start_of", "js_moment_end_of"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // unit
            sig.returns.push(AbiParam::new(types::I64)); // new handle
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_moment_diff(handle: i64, other: i64, unit: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // other
            sig.params.push(AbiParam::new(types::I64)); // unit
            sig.returns.push(AbiParam::new(types::F64)); // diff
            let func_id = self.module.declare_function("js_moment_diff", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_moment_diff".to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: cron/node-cron (job scheduling)
        // ========================================================================

        // js_cron_validate(expr: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // expression
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_cron_validate", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_validate".to_string(), func_id);
        }

        // js_cron_schedule(expr: i64, callback_id: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // expression
            sig.params.push(AbiParam::new(types::F64)); // callback_id
            sig.returns.push(AbiParam::new(types::I64)); // job handle
            let func_id = self.module.declare_function("js_cron_schedule", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_schedule".to_string(), func_id);
        }

        // Cron job control (handle: i64)
        for name in &["js_cron_job_start", "js_cron_job_stop"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // job handle
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_cron_job_is_running(handle: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // job handle
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_cron_job_is_running", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_job_is_running".to_string(), func_id);
        }

        // js_cron_next_date(handle: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // job handle
            sig.returns.push(AbiParam::new(types::I64)); // ISO string
            let func_id = self.module.declare_function("js_cron_next_date", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_next_date".to_string(), func_id);
        }

        // js_cron_next_dates(handle: i64, count: f64) -> i64 (array)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // job handle
            sig.params.push(AbiParam::new(types::F64)); // count
            sig.returns.push(AbiParam::new(types::I64)); // array of ISO strings
            let func_id = self.module.declare_function("js_cron_next_dates", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_next_dates".to_string(), func_id);
        }

        // js_cron_describe(expr: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // expression
            sig.returns.push(AbiParam::new(types::I64)); // description
            let func_id = self.module.declare_function("js_cron_describe", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_describe".to_string(), func_id);
        }

        // js_cron_set_interval(callback_id: f64, interval: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // callback_id
            sig.params.push(AbiParam::new(types::F64)); // interval_ms
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_cron_set_interval", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_set_interval".to_string(), func_id);
        }

        // js_cron_clear_interval(handle: i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_cron_clear_interval", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_clear_interval".to_string(), func_id);
        }

        // js_cron_set_timeout(callback_id: f64, timeout: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // callback_id
            sig.params.push(AbiParam::new(types::F64)); // timeout_ms
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_cron_set_timeout", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_set_timeout".to_string(), func_id);
        }

        // js_cron_clear_timeout(handle: i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_cron_clear_timeout", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_cron_clear_timeout".to_string(), func_id);
        }

        // ========================================================================
        // Tier 5: rate-limiter-flexible
        // ========================================================================

        // js_ratelimit_create(options: i64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // options (JSON)
            sig.returns.push(AbiParam::new(types::I64)); // handle
            let func_id = self.module.declare_function("js_ratelimit_create", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ratelimit_create".to_string(), func_id);
        }

        // Rate limiter async methods (handle: i64, key: i64) -> Promise (i64)
        for name in &["js_ratelimit_get", "js_ratelimit_delete"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // Rate limiter methods with points (handle: i64, key: i64, points: f64) -> Promise (i64)
        for name in &["js_ratelimit_consume", "js_ratelimit_penalty", "js_ratelimit_reward"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key
            sig.params.push(AbiParam::new(types::F64)); // points
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_ratelimit_block(handle: i64, key: i64, duration: f64) -> Promise (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // handle
            sig.params.push(AbiParam::new(types::I64)); // key
            sig.params.push(AbiParam::new(types::F64)); // duration
            sig.returns.push(AbiParam::new(types::I64)); // Promise
            let func_id = self.module.declare_function("js_ratelimit_block", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ratelimit_block".to_string(), func_id);
        }

        // ========================================================================
        // Perry Native Framework: HTTP Server
        // ========================================================================

        // js_http_server_create(port: f64) -> i64 (handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // port
            sig.returns.push(AbiParam::new(types::I64)); // server handle
            let func_id = self.module.declare_function("js_http_server_create", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_server_create".to_string(), func_id);
        }

        // js_http_server_accept_v2(server: i64) -> i64 (request handle)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // server handle
            sig.returns.push(AbiParam::new(types::I64)); // request handle
            let func_id = self.module.declare_function("js_http_server_accept_v2", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_server_accept_v2".to_string(), func_id);
        }

        // js_http_server_close(server: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // server handle
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_http_server_close", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_server_close".to_string(), func_id);
        }

        // Request property getters (req: i64) -> i64 (string)
        for name in &[
            "js_http_request_method",
            "js_http_request_path",
            "js_http_request_query",
            "js_http_request_body",
            "js_http_request_content_type",
            "js_http_request_query_all",
            "js_http_request_headers_all",
        ] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.returns.push(AbiParam::new(types::I64)); // string
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_http_request_header(req: i64, name: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.params.push(AbiParam::new(types::I64)); // header name
            sig.returns.push(AbiParam::new(types::I64)); // header value
            let func_id = self.module.declare_function("js_http_request_header", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_request_header".to_string(), func_id);
        }

        // js_http_request_query_param(req: i64, name: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.params.push(AbiParam::new(types::I64)); // param name
            sig.returns.push(AbiParam::new(types::I64)); // param value
            let func_id = self.module.declare_function("js_http_request_query_param", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_request_query_param".to_string(), func_id);
        }

        // js_http_request_id(req: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.returns.push(AbiParam::new(types::F64)); // request id
            let func_id = self.module.declare_function("js_http_request_id", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_request_id".to_string(), func_id);
        }

        // js_http_request_body_length(req: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.returns.push(AbiParam::new(types::F64)); // body length
            let func_id = self.module.declare_function("js_http_request_body_length", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_request_body_length".to_string(), func_id);
        }

        // Boolean request checks (req: i64, arg: i64) -> f64 (bool)
        for name in &["js_http_request_has_header", "js_http_request_is_method"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.params.push(AbiParam::new(types::I64)); // name/method
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // Response functions: js_http_respond_text/json/html(req: i64, status: f64, body: i64) -> f64
        for name in &["js_http_respond_text", "js_http_respond_json", "js_http_respond_html"] {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.params.push(AbiParam::new(types::F64)); // status
            sig.params.push(AbiParam::new(types::I64)); // body
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_http_respond_with_headers(req: i64, status: f64, body: i64, headers: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.params.push(AbiParam::new(types::F64)); // status
            sig.params.push(AbiParam::new(types::I64)); // body
            sig.params.push(AbiParam::new(types::I64)); // headers json
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_http_respond_with_headers", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_respond_with_headers".to_string(), func_id);
        }

        // js_http_respond_redirect(req: i64, url: i64, permanent: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.params.push(AbiParam::new(types::I64)); // url
            sig.params.push(AbiParam::new(types::F64)); // permanent (bool)
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_http_respond_redirect", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_respond_redirect".to_string(), func_id);
        }

        // js_http_respond_not_found(req: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_http_respond_not_found", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_respond_not_found".to_string(), func_id);
        }

        // js_http_respond_error(req: i64, status: f64, message: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // request handle
            sig.params.push(AbiParam::new(types::F64)); // status
            sig.params.push(AbiParam::new(types::I64)); // message
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_http_respond_error", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_respond_error".to_string(), func_id);
        }

        // js_http_respond_status_text(status: f64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // status
            sig.returns.push(AbiParam::new(types::I64)); // status text
            let func_id = self.module.declare_function("js_http_respond_status_text", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_http_respond_status_text".to_string(), func_id);
        }

        // ========================================================================
        // Perry Native Framework: JSON
        // ========================================================================

        // js_json_parse(text: i64) -> i64 (JSValue bits)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // text
            sig.returns.push(AbiParam::new(types::I64)); // JSValue bits (returned in x0)
            let func_id = self.module.declare_function("js_json_parse", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_parse".to_string(), func_id);
        }

        // js_json_stringify(value: f64) -> i64 (generic stringify for any JSValue)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // value (JSValue)
            sig.returns.push(AbiParam::new(types::I64)); // json string
            let func_id = self.module.declare_function("js_json_stringify", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_stringify".to_string(), func_id);
        }

        // JSON stringify functions (various types) -> i64 (string)
        for name in &["js_json_stringify_null"] {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // string
            let func_id = self.module.declare_function(name, Linkage::Import, &sig)?;
            self.extern_funcs.insert(name.to_string(), func_id);
        }

        // js_json_stringify_string(str: i64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string
            sig.returns.push(AbiParam::new(types::I64)); // json string
            let func_id = self.module.declare_function("js_json_stringify_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_stringify_string".to_string(), func_id);
        }

        // js_json_stringify_number(num: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // number
            sig.returns.push(AbiParam::new(types::I64)); // json string
            let func_id = self.module.declare_function("js_json_stringify_number", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_stringify_number".to_string(), func_id);
        }

        // js_json_stringify_bool(bool: f64) -> i64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // bool as f64
            sig.returns.push(AbiParam::new(types::I64)); // json string
            let func_id = self.module.declare_function("js_json_stringify_bool", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_stringify_bool".to_string(), func_id);
        }

        // js_json_is_valid(text: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // text
            sig.returns.push(AbiParam::new(types::F64)); // bool
            let func_id = self.module.declare_function("js_json_is_valid", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_is_valid".to_string(), func_id);
        }

        // js_json_get_string(json: i64, key: i64) -> i64 (string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // json string
            sig.params.push(AbiParam::new(types::I64)); // key
            sig.returns.push(AbiParam::new(types::I64)); // value string
            let func_id = self.module.declare_function("js_json_get_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_get_string".to_string(), func_id);
        }

        // js_json_get_number(json: i64, key: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // json string
            sig.params.push(AbiParam::new(types::I64)); // key
            sig.returns.push(AbiParam::new(types::F64)); // value number
            let func_id = self.module.declare_function("js_json_get_number", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_get_number".to_string(), func_id);
        }

        // js_json_get_bool(json: i64, key: i64) -> f64 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // json string
            sig.params.push(AbiParam::new(types::I64)); // key
            sig.returns.push(AbiParam::new(types::F64)); // value bool
            let func_id = self.module.declare_function("js_json_get_bool", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_json_get_bool".to_string(), func_id);
        }

        // ========================================================================
        // Perry Native Framework: Math
        // ========================================================================

        // js_math_pow(base: f64, exp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // base
            sig.params.push(AbiParam::new(types::F64)); // exponent
            sig.returns.push(AbiParam::new(types::F64)); // result
            let func_id = self.module.declare_function("js_math_pow", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_math_pow".to_string(), func_id);
        }

        // js_math_random() -> f64
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64)); // random number 0..1
            let func_id = self.module.declare_function("js_math_random", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_math_random".to_string(), func_id);
        }

        // ========================================================================
        // Perry Native Framework: Date
        // ========================================================================

        // js_date_now() -> f64 (timestamp in milliseconds)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_now", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_now".to_string(), func_id);
        }

        // js_date_new() -> f64 (timestamp in milliseconds)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_new".to_string(), func_id);
        }

        // js_date_new_from_timestamp(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_new_from_timestamp", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_new_from_timestamp".to_string(), func_id);
        }

        // js_date_get_time(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_get_time", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_get_time".to_string(), func_id);
        }

        // js_date_to_iso_string(timestamp: f64) -> *mut StringHeader (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_date_to_iso_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_to_iso_string".to_string(), func_id);
        }

        // js_date_get_full_year(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_get_full_year", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_get_full_year".to_string(), func_id);
        }

        // js_date_get_month(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_get_month", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_get_month".to_string(), func_id);
        }

        // js_date_get_date(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_get_date", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_get_date".to_string(), func_id);
        }

        // js_date_get_hours(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_get_hours", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_get_hours".to_string(), func_id);
        }

        // js_date_get_minutes(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_get_minutes", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_get_minutes".to_string(), func_id);
        }

        // js_date_get_seconds(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_get_seconds", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_get_seconds".to_string(), func_id);
        }

        // js_date_get_milliseconds(timestamp: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_date_get_milliseconds", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_date_get_milliseconds".to_string(), func_id);
        }

        // Error runtime functions
        // js_error_new() -> *mut ErrorHeader
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // error pointer
            let func_id = self.module.declare_function("js_error_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_error_new".to_string(), func_id);
        }

        // js_error_new_with_message(message: *mut StringHeader) -> *mut ErrorHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // message pointer
            sig.returns.push(AbiParam::new(types::I64)); // error pointer
            let func_id = self.module.declare_function("js_error_new_with_message", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_error_new_with_message".to_string(), func_id);
        }

        // js_error_get_message(error: *mut ErrorHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // error pointer
            sig.returns.push(AbiParam::new(types::I64)); // message pointer
            let func_id = self.module.declare_function("js_error_get_message", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_error_get_message".to_string(), func_id);
        }

        // Delete operator runtime functions
        // js_object_delete_field(obj: *mut ObjectHeader, field_name: *const StringHeader) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.params.push(AbiParam::new(types::I64)); // field name pointer
            sig.returns.push(AbiParam::new(types::I32)); // bool (1 = success, 0 = failure)
            let func_id = self.module.declare_function("js_object_delete_field", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_object_delete_field".to_string(), func_id);
        }

        // js_object_delete_dynamic(obj: *mut ObjectHeader, key: f64) -> i32
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // object pointer
            sig.params.push(AbiParam::new(types::F64)); // key (could be string pointer or number index)
            sig.returns.push(AbiParam::new(types::I32)); // bool (1 = success, 0 = failure)
            let func_id = self.module.declare_function("js_object_delete_dynamic", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_object_delete_dynamic".to_string(), func_id);
        }

        // URL runtime functions
        // js_url_new(url: *mut StringHeader) -> *mut UrlHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url string pointer
            sig.returns.push(AbiParam::new(types::I64)); // url pointer
            let func_id = self.module.declare_function("js_url_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_new".to_string(), func_id);
        }

        // js_url_new_with_base(url: *mut StringHeader, base: *mut StringHeader) -> *mut UrlHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url string pointer
            sig.params.push(AbiParam::new(types::I64)); // base string pointer
            sig.returns.push(AbiParam::new(types::I64)); // url pointer
            let func_id = self.module.declare_function("js_url_new_with_base", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_new_with_base".to_string(), func_id);
        }

        // js_url_get_href(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_href", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_href".to_string(), func_id);
        }

        // js_url_get_pathname(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_pathname", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_pathname".to_string(), func_id);
        }

        // js_url_get_protocol(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_protocol", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_protocol".to_string(), func_id);
        }

        // js_url_get_host(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_host", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_host".to_string(), func_id);
        }

        // js_url_get_hostname(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_hostname", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_hostname".to_string(), func_id);
        }

        // js_url_get_port(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_port", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_port".to_string(), func_id);
        }

        // js_url_get_search(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_search", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_search".to_string(), func_id);
        }

        // js_url_get_hash(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_hash", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_hash".to_string(), func_id);
        }

        // js_url_get_origin(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_get_origin", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_origin".to_string(), func_id);
        }

        // js_url_get_search_params(url: *mut UrlHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // url pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer (for now, later would return URLSearchParams)
            let func_id = self.module.declare_function("js_url_get_search_params", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_get_search_params".to_string(), func_id);
        }

        // URLSearchParams runtime functions
        // js_url_search_params_new(init: *mut StringHeader) -> *mut ObjectHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // init string pointer
            sig.returns.push(AbiParam::new(types::I64)); // URLSearchParams object pointer
            let func_id = self.module.declare_function("js_url_search_params_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_new".to_string(), func_id);
        }

        // js_url_search_params_new_empty() -> *mut ObjectHeader
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // URLSearchParams object pointer
            let func_id = self.module.declare_function("js_url_search_params_new_empty", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_new_empty".to_string(), func_id);
        }

        // js_url_search_params_get(params: *mut ObjectHeader, name: *mut StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // params pointer
            sig.params.push(AbiParam::new(types::I64)); // name string pointer
            sig.returns.push(AbiParam::new(types::I64)); // value (string pointer or null)
            let func_id = self.module.declare_function("js_url_search_params_get", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_get".to_string(), func_id);
        }

        // js_url_search_params_has(params: *mut ObjectHeader, name: *mut StringHeader) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // params pointer
            sig.params.push(AbiParam::new(types::I64)); // name string pointer
            sig.returns.push(AbiParam::new(types::F64)); // boolean
            let func_id = self.module.declare_function("js_url_search_params_has", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_has".to_string(), func_id);
        }

        // js_url_search_params_set(params: *mut ObjectHeader, name: *mut StringHeader, value: *mut StringHeader) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // params pointer
            sig.params.push(AbiParam::new(types::I64)); // name string pointer
            sig.params.push(AbiParam::new(types::I64)); // value string pointer
            let func_id = self.module.declare_function("js_url_search_params_set", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_set".to_string(), func_id);
        }

        // js_url_search_params_append(params: *mut ObjectHeader, name: *mut StringHeader, value: *mut StringHeader) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // params pointer
            sig.params.push(AbiParam::new(types::I64)); // name string pointer
            sig.params.push(AbiParam::new(types::I64)); // value string pointer
            let func_id = self.module.declare_function("js_url_search_params_append", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_append".to_string(), func_id);
        }

        // js_url_search_params_delete(params: *mut ObjectHeader, name: *mut StringHeader) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // params pointer
            sig.params.push(AbiParam::new(types::I64)); // name string pointer
            let func_id = self.module.declare_function("js_url_search_params_delete", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_delete".to_string(), func_id);
        }

        // js_url_search_params_to_string(params: *mut ObjectHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // params pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_url_search_params_to_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_to_string".to_string(), func_id);
        }

        // js_url_search_params_get_all(params: *mut ObjectHeader, name: *mut StringHeader) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // params pointer
            sig.params.push(AbiParam::new(types::I64)); // name string pointer
            sig.returns.push(AbiParam::new(types::F64)); // array
            let func_id = self.module.declare_function("js_url_search_params_get_all", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_url_search_params_get_all".to_string(), func_id);
        }

        // AbortController runtime functions
        // js_abort_controller_new() -> *mut ObjectHeader
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64)); // AbortController object pointer
            let func_id = self.module.declare_function("js_abort_controller_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_abort_controller_new".to_string(), func_id);
        }

        // js_abort_controller_signal(controller: *mut ObjectHeader) -> *mut ObjectHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // controller pointer
            sig.returns.push(AbiParam::new(types::I64)); // signal object pointer
            let func_id = self.module.declare_function("js_abort_controller_signal", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_abort_controller_signal".to_string(), func_id);
        }

        // js_abort_controller_abort(controller: *mut ObjectHeader)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // controller pointer
            let func_id = self.module.declare_function("js_abort_controller_abort", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_abort_controller_abort".to_string(), func_id);
        }

        // RegExp runtime functions
        // js_regexp_new(pattern: *const StringHeader, flags: *const StringHeader) -> *mut RegExpHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // pattern pointer
            sig.params.push(AbiParam::new(types::I64)); // flags pointer
            sig.returns.push(AbiParam::new(types::I64)); // regexp pointer
            let func_id = self.module.declare_function("js_regexp_new", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_regexp_new".to_string(), func_id);
        }

        // js_regexp_test(re: *const RegExpHeader, s: *const StringHeader) -> bool
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // regex pointer
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::I32)); // bool (i32)
            let func_id = self.module.declare_function("js_regexp_test", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_regexp_test".to_string(), func_id);
        }

        // js_string_match(s: *const StringHeader, re: *const RegExpHeader) -> *mut ArrayHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I64)); // regex pointer
            sig.returns.push(AbiParam::new(types::I64)); // array pointer (or null)
            let func_id = self.module.declare_function("js_string_match", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_string_match".to_string(), func_id);
        }

        // js_string_replace_regex(s: *const StringHeader, re: *const RegExpHeader, replacement: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I64)); // regex pointer
            sig.params.push(AbiParam::new(types::I64)); // replacement string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function("js_string_replace_regex", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_string_replace_regex".to_string(), func_id);
        }

        // js_string_replace_string(s: *const StringHeader, pattern: *const StringHeader, replacement: *const StringHeader) -> *mut StringHeader
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::I64)); // pattern string pointer
            sig.params.push(AbiParam::new(types::I64)); // replacement string pointer
            sig.returns.push(AbiParam::new(types::I64)); // result string pointer
            let func_id = self.module.declare_function("js_string_replace_string", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_string_replace_string".to_string(), func_id);
        }

        // js_value_typeof(value: f64) -> *mut StringHeader (returns the typeof string)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed value
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_value_typeof", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_value_typeof".to_string(), func_id);
        }

        // js_string_equals(a: *const StringHeader, b: *const StringHeader) -> bool
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // a string pointer
            sig.params.push(AbiParam::new(types::I64)); // b string pointer
            sig.returns.push(AbiParam::new(types::I32)); // bool (i32)
            let func_id = self.module.declare_function("js_string_equals", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_string_equals".to_string(), func_id);
        }

        // js_dynamic_string_equals(a: f64, b: f64) -> i32
        // Compares strings that may be NaN-boxed (from PropertyGet) or raw pointers (from literals)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // a value (may be NaN-boxed or raw)
            sig.params.push(AbiParam::new(types::F64)); // b value (may be NaN-boxed or raw)
            sig.returns.push(AbiParam::new(types::I32)); // bool (i32)
            let func_id = self.module.declare_function("js_dynamic_string_equals", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_dynamic_string_equals".to_string(), func_id);
        }

        // js_parse_int(str: i64, radix: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::F64)); // radix
            sig.returns.push(AbiParam::new(types::F64)); // result number
            let func_id = self.module.declare_function("js_parse_int", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_parse_int".to_string(), func_id);
        }

        // js_parse_float(str: i64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::F64)); // result number
            let func_id = self.module.declare_function("js_parse_float", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_parse_float".to_string(), func_id);
        }

        // js_number_coerce(value: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed value
            sig.returns.push(AbiParam::new(types::F64)); // result number
            let func_id = self.module.declare_function("js_number_coerce", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_number_coerce".to_string(), func_id);
        }

        // js_string_coerce(value: f64) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed value
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_string_coerce", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_string_coerce".to_string(), func_id);
        }

        // js_is_nan(value: f64) -> f64 (boolean as 1.0/0.0)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed value
            sig.returns.push(AbiParam::new(types::F64)); // boolean result
            let func_id = self.module.declare_function("js_is_nan", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_is_nan".to_string(), func_id);
        }

        // js_is_finite(value: f64) -> f64 (boolean as 1.0/0.0)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // NaN-boxed value
            sig.returns.push(AbiParam::new(types::F64)); // boolean result
            let func_id = self.module.declare_function("js_is_finite", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_is_finite".to_string(), func_id);
        }

        // js_ethers_format_units(bigint: i64, decimals: f64) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // bigint pointer
            sig.params.push(AbiParam::new(types::F64)); // decimals
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_ethers_format_units", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ethers_format_units".to_string(), func_id);
        }

        // js_ethers_parse_units(str: i64, decimals: f64) -> i64 (bigint pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.params.push(AbiParam::new(types::F64)); // decimals
            sig.returns.push(AbiParam::new(types::I64)); // bigint pointer
            let func_id = self.module.declare_function("js_ethers_parse_units", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ethers_parse_units".to_string(), func_id);
        }

        // js_ethers_get_address(str: i64) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_ethers_get_address", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ethers_get_address".to_string(), func_id);
        }

        // js_ethers_parse_ether(str: i64) -> i64 (bigint pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // string pointer
            sig.returns.push(AbiParam::new(types::I64)); // bigint pointer
            let func_id = self.module.declare_function("js_ethers_parse_ether", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ethers_parse_ether".to_string(), func_id);
        }

        // js_ethers_format_ether(bigint: i64) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // bigint pointer
            sig.returns.push(AbiParam::new(types::I64)); // string pointer
            let func_id = self.module.declare_function("js_ethers_format_ether", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_ethers_format_ether".to_string(), func_id);
        }

        // ============================================
        // Fastify HTTP Framework FFI functions
        // ============================================

        // js_fastify_create() -> Handle (i64)
        {
            let mut sig = self.module.make_signature();
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_create", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_create".to_string(), func_id);
        }

        // js_fastify_create_with_opts(opts: f64) -> Handle (i64)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // opts object
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_create_with_opts", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_create_with_opts".to_string(), func_id);
        }

        // js_fastify_get(app: Handle, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // app handle
            sig.params.push(AbiParam::new(types::I64)); // path string
            sig.params.push(AbiParam::new(types::I64)); // handler closure
            sig.returns.push(AbiParam::new(types::I32)); // bool
            let func_id = self.module.declare_function("js_fastify_get", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_get".to_string(), func_id);
        }

        // js_fastify_post(app: Handle, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_post", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_post".to_string(), func_id);
        }

        // js_fastify_put(app: Handle, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_put", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_put".to_string(), func_id);
        }

        // js_fastify_delete(app: Handle, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_delete", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_delete".to_string(), func_id);
        }

        // js_fastify_patch(app: Handle, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_patch", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_patch".to_string(), func_id);
        }

        // js_fastify_head(app: Handle, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_head", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_head".to_string(), func_id);
        }

        // js_fastify_options(app: Handle, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_options", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_options".to_string(), func_id);
        }

        // js_fastify_all(app: Handle, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_all", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_all".to_string(), func_id);
        }

        // js_fastify_route(app: Handle, method: i64, path: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_route", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_route".to_string(), func_id);
        }

        // js_fastify_add_hook(app: Handle, hook_name: i64, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_add_hook", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_add_hook".to_string(), func_id);
        }

        // js_fastify_set_error_handler(app: Handle, handler: i64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_set_error_handler", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_set_error_handler".to_string(), func_id);
        }

        // js_fastify_register(app: Handle, plugin: i64, opts: f64) -> bool (i32)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // app handle
            sig.params.push(AbiParam::new(types::I64)); // plugin closure
            sig.params.push(AbiParam::new(types::F64)); // opts object
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_register", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_register".to_string(), func_id);
        }

        // js_fastify_listen(app: Handle, opts: f64, callback: i64) -> void
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // app handle
            sig.params.push(AbiParam::new(types::F64)); // opts object (contains port)
            sig.params.push(AbiParam::new(types::I64)); // callback closure
            let func_id = self.module.declare_function("js_fastify_listen", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_listen".to_string(), func_id);
        }

        // ---- Context/Request/Reply methods ----

        // js_fastify_req_method(ctx: Handle) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_req_method", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_method".to_string(), func_id);
        }

        // js_fastify_req_url(ctx: Handle) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_req_url", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_url".to_string(), func_id);
        }

        // js_fastify_req_params(ctx: Handle) -> i64 (string pointer - JSON)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_req_params", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_params".to_string(), func_id);
        }

        // js_fastify_req_param(ctx: Handle, name: i64) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_req_param", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_param".to_string(), func_id);
        }

        // js_fastify_req_query(ctx: Handle) -> i64 (string pointer - JSON)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_req_query", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_query".to_string(), func_id);
        }

        // js_fastify_req_body(ctx: Handle) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_req_body", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_body".to_string(), func_id);
        }

        // js_fastify_req_json(ctx: Handle) -> f64 (NaN-boxed object)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_fastify_req_json", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_json".to_string(), func_id);
        }

        // js_fastify_req_headers(ctx: Handle) -> i64 (string pointer - JSON)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_req_headers", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_headers".to_string(), func_id);
        }

        // js_fastify_req_header(ctx: Handle, name: i64) -> i64 (string pointer)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_req_header", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_req_header".to_string(), func_id);
        }

        // js_fastify_reply_status(ctx: Handle, code: f64) -> i64 (handle - chainable)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_reply_status", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_reply_status".to_string(), func_id);
        }

        // js_fastify_reply_header(ctx: Handle, name: i64, value: i64) -> i64 (handle - chainable)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.returns.push(AbiParam::new(types::I64));
            let func_id = self.module.declare_function("js_fastify_reply_header", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_reply_header".to_string(), func_id);
        }

        // js_fastify_reply_send(ctx: Handle, data: f64) -> i32 (bool)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::I32));
            let func_id = self.module.declare_function("js_fastify_reply_send", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_reply_send".to_string(), func_id);
        }

        // js_fastify_ctx_json(ctx: Handle, data: f64, status: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_fastify_ctx_json", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_ctx_json".to_string(), func_id);
        }

        // js_fastify_ctx_text(ctx: Handle, text: i64, status: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_fastify_ctx_text", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_ctx_text".to_string(), func_id);
        }

        // js_fastify_ctx_html(ctx: Handle, html: i64, status: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_fastify_ctx_html", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_ctx_html".to_string(), func_id);
        }

        // js_fastify_ctx_redirect(ctx: Handle, url: i64, status: f64) -> f64
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::I64));
            sig.params.push(AbiParam::new(types::F64));
            sig.returns.push(AbiParam::new(types::F64));
            let func_id = self.module.declare_function("js_fastify_ctx_redirect", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_fastify_ctx_redirect".to_string(), func_id);
        }

        // ============================================
        // V8 JavaScript Runtime FFI functions
        // ============================================

        // js_runtime_init() -> void
        // Initialize the V8 JavaScript runtime
        {
            let sig = self.module.make_signature();
            let func_id = self.module.declare_function("js_runtime_init", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_runtime_init".to_string(), func_id);
        }

        // js_load_module(path_ptr: i64, path_len: i64) -> u64 (module handle)
        // Load a JavaScript module and return a handle
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // path pointer
            sig.params.push(AbiParam::new(types::I64)); // path length
            sig.returns.push(AbiParam::new(types::I64)); // module handle (u64)
            let func_id = self.module.declare_function("js_load_module", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_load_module".to_string(), func_id);
        }

        // js_get_export(module_handle: u64, name_ptr: i64, name_len: i64) -> f64 (NaN-boxed value)
        // Get an export from a loaded module
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // module handle
            sig.params.push(AbiParam::new(types::I64)); // export name pointer
            sig.params.push(AbiParam::new(types::I64)); // export name length
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed value
            let func_id = self.module.declare_function("js_get_export", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_get_export".to_string(), func_id);
        }

        // js_call_function(module_handle: u64, name_ptr: i64, name_len: i64, args_ptr: i64, args_len: i64) -> f64
        // Call a function from a loaded module
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // module handle
            sig.params.push(AbiParam::new(types::I64)); // function name pointer
            sig.params.push(AbiParam::new(types::I64)); // function name length
            sig.params.push(AbiParam::new(types::I64)); // args array pointer
            sig.params.push(AbiParam::new(types::I64)); // args count
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed return value
            let func_id = self.module.declare_function("js_call_function", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_call_function".to_string(), func_id);
        }

        // js_native_call_method(object: f64, name_ptr: i64, name_len: i64, args_ptr: i64, args_len: i64) -> f64
        // Call a method on a JavaScript object
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // object (NaN-boxed)
            sig.params.push(AbiParam::new(types::I64)); // method name pointer
            sig.params.push(AbiParam::new(types::I64)); // method name length
            sig.params.push(AbiParam::new(types::I64)); // args array pointer
            sig.params.push(AbiParam::new(types::I64)); // args count
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed return value
            let func_id = self.module.declare_function("js_native_call_method", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_native_call_method".to_string(), func_id);
        }

        // js_native_call_value(func_value: f64, args_ptr: i64, args_len: i64) -> f64
        // Call a JavaScript function value directly (for callback parameters)
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // function value (NaN-boxed)
            sig.params.push(AbiParam::new(types::I64)); // args array pointer
            sig.params.push(AbiParam::new(types::I64)); // args count
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed return value
            let func_id = self.module.declare_function("js_native_call_value", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_native_call_value".to_string(), func_id);
        }

        // js_get_property(object: f64, name_ptr: i64, name_len: i64) -> f64
        // Get a property from a JavaScript object
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // object (NaN-boxed)
            sig.params.push(AbiParam::new(types::I64)); // property name pointer
            sig.params.push(AbiParam::new(types::I64)); // property name length
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed return value
            let func_id = self.module.declare_function("js_get_property", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_get_property".to_string(), func_id);
        }

        // js_set_property(object: f64, name_ptr: i64, name_len: i64, value: f64) -> void
        // Set a property on a JavaScript object
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // object (NaN-boxed)
            sig.params.push(AbiParam::new(types::I64)); // property name pointer
            sig.params.push(AbiParam::new(types::I64)); // property name length
            sig.params.push(AbiParam::new(types::F64)); // value (NaN-boxed)
            let func_id = self.module.declare_function("js_set_property", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_set_property".to_string(), func_id);
        }

        // js_new_instance(module: u64, class_ptr: i64, class_len: i64, args_ptr: i64, args_len: i64) -> f64
        // Create a new instance of a JavaScript class
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // module handle
            sig.params.push(AbiParam::new(types::I64)); // class name pointer
            sig.params.push(AbiParam::new(types::I64)); // class name length
            sig.params.push(AbiParam::new(types::I64)); // args array pointer
            sig.params.push(AbiParam::new(types::I64)); // args count
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed return value (JS handle)
            let func_id = self.module.declare_function("js_new_instance", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_new_instance".to_string(), func_id);
        }

        // js_new_from_handle(constructor: f64, args_ptr: i64, args_len: i64) -> f64
        // Create a new instance using a JS handle to a constructor
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::F64)); // constructor (NaN-boxed JS handle)
            sig.params.push(AbiParam::new(types::I64)); // args array pointer
            sig.params.push(AbiParam::new(types::I64)); // args count
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed return value (JS handle)
            let func_id = self.module.declare_function("js_new_from_handle", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_new_from_handle".to_string(), func_id);
        }

        // js_create_callback(func_ptr: i64, closure_env: i64, param_count: i64) -> f64
        // Create a V8 function that wraps a native callback
        {
            let mut sig = self.module.make_signature();
            sig.params.push(AbiParam::new(types::I64)); // function pointer
            sig.params.push(AbiParam::new(types::I64)); // closure environment pointer
            sig.params.push(AbiParam::new(types::I64)); // parameter count
            sig.returns.push(AbiParam::new(types::F64)); // NaN-boxed return value (JS handle)
            let func_id = self.module.declare_function("js_create_callback", Linkage::Import, &sig)?;
            self.extern_funcs.insert("js_create_callback".to_string(), func_id);
        }

        Ok(())
    }

    fn declare_function(&mut self, func: &Function) -> Result<()> {
        let mut sig = self.module.make_signature();

        // Add parameters based on their types
        // Track rest parameter index if any
        for (i, param) in func.params.iter().enumerate() {
            let abi_type = self.type_to_abi(&param.ty);
            sig.params.push(AbiParam::new(abi_type));
            if param.is_rest {
                self.func_rest_param_index.insert(func.id, i);
            }
        }

        // Add return type based on the declared return type
        if func.is_async {
            sig.returns.push(AbiParam::new(types::I64)); // Promise pointer
            self.async_func_ids.insert(func.id);
        } else {
            let return_abi = self.type_to_abi(&func.return_type);
            sig.returns.push(AbiParam::new(return_abi));
        }

        // Rename user "main" to "_user_main" to avoid conflict with C entry point
        let symbol_name = if func.name == "main" {
            "_user_main"
        } else {
            &func.name
        };

        let linkage = if func.is_exported {
            Linkage::Export
        } else {
            Linkage::Local
        };

        let func_id = match self.module.declare_function(symbol_name, linkage, &sig) {
            Ok(id) => id,
            Err(e) => {
                // Check if this is an incompatible declaration error
                // If so, try to find the existing function by name and use its ID
                // This handles optional parameters where functions may have different param counts
                let err_str = format!("{:?}", e);
                let err_msg = e.to_string();
                let is_incompatible = err_str.to_lowercase().contains("incompatible") ||
                                       err_msg.to_lowercase().contains("incompatible") ||
                                       matches!(e, cranelift_module::ModuleError::IncompatibleDeclaration(_));
                if is_incompatible {
                    // Try to find existing function by iterating all declarations
                    for (id, decl) in self.module.declarations().get_functions() {
                        if decl.name.as_deref() == Some(symbol_name) {
                            // Already have this function declared, map our func.id to the existing ID
                            self.func_ids.insert(func.id, id);
                            return Ok(());
                        }
                    }
                    // If not found, this is a real error
                    return Err(anyhow!("Failed to declare function {} (symbol: {}): incompatible signature and no existing declaration found", func.name, symbol_name));
                } else {
                    return Err(anyhow!("Failed to declare function {} (symbol: {}): {}", func.name, symbol_name, e));
                }
            }
        };
        self.func_ids.insert(func.id, func_id);

        Ok(())
    }

    fn compile_function(&mut self, func: &Function) -> Result<()> {
        let func_id = *self.func_ids.get(&func.id)
            .ok_or_else(|| anyhow!("Function not declared: {}", func.name))?;

        // Set up the function signature with actual types
        self.ctx.func.signature.params.clear();
        self.ctx.func.signature.returns.clear();

        // Collect param types for use in local info
        let param_abi_types: Vec<types::Type> = func.params.iter()
            .map(|p| self.type_to_abi(&p.ty))
            .collect();

        for abi_type in &param_abi_types {
            self.ctx.func.signature.params.push(AbiParam::new(*abi_type));
        }

        // Async functions return a Promise (i64 pointer)
        if func.is_async {
            self.ctx.func.signature.returns.push(AbiParam::new(types::I64));
        } else {
            let return_abi = self.type_to_abi(&func.return_type);
            self.ctx.func.signature.returns.push(AbiParam::new(return_abi));
        }

        // Collect all variables that will be mutably captured by closures (before borrowing self.ctx)
        let boxed_vars = self.collect_mutable_captures_from_stmts(&func.body);

        {
            // Build the function
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.append_block_params_for_function_params(entry_block);
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // Create variables for parameters using sequential indices (0, 1, 2, ...)
            let mut locals: HashMap<LocalId, LocalInfo> = HashMap::new();
            for (i, param) in func.params.iter().enumerate() {
                let var = Variable::new(i);  // Use sequential index, not param.id
                let abi_type = param_abi_types[i];
                builder.declare_var(var, abi_type);
                let val = builder.block_params(entry_block)[i];
                builder.def_var(var, val);
                // Determine local info flags based on type
                let is_string = matches!(param.ty, perry_types::Type::String);
                let is_array = matches!(&param.ty, perry_types::Type::Array(_));
                let is_closure = matches!(param.ty, perry_types::Type::Function(_));
                let is_bigint = matches!(param.ty, perry_types::Type::BigInt);
                let is_pointer = abi_type == types::I64;
                // Named types (interfaces) and Object types may contain NaN-boxed values
                // when accessed via PropertyGet, so treat them as potentially union
                let is_union = matches!(param.ty,
                    perry_types::Type::Union(_) |
                    perry_types::Type::Named(_) |
                    perry_types::Type::Object(_) |
                    perry_types::Type::Any);
                // Check if array has mixed element types (union or any)
                let is_mixed_array = if let perry_types::Type::Array(elem_ty) = &param.ty {
                    matches!(elem_ty.as_ref(), perry_types::Type::Union(_) | perry_types::Type::Any)
                } else {
                    false
                };
                locals.insert(param.id, LocalInfo {
                    var,
                    name: Some(param.name.clone()),
                    class_name: None,
                    type_args: Vec::new(),
                    is_pointer,
                    is_array,
                    is_string,
                    is_bigint,
                    is_closure,
                    is_boxed: false,
                    is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union,
                    is_mixed_array,
                    is_integer: false,
                    is_integer_array: false,
                    is_i32: false,
                    i32_shadow: None,
                    bounded_by_array: None,
                    bounded_by_constant: None,
                    scalar_fields: None,
                    squared_cache: None, product_cache: None,
                });
            }

            // Load module-level variables from their global slots
            // These are variables defined at module scope that the function may reference
            // Use a large offset to avoid conflicts with function params and body locals
            let mut next_var_id = 20000 + func.params.len();
            for (local_id, data_id) in &self.module_var_data_ids {
                // Get the type info from module_level_locals (populated during compile_init)
                let (var_type, local_info_template) = if let Some(info) = self.module_level_locals.get(local_id) {
                    // Variable is stored as i64 only if is_pointer && !is_union
                    let vt = if info.is_pointer && !info.is_union { types::I64 } else { types::F64 };
                    (vt, info.clone())
                } else {
                    // Fallback to f64 if type info not available
                    (types::F64, LocalInfo {
                        var: Variable::new(0), // Will be overwritten
                        name: None,
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false,
                        is_array: false,
                        is_string: false,
                        is_bigint: false,
                        is_closure: false,
                        is_boxed: false,
                        is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                        is_mixed_array: false,
                        is_integer: false,
                        is_integer_array: false,
                        is_i32: false,
                        i32_shadow: None,
                        bounded_by_array: None,
                        bounded_by_constant: None,
                        scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    })
                };

                let var = Variable::new(next_var_id);
                next_var_id += 1;
                builder.declare_var(var, var_type);

                // Load the value from the global data slot
                let global_val = self.module.declare_data_in_func(*data_id, builder.func);
                let ptr = builder.ins().global_value(types::I64, global_val);
                let val = builder.ins().load(var_type, MemFlags::new(), ptr, 0);
                builder.def_var(var, val);

                // Insert into locals so LocalGet can find it
                let mut info = local_info_template;
                info.var = var;
                locals.insert(*local_id, info);
            }

            // For async functions, create a Promise variable to track
            let promise_var = if func.is_async {
                // Use next_temp_var_id() to get a guaranteed unique ID (avoids conflicts with other temp vars)
                let var = Variable::new(next_temp_var_id());
                builder.declare_var(var, types::I64);

                // Allocate the promise: js_promise_new()
                let promise_new = self.extern_funcs.get("js_promise_new")
                    .ok_or_else(|| anyhow!("js_promise_new not declared"))?;
                let func_ref = self.module.declare_func_in_func(*promise_new, builder.func);
                let call = builder.ins().call(func_ref, &[]);
                let promise_ptr = builder.inst_results(call)[0];
                builder.def_var(var, promise_ptr);

                Some(var)
            } else {
                None
            };

            // Compile the function body
            // next_var continues from where params left off (params use 0..params.len())
            let mut next_var = func.params.len();

            // For async functions, we need to handle returns specially
            if func.is_async {
                for stmt in &func.body {
                    compile_async_stmt(&mut builder, &mut self.module, &self.func_ids, &self.closure_func_ids, &self.func_wrapper_ids, &self.extern_funcs, &self.async_func_ids, &self.closure_returning_funcs, &self.classes, &self.enums, &self.func_param_types, &self.func_union_params, &self.func_return_types, &self.func_hir_return_types, &self.func_rest_param_index, &self.imported_func_param_counts, &mut locals, &mut next_var, stmt, promise_var.unwrap(), &boxed_vars)?;
                }

                // If no explicit return, resolve with undefined and return the promise
                let current_block = builder.current_block().unwrap();
                if !is_block_filled(&builder, current_block) {
                    let promise_ptr = builder.use_var(promise_var.unwrap());

                    // Resolve with undefined
                    let resolve_func = self.extern_funcs.get("js_promise_resolve")
                        .ok_or_else(|| anyhow!("js_promise_resolve not declared"))?;
                    let resolve_ref = self.module.declare_func_in_func(*resolve_func, builder.func);
                    const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                    let undef_val = builder.ins().f64const(f64::from_bits(TAG_UNDEFINED));
                    builder.ins().call(resolve_ref, &[promise_ptr, undef_val]);

                    builder.ins().return_(&[promise_ptr]);
                }
            } else {
                for stmt in &func.body {
                    compile_stmt(&mut builder, &mut self.module, &self.func_ids, &self.closure_func_ids, &self.func_wrapper_ids, &self.extern_funcs, &self.async_func_ids, &self.closure_returning_funcs, &self.classes, &self.enums, &self.func_param_types, &self.func_union_params, &self.func_return_types, &self.func_hir_return_types, &self.func_rest_param_index, &self.imported_func_param_counts, &mut locals, &mut next_var, stmt, None, None, &boxed_vars)?;
                }

                // If no explicit return, return 0 with the correct type
                let current_block = builder.current_block().unwrap();
                if !is_block_filled(&builder, current_block) {
                    let ret_type = builder.func.signature.returns.first().map(|p| p.value_type).unwrap_or(types::F64);
                    let zero = match ret_type {
                        types::I64 => builder.ins().iconst(types::I64, 0),
                        types::I32 => builder.ins().iconst(types::I32, 0),
                        _ => builder.ins().f64const(0.0),
                    };
                    builder.ins().return_(&[zero]);
                }
            }

            builder.finalize();
        }

        // Compile and define the function
        self.module.define_function(func_id, &mut self.ctx)
            .map_err(|e| anyhow!("Error compiling function '{}': {:?}", func.name, e))?;
        self.module.clear_context(&mut self.ctx);

        Ok(())
    }

    /// Check if a function body returns a closure (by scanning return statements)
    fn function_returns_closure(&self, body: &[Stmt]) -> bool {
        for stmt in body {
            if self.stmt_returns_closure(stmt) {
                return true;
            }
        }
        false
    }

    /// Check if a statement contains a return that returns a closure
    fn stmt_returns_closure(&self, stmt: &Stmt) -> bool {
        match stmt {
            Stmt::Return(Some(expr)) => self.expr_is_closure(expr),
            Stmt::If { then_branch, else_branch, .. } => {
                for s in then_branch {
                    if self.stmt_returns_closure(s) {
                        return true;
                    }
                }
                if let Some(else_stmts) = else_branch {
                    for s in else_stmts {
                        if self.stmt_returns_closure(s) {
                            return true;
                        }
                    }
                }
                false
            }
            _ => false,
        }
    }

    /// Check if an expression is a closure
    fn expr_is_closure(&self, expr: &Expr) -> bool {
        matches!(expr, Expr::Closure { .. })
    }

    /// Collect all closures from statements (recursively) into a provided vector
    /// Tuple: (func_id, params, body, captures, mutable_captures, captures_this, enclosing_class)
    fn collect_closures_from_stmts_into(&self, stmts: &[Stmt], closures: &mut Vec<(u32, Vec<perry_hir::Param>, Vec<Stmt>, Vec<LocalId>, Vec<LocalId>, bool, Option<String>)>, enclosing_class: Option<&str>) {
        for stmt in stmts {
            self.collect_closures_from_stmt(stmt, closures, enclosing_class);
        }
    }

    fn collect_closures_from_stmt(&self, stmt: &Stmt, closures: &mut Vec<(u32, Vec<perry_hir::Param>, Vec<Stmt>, Vec<LocalId>, Vec<LocalId>, bool, Option<String>)>, enclosing_class: Option<&str>) {
        match stmt {
            Stmt::Let { init: Some(expr), .. } => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Stmt::Expr(expr) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Stmt::Return(Some(expr)) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Stmt::If { condition, then_branch, else_branch } => {
                self.collect_closures_from_expr(condition, closures, enclosing_class);
                for s in then_branch {
                    self.collect_closures_from_stmt(s, closures, enclosing_class);
                }
                if let Some(else_stmts) = else_branch {
                    for s in else_stmts {
                        self.collect_closures_from_stmt(s, closures, enclosing_class);
                    }
                }
            }
            Stmt::While { condition, body } => {
                self.collect_closures_from_expr(condition, closures, enclosing_class);
                for s in body {
                    self.collect_closures_from_stmt(s, closures, enclosing_class);
                }
            }
            Stmt::For { init, condition, update, body } => {
                if let Some(init_stmt) = init {
                    self.collect_closures_from_stmt(init_stmt, closures, enclosing_class);
                }
                if let Some(cond) = condition {
                    self.collect_closures_from_expr(cond, closures, enclosing_class);
                }
                if let Some(upd) = update {
                    self.collect_closures_from_expr(upd, closures, enclosing_class);
                }
                for s in body {
                    self.collect_closures_from_stmt(s, closures, enclosing_class);
                }
            }
            Stmt::Throw(expr) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Stmt::Try { body, catch, finally } => {
                for s in body {
                    self.collect_closures_from_stmt(s, closures, enclosing_class);
                }
                if let Some(catch_clause) = catch {
                    for s in &catch_clause.body {
                        self.collect_closures_from_stmt(s, closures, enclosing_class);
                    }
                }
                if let Some(finally_stmts) = finally {
                    for s in finally_stmts {
                        self.collect_closures_from_stmt(s, closures, enclosing_class);
                    }
                }
            }
            Stmt::Switch { discriminant, cases } => {
                self.collect_closures_from_expr(discriminant, closures, enclosing_class);
                for case in cases {
                    // Collect from case test expression (closures may appear in case tests)
                    if let Some(test) = &case.test {
                        self.collect_closures_from_expr(test, closures, enclosing_class);
                    }
                    for s in &case.body {
                        self.collect_closures_from_stmt(s, closures, enclosing_class);
                    }
                }
            }
            _ => {}
        }
    }

    fn collect_closures_from_expr(&self, expr: &Expr, closures: &mut Vec<(u32, Vec<perry_hir::Param>, Vec<Stmt>, Vec<LocalId>, Vec<LocalId>, bool, Option<String>)>, enclosing_class: Option<&str>) {
        match expr {
            Expr::Closure { func_id, params, body, captures, mutable_captures, captures_this, enclosing_class: closure_class, .. } => {
                // Use the enclosing_class stored in the Closure itself (set during lowering)
                // This ensures the class context is preserved even after transformations
                closures.push((*func_id, params.clone(), body.clone(), captures.clone(), mutable_captures.clone(), *captures_this, closure_class.clone()));
                // Also collect nested closures (they inherit the enclosing class from the outer closure)
                let nested_class = closure_class.as_deref().or(enclosing_class);
                for stmt in body {
                    self.collect_closures_from_stmt(stmt, closures, nested_class);
                }
            }
            Expr::Binary { left, right, .. } => {
                self.collect_closures_from_expr(left, closures, enclosing_class);
                self.collect_closures_from_expr(right, closures, enclosing_class);
            }
            Expr::Unary { operand, .. } => {
                self.collect_closures_from_expr(operand, closures, enclosing_class);
            }
            Expr::Call { callee, args, .. } => {
                self.collect_closures_from_expr(callee, closures, enclosing_class);
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::Array(elements) => {
                for elem in elements {
                    self.collect_closures_from_expr(elem, closures, enclosing_class);
                }
            }
            Expr::ArraySpread(elements) => {
                for elem in elements {
                    match elem {
                        ArrayElement::Expr(e) => self.collect_closures_from_expr(e, closures, enclosing_class),
                        ArrayElement::Spread(e) => self.collect_closures_from_expr(e, closures, enclosing_class),
                    }
                }
            }
            Expr::Conditional { condition, then_expr, else_expr } => {
                self.collect_closures_from_expr(condition, closures, enclosing_class);
                self.collect_closures_from_expr(then_expr, closures, enclosing_class);
                self.collect_closures_from_expr(else_expr, closures, enclosing_class);
            }
            Expr::ArrayForEach { array, callback } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(callback, closures, enclosing_class);
            }
            Expr::ArrayMap { array, callback } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(callback, closures, enclosing_class);
            }
            Expr::ArrayFilter { array, callback } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(callback, closures, enclosing_class);
            }
            Expr::ArrayFind { array, callback } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(callback, closures, enclosing_class);
            }
            Expr::ArrayFindIndex { array, callback } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(callback, closures, enclosing_class);
            }
            Expr::ArrayReduce { array, callback, initial } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(callback, closures, enclosing_class);
                if let Some(init) = initial {
                    self.collect_closures_from_expr(init, closures, enclosing_class);
                }
            }
            Expr::ArrayJoin { array, separator } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                if let Some(sep) = separator {
                    self.collect_closures_from_expr(sep, closures, enclosing_class);
                }
            }
            Expr::NativeMethodCall { object, args, .. } => {
                // Collect closures from object (if present)
                if let Some(obj) = object {
                    self.collect_closures_from_expr(obj, closures, enclosing_class);
                }
                // Collect closures from arguments (important for callbacks)
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            // JS interop expressions that may contain closures
            Expr::JsCallFunction { module_handle, args, .. } => {
                self.collect_closures_from_expr(module_handle, closures, enclosing_class);
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::JsCallMethod { object, args, .. } => {
                self.collect_closures_from_expr(object, closures, enclosing_class);
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::JsGetExport { module_handle, .. } => {
                self.collect_closures_from_expr(module_handle, closures, enclosing_class);
            }
            Expr::JsGetProperty { object, .. } => {
                self.collect_closures_from_expr(object, closures, enclosing_class);
            }
            Expr::JsSetProperty { object, value, .. } => {
                self.collect_closures_from_expr(object, closures, enclosing_class);
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::JsNew { module_handle, args, .. } => {
                self.collect_closures_from_expr(module_handle, closures, enclosing_class);
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::JsNewFromHandle { constructor, args } => {
                self.collect_closures_from_expr(constructor, closures, enclosing_class);
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::JsCreateCallback { closure, .. } => {
                // This is the critical case - we need to collect the closure inside JsCreateCallback
                self.collect_closures_from_expr(closure, closures, enclosing_class);
            }
            Expr::PropertyGet { object, .. } => {
                self.collect_closures_from_expr(object, closures, enclosing_class);
            }
            Expr::PropertySet { object, value, .. } => {
                self.collect_closures_from_expr(object, closures, enclosing_class);
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::IndexGet { object, index } => {
                self.collect_closures_from_expr(object, closures, enclosing_class);
                self.collect_closures_from_expr(index, closures, enclosing_class);
            }
            Expr::IndexSet { object, index, value } => {
                self.collect_closures_from_expr(object, closures, enclosing_class);
                self.collect_closures_from_expr(index, closures, enclosing_class);
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::Await(inner) => {
                self.collect_closures_from_expr(inner, closures, enclosing_class);
            }
            Expr::Conditional { condition, then_expr, else_expr } => {
                self.collect_closures_from_expr(condition, closures, enclosing_class);
                self.collect_closures_from_expr(then_expr, closures, enclosing_class);
                self.collect_closures_from_expr(else_expr, closures, enclosing_class);
            }
            Expr::Logical { left, right, .. } => {
                self.collect_closures_from_expr(left, closures, enclosing_class);
                self.collect_closures_from_expr(right, closures, enclosing_class);
            }
            Expr::Compare { left, right, .. } => {
                self.collect_closures_from_expr(left, closures, enclosing_class);
                self.collect_closures_from_expr(right, closures, enclosing_class);
            }
            Expr::New { args, .. } => {
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::NewDynamic { callee, args } => {
                self.collect_closures_from_expr(callee, closures, enclosing_class);
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::Object(fields) => {
                for (_, val) in fields {
                    self.collect_closures_from_expr(val, closures, enclosing_class);
                }
            }
            Expr::LocalSet(_, expr) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Expr::GlobalSet(_, expr) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Expr::CallSpread { callee, args, .. } => {
                self.collect_closures_from_expr(callee, closures, enclosing_class);
                for arg in args {
                    match arg {
                        CallArg::Expr(e) => self.collect_closures_from_expr(e, closures, enclosing_class),
                        CallArg::Spread(e) => self.collect_closures_from_expr(e, closures, enclosing_class),
                    }
                }
            }
            Expr::TypeOf(expr) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Expr::InstanceOf { expr, .. } => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Expr::In { property, object } => {
                self.collect_closures_from_expr(property, closures, enclosing_class);
                self.collect_closures_from_expr(object, closures, enclosing_class);
            }
            Expr::StaticFieldSet { value, .. } => {
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::StaticMethodCall { args, .. } => {
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::SuperCall(args) => {
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::SuperMethodCall { args, .. } => {
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::Sequence(exprs) => {
                for e in exprs {
                    self.collect_closures_from_expr(e, closures, enclosing_class);
                }
            }
            Expr::NetCreateServer { options, connection_listener } => {
                if let Some(opts) = options {
                    self.collect_closures_from_expr(opts, closures, enclosing_class);
                }
                if let Some(listener) = connection_listener {
                    self.collect_closures_from_expr(listener, closures, enclosing_class);
                }
            }
            Expr::NetCreateConnection { port, host, connect_listener } | Expr::NetConnect { port, host, connect_listener } => {
                self.collect_closures_from_expr(port, closures, enclosing_class);
                if let Some(h) = host {
                    self.collect_closures_from_expr(h, closures, enclosing_class);
                }
                if let Some(listener) = connect_listener {
                    self.collect_closures_from_expr(listener, closures, enclosing_class);
                }
            }
            Expr::ChildProcessExec { command, options, callback } => {
                self.collect_closures_from_expr(command, closures, enclosing_class);
                if let Some(opts) = options {
                    self.collect_closures_from_expr(opts, closures, enclosing_class);
                }
                if let Some(cb) = callback {
                    self.collect_closures_from_expr(cb, closures, enclosing_class);
                }
            }
            Expr::Delete(expr) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            Expr::PropertyUpdate { object, .. } => {
                self.collect_closures_from_expr(object, closures, enclosing_class);
            }
            // Additional expressions that may contain closures
            Expr::FetchWithOptions { url, method, body, headers } => {
                self.collect_closures_from_expr(url, closures, enclosing_class);
                self.collect_closures_from_expr(method, closures, enclosing_class);
                self.collect_closures_from_expr(body, closures, enclosing_class);
                for (_, header_val) in headers {
                    self.collect_closures_from_expr(header_val, closures, enclosing_class);
                }
            }
            Expr::MathMin(args) | Expr::MathMax(args) => {
                for arg in args {
                    self.collect_closures_from_expr(arg, closures, enclosing_class);
                }
            }
            Expr::MathPow(base, exp) => {
                self.collect_closures_from_expr(base, closures, enclosing_class);
                self.collect_closures_from_expr(exp, closures, enclosing_class);
            }
            Expr::ArraySplice { start, delete_count, items, .. } => {
                self.collect_closures_from_expr(start, closures, enclosing_class);
                if let Some(dc) = delete_count {
                    self.collect_closures_from_expr(dc, closures, enclosing_class);
                }
                for item in items {
                    self.collect_closures_from_expr(item, closures, enclosing_class);
                }
            }
            Expr::ArraySlice { array, start, end } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(start, closures, enclosing_class);
                if let Some(e) = end {
                    self.collect_closures_from_expr(e, closures, enclosing_class);
                }
            }
            Expr::ArrayIndexOf { array, value } | Expr::ArrayIncludes { array, value } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::ArrayPush { value, .. } | Expr::ArrayUnshift { value, .. } => {
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::MapSet { map, key, value } => {
                self.collect_closures_from_expr(map, closures, enclosing_class);
                self.collect_closures_from_expr(key, closures, enclosing_class);
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::MapGet { map, key } | Expr::MapHas { map, key } | Expr::MapDelete { map, key } => {
                self.collect_closures_from_expr(map, closures, enclosing_class);
                self.collect_closures_from_expr(key, closures, enclosing_class);
            }
            Expr::SetAdd { value, .. } => {
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::SetHas { set, value } | Expr::SetDelete { set, value } => {
                self.collect_closures_from_expr(set, closures, enclosing_class);
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            Expr::StringSplit(string, delimiter) => {
                self.collect_closures_from_expr(string, closures, enclosing_class);
                self.collect_closures_from_expr(delimiter, closures, enclosing_class);
            }
            Expr::RegExpTest { regex, string } => {
                self.collect_closures_from_expr(regex, closures, enclosing_class);
                self.collect_closures_from_expr(string, closures, enclosing_class);
            }
            Expr::ParseInt { string, radix } => {
                self.collect_closures_from_expr(string, closures, enclosing_class);
                if let Some(r) = radix {
                    self.collect_closures_from_expr(r, closures, enclosing_class);
                }
            }
            Expr::BufferFrom { data, encoding } => {
                self.collect_closures_from_expr(data, closures, enclosing_class);
                if let Some(enc) = encoding {
                    self.collect_closures_from_expr(enc, closures, enclosing_class);
                }
            }
            Expr::BufferAlloc { size, fill } => {
                self.collect_closures_from_expr(size, closures, enclosing_class);
                if let Some(f) = fill {
                    self.collect_closures_from_expr(f, closures, enclosing_class);
                }
            }
            Expr::ChildProcessExecSync { command, options } => {
                self.collect_closures_from_expr(command, closures, enclosing_class);
                if let Some(opts) = options {
                    self.collect_closures_from_expr(opts, closures, enclosing_class);
                }
            }
            Expr::ChildProcessSpawnSync { command, args, options } => {
                self.collect_closures_from_expr(command, closures, enclosing_class);
                if let Some(a) = args {
                    self.collect_closures_from_expr(a, closures, enclosing_class);
                }
                if let Some(opts) = options {
                    self.collect_closures_from_expr(opts, closures, enclosing_class);
                }
            }
            Expr::ChildProcessSpawn { command, args, options } => {
                self.collect_closures_from_expr(command, closures, enclosing_class);
                if let Some(a) = args {
                    self.collect_closures_from_expr(a, closures, enclosing_class);
                }
                if let Some(opts) = options {
                    self.collect_closures_from_expr(opts, closures, enclosing_class);
                }
            }
            Expr::UrlNew { url, base } => {
                self.collect_closures_from_expr(url, closures, enclosing_class);
                if let Some(b) = base {
                    self.collect_closures_from_expr(b, closures, enclosing_class);
                }
            }
            Expr::UrlSearchParamsGet { params, name } | Expr::UrlSearchParamsHas { params, name } |
            Expr::UrlSearchParamsDelete { params, name } | Expr::UrlSearchParamsGetAll { params, name } => {
                self.collect_closures_from_expr(params, closures, enclosing_class);
                self.collect_closures_from_expr(name, closures, enclosing_class);
            }
            Expr::UrlSearchParamsSet { params, name, value } | Expr::UrlSearchParamsAppend { params, name, value } => {
                self.collect_closures_from_expr(params, closures, enclosing_class);
                self.collect_closures_from_expr(name, closures, enclosing_class);
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            // File system operations
            Expr::FsReadFileSync(path) | Expr::FsExistsSync(path) | Expr::FsMkdirSync(path) | Expr::FsUnlinkSync(path) => {
                self.collect_closures_from_expr(path, closures, enclosing_class);
            }
            // Dynamic environment variable access
            Expr::EnvGetDynamic(key_expr) => {
                self.collect_closures_from_expr(key_expr, closures, enclosing_class);
            }
            Expr::FsWriteFileSync(path, content) | Expr::FsAppendFileSync(path, content) => {
                self.collect_closures_from_expr(path, closures, enclosing_class);
                self.collect_closures_from_expr(content, closures, enclosing_class);
            }
            // Path operations
            Expr::PathJoin(a, b) => {
                self.collect_closures_from_expr(a, closures, enclosing_class);
                self.collect_closures_from_expr(b, closures, enclosing_class);
            }
            Expr::PathDirname(path) | Expr::PathBasename(path) | Expr::PathExtname(path) | Expr::PathResolve(path) => {
                self.collect_closures_from_expr(path, closures, enclosing_class);
            }
            // JSON operations
            Expr::JsonParse(expr) | Expr::JsonStringify(expr) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            // Math operations
            Expr::MathFloor(expr) | Expr::MathCeil(expr) | Expr::MathRound(expr) |
            Expr::MathAbs(expr) | Expr::MathSqrt(expr) => {
                self.collect_closures_from_expr(expr, closures, enclosing_class);
            }
            // Crypto operations
            Expr::CryptoRandomBytes(inner) | Expr::CryptoSha256(inner) | Expr::CryptoMd5(inner) => {
                self.collect_closures_from_expr(inner, closures, enclosing_class);
            }
            // Buffer operations
            Expr::BufferAllocUnsafe(inner) | Expr::BufferConcat(inner) | Expr::BufferIsBuffer(inner) |
            Expr::BufferByteLength(inner) | Expr::BufferLength(inner) => {
                self.collect_closures_from_expr(inner, closures, enclosing_class);
            }
            Expr::BufferToString { buffer, encoding } => {
                self.collect_closures_from_expr(buffer, closures, enclosing_class);
                if let Some(enc) = encoding {
                    self.collect_closures_from_expr(enc, closures, enclosing_class);
                }
            }
            Expr::BufferSlice { buffer, start, end } => {
                self.collect_closures_from_expr(buffer, closures, enclosing_class);
                if let Some(s) = start {
                    self.collect_closures_from_expr(s, closures, enclosing_class);
                }
                if let Some(e) = end {
                    self.collect_closures_from_expr(e, closures, enclosing_class);
                }
            }
            Expr::BufferCopy { source, target, target_start, source_start, source_end } => {
                self.collect_closures_from_expr(source, closures, enclosing_class);
                self.collect_closures_from_expr(target, closures, enclosing_class);
                if let Some(ts) = target_start {
                    self.collect_closures_from_expr(ts, closures, enclosing_class);
                }
                if let Some(ss) = source_start {
                    self.collect_closures_from_expr(ss, closures, enclosing_class);
                }
                if let Some(se) = source_end {
                    self.collect_closures_from_expr(se, closures, enclosing_class);
                }
            }
            Expr::BufferWrite { buffer, string, offset, encoding } => {
                self.collect_closures_from_expr(buffer, closures, enclosing_class);
                self.collect_closures_from_expr(string, closures, enclosing_class);
                if let Some(o) = offset {
                    self.collect_closures_from_expr(o, closures, enclosing_class);
                }
                if let Some(e) = encoding {
                    self.collect_closures_from_expr(e, closures, enclosing_class);
                }
            }
            Expr::BufferEquals { buffer, other } => {
                self.collect_closures_from_expr(buffer, closures, enclosing_class);
                self.collect_closures_from_expr(other, closures, enclosing_class);
            }
            Expr::BufferIndexGet { buffer, index } | Expr::BufferIndexSet { buffer, index, .. } => {
                self.collect_closures_from_expr(buffer, closures, enclosing_class);
                self.collect_closures_from_expr(index, closures, enclosing_class);
            }
            // Uint8Array operations
            Expr::Uint8ArrayNew(Some(arg)) | Expr::Uint8ArrayFrom(arg) | Expr::Uint8ArrayLength(arg) => {
                self.collect_closures_from_expr(arg, closures, enclosing_class);
            }
            Expr::Uint8ArrayGet { array, index } | Expr::Uint8ArraySet { array, index, .. } => {
                self.collect_closures_from_expr(array, closures, enclosing_class);
                self.collect_closures_from_expr(index, closures, enclosing_class);
            }
            // Map/Set size and clear operations
            Expr::MapSize(map) | Expr::MapClear(map) => {
                self.collect_closures_from_expr(map, closures, enclosing_class);
            }
            Expr::SetSize(set) | Expr::SetClear(set) => {
                self.collect_closures_from_expr(set, closures, enclosing_class);
            }
            // Date operations
            Expr::DateNew(Some(arg)) => {
                self.collect_closures_from_expr(arg, closures, enclosing_class);
            }
            Expr::DateGetTime(date) | Expr::DateToISOString(date) | Expr::DateGetFullYear(date) |
            Expr::DateGetMonth(date) | Expr::DateGetDate(date) | Expr::DateGetHours(date) |
            Expr::DateGetMinutes(date) | Expr::DateGetSeconds(date) | Expr::DateGetMilliseconds(date) => {
                self.collect_closures_from_expr(date, closures, enclosing_class);
            }
            // Error operations
            Expr::ErrorNew(Some(msg)) => {
                self.collect_closures_from_expr(msg, closures, enclosing_class);
            }
            Expr::ErrorMessage(err) => {
                self.collect_closures_from_expr(err, closures, enclosing_class);
            }
            // URL getter operations
            Expr::UrlGetHref(url) | Expr::UrlGetPathname(url) | Expr::UrlGetProtocol(url) |
            Expr::UrlGetHost(url) | Expr::UrlGetHostname(url) | Expr::UrlGetPort(url) |
            Expr::UrlGetSearch(url) | Expr::UrlGetHash(url) | Expr::UrlGetOrigin(url) |
            Expr::UrlGetSearchParams(url) => {
                self.collect_closures_from_expr(url, closures, enclosing_class);
            }
            Expr::UrlSearchParamsNew(Some(init)) => {
                self.collect_closures_from_expr(init, closures, enclosing_class);
            }
            Expr::UrlSearchParamsToString(params) => {
                self.collect_closures_from_expr(params, closures, enclosing_class);
            }
            // String operations
            Expr::StringMatch { string, regex } => {
                self.collect_closures_from_expr(string, closures, enclosing_class);
                self.collect_closures_from_expr(regex, closures, enclosing_class);
            }
            Expr::StringReplace { string, pattern, replacement } => {
                self.collect_closures_from_expr(string, closures, enclosing_class);
                self.collect_closures_from_expr(pattern, closures, enclosing_class);
                self.collect_closures_from_expr(replacement, closures, enclosing_class);
            }
            // Object operations
            Expr::ObjectKeys(obj) | Expr::ObjectValues(obj) | Expr::ObjectEntries(obj) => {
                self.collect_closures_from_expr(obj, closures, enclosing_class);
            }
            // Array static methods
            Expr::ArrayIsArray(value) => {
                self.collect_closures_from_expr(value, closures, enclosing_class);
            }
            // Global functions
            Expr::ParseFloat(s) | Expr::NumberCoerce(s) | Expr::StringCoerce(s) |
            Expr::IsNaN(s) | Expr::IsFinite(s) => {
                self.collect_closures_from_expr(s, closures, enclosing_class);
            }
            // Expressions with no inner expressions to traverse
            Expr::Undefined | Expr::Null | Expr::Bool(_) | Expr::Number(_) | Expr::Integer(_) |
            Expr::BigInt(_) | Expr::String(_) | Expr::LocalGet(_) | Expr::GlobalGet(_) |
            Expr::Update { .. } | Expr::FuncRef(_) | Expr::ExternFuncRef { .. } |
            Expr::NativeModuleRef(_) | Expr::StaticFieldGet { .. } | Expr::This |
            Expr::EnumMember { .. } | Expr::ClassRef(_) | Expr::EnvGet(_) |
            Expr::ProcessUptime | Expr::ProcessCwd | Expr::ProcessArgv |
            Expr::MathRandom | Expr::CryptoRandomUUID |
            Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
            Expr::OsTmpdir | Expr::OsTotalmem | Expr::OsFreemem | Expr::OsUptime |
            Expr::OsType | Expr::OsRelease | Expr::OsCpus | Expr::OsNetworkInterfaces |
            Expr::OsUserInfo | Expr::OsEOL |
            Expr::MapNew | Expr::SetNew | Expr::DateNow |
            Expr::ArrayPop(_) | Expr::ArrayShift(_) |
            Expr::Uint8ArrayNew(None) | Expr::DateNew(None) | Expr::ErrorNew(None) |
            Expr::UrlSearchParamsNew(None) |
            Expr::RegExp { .. } | Expr::JsLoadModule { .. } | Expr::ImportMetaUrl(_) => {
                // No inner expressions to traverse
            }
        }
    }

    /// Collect all mutable captures from closures in the given statements.
    /// Returns a set of LocalIds that need to be boxed at declaration time.
    fn collect_mutable_captures_from_stmts(&self, stmts: &[Stmt]) -> std::collections::HashSet<LocalId> {
        let mut mutable_captures: std::collections::HashSet<LocalId> = std::collections::HashSet::new();
        for stmt in stmts {
            self.collect_mutable_captures_from_stmt(stmt, &mut mutable_captures);
        }
        mutable_captures
    }

    fn collect_mutable_captures_from_stmt(&self, stmt: &Stmt, captures: &mut std::collections::HashSet<LocalId>) {
        match stmt {
            Stmt::Let { init: Some(expr), .. } => {
                self.collect_mutable_captures_from_expr(expr, captures);
            }
            Stmt::Expr(expr) => {
                self.collect_mutable_captures_from_expr(expr, captures);
            }
            Stmt::Return(Some(expr)) => {
                self.collect_mutable_captures_from_expr(expr, captures);
            }
            Stmt::If { condition, then_branch, else_branch } => {
                self.collect_mutable_captures_from_expr(condition, captures);
                for s in then_branch {
                    self.collect_mutable_captures_from_stmt(s, captures);
                }
                if let Some(else_stmts) = else_branch {
                    for s in else_stmts {
                        self.collect_mutable_captures_from_stmt(s, captures);
                    }
                }
            }
            Stmt::While { condition, body } => {
                self.collect_mutable_captures_from_expr(condition, captures);
                for s in body {
                    self.collect_mutable_captures_from_stmt(s, captures);
                }
            }
            Stmt::For { init, condition, update, body } => {
                if let Some(init_stmt) = init {
                    self.collect_mutable_captures_from_stmt(init_stmt, captures);
                }
                if let Some(cond) = condition {
                    self.collect_mutable_captures_from_expr(cond, captures);
                }
                if let Some(upd) = update {
                    self.collect_mutable_captures_from_expr(upd, captures);
                }
                for s in body {
                    self.collect_mutable_captures_from_stmt(s, captures);
                }
            }
            Stmt::Try { body, catch, finally } => {
                for s in body {
                    self.collect_mutable_captures_from_stmt(s, captures);
                }
                if let Some(catch_clause) = catch {
                    for s in &catch_clause.body {
                        self.collect_mutable_captures_from_stmt(s, captures);
                    }
                }
                if let Some(finally_stmts) = finally {
                    for s in finally_stmts {
                        self.collect_mutable_captures_from_stmt(s, captures);
                    }
                }
            }
            Stmt::Switch { discriminant, cases } => {
                self.collect_mutable_captures_from_expr(discriminant, captures);
                for case in cases {
                    for s in &case.body {
                        self.collect_mutable_captures_from_stmt(s, captures);
                    }
                }
            }
            _ => {}
        }
    }

    fn collect_mutable_captures_from_expr(&self, expr: &Expr, captures: &mut std::collections::HashSet<LocalId>) {
        match expr {
            Expr::Closure { mutable_captures, body, .. } => {
                // Add all mutable captures to the set
                for id in mutable_captures {
                    captures.insert(*id);
                }
                // Also collect from nested closures in the body
                for stmt in body {
                    self.collect_mutable_captures_from_stmt(stmt, captures);
                }
            }
            Expr::Binary { left, right, .. } => {
                self.collect_mutable_captures_from_expr(left, captures);
                self.collect_mutable_captures_from_expr(right, captures);
            }
            Expr::Unary { operand, .. } => {
                self.collect_mutable_captures_from_expr(operand, captures);
            }
            Expr::Call { callee, args, .. } => {
                self.collect_mutable_captures_from_expr(callee, captures);
                for arg in args {
                    self.collect_mutable_captures_from_expr(arg, captures);
                }
            }
            Expr::Array(elements) => {
                for elem in elements {
                    self.collect_mutable_captures_from_expr(elem, captures);
                }
            }
            Expr::ArraySpread(elements) => {
                for elem in elements {
                    match elem {
                        ArrayElement::Expr(e) => self.collect_mutable_captures_from_expr(e, captures),
                        ArrayElement::Spread(e) => self.collect_mutable_captures_from_expr(e, captures),
                    }
                }
            }
            Expr::Conditional { condition, then_expr, else_expr } => {
                self.collect_mutable_captures_from_expr(condition, captures);
                self.collect_mutable_captures_from_expr(then_expr, captures);
                self.collect_mutable_captures_from_expr(else_expr, captures);
            }
            Expr::ArrayForEach { array, callback } => {
                self.collect_mutable_captures_from_expr(array, captures);
                self.collect_mutable_captures_from_expr(callback, captures);
            }
            Expr::ArrayMap { array, callback } => {
                self.collect_mutable_captures_from_expr(array, captures);
                self.collect_mutable_captures_from_expr(callback, captures);
            }
            Expr::ArrayFilter { array, callback } => {
                self.collect_mutable_captures_from_expr(array, captures);
                self.collect_mutable_captures_from_expr(callback, captures);
            }
            Expr::ArrayFind { array, callback } => {
                self.collect_mutable_captures_from_expr(array, captures);
                self.collect_mutable_captures_from_expr(callback, captures);
            }
            Expr::ArrayFindIndex { array, callback } => {
                self.collect_mutable_captures_from_expr(array, captures);
                self.collect_mutable_captures_from_expr(callback, captures);
            }
            Expr::ArrayReduce { array, callback, initial } => {
                self.collect_mutable_captures_from_expr(array, captures);
                self.collect_mutable_captures_from_expr(callback, captures);
                if let Some(init) = initial {
                    self.collect_mutable_captures_from_expr(init, captures);
                }
            }
            Expr::ArrayJoin { array, separator } => {
                self.collect_mutable_captures_from_expr(array, captures);
                if let Some(sep) = separator {
                    self.collect_mutable_captures_from_expr(sep, captures);
                }
            }
            Expr::LocalSet(_, val) | Expr::GlobalSet(_, val) => {
                self.collect_mutable_captures_from_expr(val, captures);
            }
            Expr::PropertyGet { object, .. } => {
                self.collect_mutable_captures_from_expr(object, captures);
            }
            Expr::PropertySet { object, value, .. } => {
                self.collect_mutable_captures_from_expr(object, captures);
                self.collect_mutable_captures_from_expr(value, captures);
            }
            Expr::IndexGet { object, index } => {
                self.collect_mutable_captures_from_expr(object, captures);
                self.collect_mutable_captures_from_expr(index, captures);
            }
            Expr::IndexSet { object, index, value } => {
                self.collect_mutable_captures_from_expr(object, captures);
                self.collect_mutable_captures_from_expr(index, captures);
                self.collect_mutable_captures_from_expr(value, captures);
            }
            Expr::Object(fields) => {
                for (_, value) in fields {
                    self.collect_mutable_captures_from_expr(value, captures);
                }
            }
            Expr::New { args, .. } => {
                for arg in args {
                    self.collect_mutable_captures_from_expr(arg, captures);
                }
            }
            Expr::NativeMethodCall { object, args, .. } => {
                // Collect from object (if present)
                if let Some(obj) = object {
                    self.collect_mutable_captures_from_expr(obj, captures);
                }
                // Collect from arguments (important for callbacks)
                for arg in args {
                    self.collect_mutable_captures_from_expr(arg, captures);
                }
            }
            // JS interop expressions that may contain closures
            Expr::JsCallFunction { module_handle, args, .. } => {
                self.collect_mutable_captures_from_expr(module_handle, captures);
                for arg in args {
                    self.collect_mutable_captures_from_expr(arg, captures);
                }
            }
            Expr::JsCallMethod { object, args, .. } => {
                self.collect_mutable_captures_from_expr(object, captures);
                for arg in args {
                    self.collect_mutable_captures_from_expr(arg, captures);
                }
            }
            Expr::JsGetExport { module_handle, .. } => {
                self.collect_mutable_captures_from_expr(module_handle, captures);
            }
            Expr::JsGetProperty { object, .. } => {
                self.collect_mutable_captures_from_expr(object, captures);
            }
            Expr::JsSetProperty { object, value, .. } => {
                self.collect_mutable_captures_from_expr(object, captures);
                self.collect_mutable_captures_from_expr(value, captures);
            }
            Expr::JsNew { module_handle, args, .. } => {
                self.collect_mutable_captures_from_expr(module_handle, captures);
                for arg in args {
                    self.collect_mutable_captures_from_expr(arg, captures);
                }
            }
            Expr::JsNewFromHandle { constructor, args } => {
                self.collect_mutable_captures_from_expr(constructor, captures);
                for arg in args {
                    self.collect_mutable_captures_from_expr(arg, captures);
                }
            }
            Expr::JsCreateCallback { closure, .. } => {
                self.collect_mutable_captures_from_expr(closure, captures);
            }
            _ => {}
        }
    }

    /// Collect FuncRef expressions that are used as values (not as call callees)
    /// These need wrapper functions for closure-compatible calling convention
    fn collect_func_refs_needing_wrappers_from_stmts(&self, stmts: &[Stmt], func_refs: &mut std::collections::HashSet<u32>) {
        for stmt in stmts {
            self.collect_func_refs_from_stmt(stmt, func_refs);
        }
    }

    fn collect_func_refs_from_stmt(&self, stmt: &Stmt, func_refs: &mut std::collections::HashSet<u32>) {
        match stmt {
            Stmt::Let { init: Some(expr), .. } => {
                self.collect_func_refs_from_expr(expr, func_refs);
            }
            Stmt::Expr(expr) => {
                self.collect_func_refs_from_expr(expr, func_refs);
            }
            Stmt::Return(Some(expr)) => {
                self.collect_func_refs_from_expr(expr, func_refs);
            }
            Stmt::If { condition, then_branch, else_branch } => {
                self.collect_func_refs_from_expr(condition, func_refs);
                self.collect_func_refs_needing_wrappers_from_stmts(then_branch, func_refs);
                if let Some(else_stmts) = else_branch {
                    self.collect_func_refs_needing_wrappers_from_stmts(else_stmts, func_refs);
                }
            }
            Stmt::While { condition, body } => {
                self.collect_func_refs_from_expr(condition, func_refs);
                self.collect_func_refs_needing_wrappers_from_stmts(body, func_refs);
            }
            Stmt::For { init, condition, update, body } => {
                if let Some(init_stmt) = init {
                    self.collect_func_refs_from_stmt(init_stmt, func_refs);
                }
                if let Some(cond) = condition {
                    self.collect_func_refs_from_expr(cond, func_refs);
                }
                if let Some(upd) = update {
                    self.collect_func_refs_from_expr(upd, func_refs);
                }
                self.collect_func_refs_needing_wrappers_from_stmts(body, func_refs);
            }
            _ => {}
        }
    }

    fn collect_func_refs_from_expr(&self, expr: &Expr, func_refs: &mut std::collections::HashSet<u32>) {
        match expr {
            Expr::Call { callee, args, .. } => {
                // Callee FuncRef is NOT a wrapper candidate (it's being called directly)
                // But we need to check if callee is a complex expression
                if !matches!(callee.as_ref(), Expr::FuncRef(_)) {
                    self.collect_func_refs_from_expr(callee, func_refs);
                }
                // Args that are FuncRefs ARE wrapper candidates
                for arg in args {
                    match arg {
                        Expr::FuncRef(func_id) => {
                            func_refs.insert(*func_id);
                        }
                        _ => self.collect_func_refs_from_expr(arg, func_refs),
                    }
                }
            }
            Expr::Binary { left, right, .. } => {
                self.collect_func_refs_from_expr(left, func_refs);
                self.collect_func_refs_from_expr(right, func_refs);
            }
            Expr::Unary { operand, .. } => {
                self.collect_func_refs_from_expr(operand, func_refs);
            }
            Expr::Array(elements) => {
                for elem in elements {
                    match elem {
                        Expr::FuncRef(func_id) => {
                            func_refs.insert(*func_id);
                        }
                        _ => self.collect_func_refs_from_expr(elem, func_refs),
                    }
                }
            }
            Expr::ArraySpread(elements) => {
                for elem in elements {
                    match elem {
                        ArrayElement::Expr(e) => {
                            if let Expr::FuncRef(func_id) = e {
                                func_refs.insert(*func_id);
                            } else {
                                self.collect_func_refs_from_expr(e, func_refs);
                            }
                        }
                        ArrayElement::Spread(e) => self.collect_func_refs_from_expr(e, func_refs),
                    }
                }
            }
            Expr::Conditional { condition, then_expr, else_expr } => {
                self.collect_func_refs_from_expr(condition, func_refs);
                self.collect_func_refs_from_expr(then_expr, func_refs);
                self.collect_func_refs_from_expr(else_expr, func_refs);
            }
            Expr::Closure { func_id, body, .. } => {
                self.collect_func_refs_needing_wrappers_from_stmts(body, func_refs);
            }
            Expr::ArrayForEach { array, callback } | Expr::ArrayMap { array, callback } | Expr::ArrayFilter { array, callback } | Expr::ArrayFind { array, callback } | Expr::ArrayFindIndex { array, callback } => {
                self.collect_func_refs_from_expr(array, func_refs);
                match callback.as_ref() {
                    Expr::FuncRef(func_id) => {
                        func_refs.insert(*func_id);
                    }
                    _ => self.collect_func_refs_from_expr(callback, func_refs),
                }
            }
            Expr::ArrayReduce { array, callback, initial } => {
                self.collect_func_refs_from_expr(array, func_refs);
                match callback.as_ref() {
                    Expr::FuncRef(func_id) => {
                        func_refs.insert(*func_id);
                    }
                    _ => self.collect_func_refs_from_expr(callback, func_refs),
                }
                if let Some(init) = initial {
                    self.collect_func_refs_from_expr(init, func_refs);
                }
            }
            _ => {}
        }
    }

    /// Declare a closure function
    fn declare_closure(&mut self, func_id: u32, param_count: usize, capture_count: usize) -> Result<()> {
        let mut sig = self.module.make_signature();

        // First parameter is the closure pointer (for accessing captures)
        sig.params.push(AbiParam::new(types::I64));

        // Then the regular parameters (all f64 for now)
        for _ in 0..param_count {
            sig.params.push(AbiParam::new(types::F64));
        }

        // Return type
        sig.returns.push(AbiParam::new(types::F64));

        let func_name = format!("__closure_{}", func_id);
        let clif_func_id = self.module.declare_function(&func_name, Linkage::Local, &sig)?;
        self.closure_func_ids.insert(func_id, clif_func_id);

        Ok(())
    }

    /// Compile a closure function
    fn compile_closure(&mut self, func_id: u32, params: &[perry_hir::Param], body: &[Stmt], captures: &[LocalId], mutable_captures: &[LocalId], captures_this: bool, enclosing_class: Option<&str>) -> Result<()> {
        let clif_func_id = *self.closure_func_ids.get(&func_id)
            .ok_or_else(|| anyhow!("Closure not declared: {}", func_id))?;

        // Set up the function signature
        self.ctx.func.signature.params.clear();
        self.ctx.func.signature.returns.clear();

        // First parameter is closure pointer
        self.ctx.func.signature.params.push(AbiParam::new(types::I64));

        for _ in params {
            self.ctx.func.signature.params.push(AbiParam::new(types::F64));
        }
        self.ctx.func.signature.returns.push(AbiParam::new(types::F64));

        // Build a set of mutable captures for quick lookup
        let mutable_set: std::collections::HashSet<LocalId> = mutable_captures.iter().copied().collect();

        // Collect mutable captures for the closure body (for nested closures) - before borrowing self.ctx
        let boxed_vars = self.collect_mutable_captures_from_stmts(body);

        // Get class metadata if this closure captures `this`
        let class_meta = if captures_this {
            if let Some(class_name) = enclosing_class {
                self.classes.get(class_name).cloned()
            } else {
                None
            }
        } else {
            None
        };

        {
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.append_block_params_for_function_params(entry_block);
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // First param is closure pointer
            let closure_ptr_var = Variable::new(0);
            builder.declare_var(closure_ptr_var, types::I64);
            let closure_ptr = builder.block_params(entry_block)[0];
            builder.def_var(closure_ptr_var, closure_ptr);

            // Create variables for regular parameters
            let mut locals: HashMap<LocalId, LocalInfo> = HashMap::new();
            let mut next_var = 1usize;

            for (i, param) in params.iter().enumerate() {
                let var = Variable::new(next_var);
                next_var += 1;
                // Check parameter type to set appropriate LocalInfo flags
                let is_closure = matches!(param.ty, perry_types::Type::Function(_));
                let is_string = matches!(param.ty, perry_types::Type::String);
                let is_array = matches!(param.ty, perry_types::Type::Array(_));
                // Any/Unknown are union types - they could be numbers, strings, objects, etc.
                // Don't treat them as pointers since we can't extract pointer from plain numbers
                let is_union_type = matches!(param.ty, perry_types::Type::Any | perry_types::Type::Unknown);
                let is_pointer = is_closure || is_string || is_array ||
                    matches!(param.ty, perry_types::Type::Object(_) | perry_types::Type::Named(_));
                // Use i64 for known pointer types, f64 for numbers and union types
                let var_type = if is_pointer && !is_union_type { types::I64 } else { types::F64 };
                builder.declare_var(var, var_type);
                // Parameters come in as f64 (potentially NaN-boxed), extract raw pointer if needed
                let val = builder.block_params(entry_block)[i + 1]; // +1 to skip closure ptr
                let final_val = if is_pointer && !is_union_type {
                    // The f64 may be NaN-boxed (e.g., object from array access)
                    // Extract the raw pointer using js_nanbox_get_pointer
                    let get_ptr_func = self.extern_funcs.get("js_nanbox_get_pointer")
                        .expect("js_nanbox_get_pointer not declared");
                    let get_ptr_ref = self.module.declare_func_in_func(*get_ptr_func, builder.func);
                    let call = builder.ins().call(get_ptr_ref, &[val]);
                    builder.inst_results(call)[0]
                } else {
                    val
                };
                builder.def_var(var, final_val);
                locals.insert(param.id, LocalInfo {
                    var,
                    name: Some(param.name.clone()),
                    class_name: None,
                    type_args: Vec::new(),
                    is_pointer: is_pointer && !is_union_type,
                    is_array,
                    is_string,
                    is_bigint: false,
                    is_closure,
                    is_boxed: false,
                    is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: is_union_type,
                    is_mixed_array: false,
                    is_integer: false,
                    is_integer_array: false,
                    is_i32: false,
                    i32_shadow: None,
                    bounded_by_array: None,
                    bounded_by_constant: None,
                    scalar_fields: None,
                    squared_cache: None, product_cache: None,
                });
            }

            // Load captured variables from the closure object
            // Each capture is stored as f64 in the closure object
            // For mutable captures, the f64 is actually a bitcast of a box pointer
            let get_capture_func = self.extern_funcs.get("js_closure_get_capture_f64")
                .ok_or_else(|| anyhow!("js_closure_get_capture_f64 not declared"))?;
            let get_capture_ref = self.module.declare_func_in_func(*get_capture_func, builder.func);

            // If captures_this, load `this` from capture slot 0 first
            // Then other captures are offset by 1
            let capture_offset = if captures_this { 1 } else { 0 };

            // Variable to hold `this` if captured
            let this_var = if captures_this {
                // Load `this` from capture slot 0
                let idx = builder.ins().iconst(types::I32, 0);
                let call = builder.ins().call(get_capture_ref, &[closure_ptr, idx]);
                let this_f64 = builder.inst_results(call)[0];

                // `this` is stored as f64 (bitcast of i64 pointer), convert back to i64
                let this_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), this_f64);

                // Store in a variable
                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, types::I64);
                builder.def_var(var, this_ptr);

                Some(var)
            } else {
                None
            };

            for (i, capture_id) in captures.iter().enumerate() {
                let is_mutable = mutable_set.contains(capture_id);

                // Load the captured value: js_closure_get_capture_f64(closure_ptr, index)
                // Index is offset by 1 if captures_this (slot 0 is `this`)
                let idx = builder.ins().iconst(types::I32, (i + capture_offset) as i64);
                let call = builder.ins().call(get_capture_ref, &[closure_ptr, idx]);
                let val_f64 = builder.inst_results(call)[0];

                if is_mutable {
                    // For mutable captures, the stored f64 is actually a box pointer
                    // Convert to i64 and store the box pointer
                    let var = Variable::new(next_var);
                    next_var += 1;
                    builder.declare_var(var, types::I64);
                    let box_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val_f64);
                    builder.def_var(var, box_ptr);

                    locals.insert(*capture_id, LocalInfo {
                        var,
                        name: None, // Captures don't have a direct name
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: true,
                        is_array: false,
                        is_string: false,
                        is_bigint: false,
                        is_closure: false,
                        is_boxed: true,
                        is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                        is_mixed_array: false,
                        is_integer: false,
                        is_integer_array: false,
                        is_i32: false,
                        i32_shadow: None,
                        bounded_by_array: None,
                        bounded_by_constant: None,
                        scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    });
                } else {
                    // For immutable captures, store the value directly
                    let var = Variable::new(next_var);
                    next_var += 1;
                    builder.declare_var(var, types::F64);
                    builder.def_var(var, val_f64);

                    locals.insert(*capture_id, LocalInfo {
                        var,
                        name: None, // Captures don't have a direct name
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false,
                        is_array: false,
                        is_string: false,
                        is_bigint: false,
                        is_closure: false,
                        is_boxed: false,
                        is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                        is_mixed_array: false,
                        is_integer: false,
                        is_integer_array: false,
                        is_i32: false,
                        i32_shadow: None,
                        bounded_by_array: None,
                        bounded_by_constant: None,
                        scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    });
                }
            }

            // Load module-level variables from their global slots
            // These are variables defined at module scope that the closure may reference
            for (local_id, data_id) in &self.module_var_data_ids {
                // Skip if already in locals (e.g., passed as a capture)
                if locals.contains_key(local_id) {
                    continue;
                }

                // Get the type info from module_level_locals (populated during compile_init)
                let (var_type, local_info_template) = if let Some(info) = self.module_level_locals.get(local_id) {
                    // Variable is stored as i64 only if is_pointer && !is_union
                    let vt = if info.is_pointer && !info.is_union { types::I64 } else { types::F64 };
                    (vt, info.clone())
                } else {
                    // Fallback to f64 if type info not available
                    (types::F64, LocalInfo {
                        var: Variable::new(0), // Will be overwritten
                        name: None,
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false,
                        is_array: false,
                        is_string: false,
                        is_bigint: false,
                        is_closure: false,
                        is_boxed: false,
                        is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                        is_mixed_array: false,
                        is_integer: false,
                        is_integer_array: false,
                        is_i32: false,
                        i32_shadow: None,
                        bounded_by_array: None,
                        bounded_by_constant: None,
                        scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    })
                };

                let var = Variable::new(next_var);
                next_var += 1;
                builder.declare_var(var, var_type);

                // Load the value from the global data slot
                let global_val = self.module.declare_data_in_func(*data_id, builder.func);
                let ptr = builder.ins().global_value(types::I64, global_val);
                let val = builder.ins().load(var_type, MemFlags::new(), ptr, 0);
                builder.def_var(var, val);

                // Insert into locals so LocalGet can find it
                let mut info = local_info_template;
                info.var = var;
                locals.insert(*local_id, info);
            }

            // Create ThisContext if we captured `this`
            let this_ctx = if let (Some(var), Some(meta)) = (this_var, class_meta.clone()) {
                Some(ThisContext {
                    this_var: var,
                    class_meta: meta,
                })
            } else {
                None
            };

            // Compile the body
            for stmt in body {
                compile_stmt(
                    &mut builder,
                    &mut self.module,
                    &self.func_ids,
                    &self.closure_func_ids,
                    &self.func_wrapper_ids,
                    &self.extern_funcs,
                    &self.async_func_ids,
                    &self.closure_returning_funcs,
                    &self.classes,
                    &self.enums,
                    &self.func_param_types,
                    &self.func_union_params,
                    &self.func_return_types,
                    &self.func_hir_return_types,
                    &self.func_rest_param_index,
                    &self.imported_func_param_counts,
                    &mut locals,
                    &mut next_var,
                    stmt,
                    this_ctx.as_ref(),
                    None,
                    &boxed_vars,
                )?;
            }

            // If no explicit return, return 0 with correct type
            let current_block = builder.current_block().unwrap();
            if !is_block_filled(&builder, current_block) {
                let ret_type = builder.func.signature.returns.first().map(|p| p.value_type).unwrap_or(types::F64);
                let zero = match ret_type {
                    types::I64 => builder.ins().iconst(types::I64, 0),
                    types::I32 => builder.ins().iconst(types::I32, 0),
                    _ => builder.ins().f64const(0.0),
                };
                builder.ins().return_(&[zero]);
            }

            builder.finalize();
        }

        self.module.define_function(clif_func_id, &mut self.ctx)
            .map_err(|e| anyhow!("Error compiling closure_{} with {} params: {:?}", func_id, params.len(), e))?;
        self.module.clear_context(&mut self.ctx);

        Ok(())
    }

    /// Get or create a closure-compatible wrapper for a named function
    /// This is needed when passing a named function as a callback argument
    fn get_or_create_func_wrapper(&mut self, func_id: u32) -> Result<cranelift_module::FuncId> {
        // Check if we already have a wrapper
        if let Some(&wrapper_id) = self.func_wrapper_ids.get(&func_id) {
            return Ok(wrapper_id);
        }

        // Find the original function in HIR
        let func = self.hir_functions.iter()
            .find(|f| f.id == func_id)
            .ok_or_else(|| anyhow!("Function not found for wrapper generation: {}", func_id))?
            .clone();

        // Create wrapper function signature: (closure_ptr, ...args) -> result
        // For exported functions, always return f64 to provide uniform ABI for cross-module calls
        // For local wrappers, use the original return type
        let mut sig = self.module.make_signature();
        sig.params.push(AbiParam::new(types::I64)); // closure_ptr (ignored)
        for _param in &func.params {
            sig.params.push(AbiParam::new(types::F64)); // all args as f64 for now
        }
        // Determine return type: for exported functions, always f64; for local, use actual type
        let original_return_abi = if func.is_async {
            types::I64 // async functions return Promise pointer
        } else {
            self.type_to_abi(&func.return_type)
        };
        // Exported wrappers always return f64 for uniform cross-module ABI
        let return_abi = if func.is_exported { types::F64 } else { original_return_abi };
        sig.returns.push(AbiParam::new(return_abi));

        let wrapper_name = format!("__wrapper_{}", func.name);
        // Use Export linkage for exported functions so other modules can call the wrapper
        let linkage = if func.is_exported { Linkage::Export } else { Linkage::Local };
        let wrapper_id = self.module.declare_function(&wrapper_name, linkage, &sig)?;
        // Track whether we need to NaN-box the return value and if it's a string
        let needs_return_boxing = func.is_exported && original_return_abi == types::I64;
        let is_string_return = matches!(func.return_type, perry_types::Type::String);

        // Pre-compute expected types for each parameter before borrowing self.ctx
        let param_expected_types: Vec<types::Type> = func.params.iter()
            .map(|p| self.type_to_abi(&p.ty))
            .collect();

        // Get original function id before borrowing self.ctx
        let original_func_id = *self.func_ids.get(&func_id)
            .ok_or_else(|| anyhow!("Original function not found: {}", func_id))?;

        // Get js_nanbox_get_pointer for extracting pointers from NaN-boxed values
        let nanbox_get_ptr_id = self.extern_funcs.get("js_nanbox_get_pointer").copied();

        // Compile the wrapper function
        self.ctx.func.signature = sig;

        {
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.append_block_params_for_function_params(entry_block);
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // Skip the closure_ptr (param 0) and forward the rest to the original function
            // Need to convert f64 wrapper params to the types the original function expects
            // For cross-module calls, i64 params are now properly NaN-boxed, so we need to
            // extract the pointer using js_nanbox_get_pointer instead of simple bitcast.
            // Copy block params to a Vec first to avoid borrow conflict
            let block_params: Vec<Value> = builder.block_params(entry_block).to_vec();
            let mut call_args: Vec<Value> = Vec::new();
            for (i, expected_type) in param_expected_types.iter().enumerate() {
                let wrapper_param = block_params[i + 1]; // +1 to skip closure_ptr
                if *expected_type == types::I64 {
                    // Original function expects i64, wrapper has f64 (NaN-boxed pointer)
                    // Use js_nanbox_get_pointer to properly extract the pointer
                    if let Some(get_ptr_id) = nanbox_get_ptr_id {
                        let get_ptr_ref = self.module.declare_func_in_func(get_ptr_id, builder.func);
                        let call = builder.ins().call(get_ptr_ref, &[wrapper_param]);
                        call_args.push(builder.inst_results(call)[0]);
                    } else {
                        // Fallback to bitcast if js_nanbox_get_pointer not available
                        let converted = builder.ins().bitcast(types::I64, MemFlags::new(), wrapper_param);
                        call_args.push(converted);
                    }
                } else {
                    // Same type (f64), pass directly
                    call_args.push(wrapper_param);
                }
            }

            // Call the original function
            let func_ref = self.module.declare_func_in_func(original_func_id, builder.func);

            // Get expected parameter count from the actual function signature
            let actual_sig = self.module.declarations().get_function_decl(original_func_id);
            let expected_param_count = actual_sig.signature.params.len();

            // First, ensure all arguments match the expected types
            let mut final_call_args: Vec<Value> = call_args.iter().enumerate()
                .map(|(i, &val)| {
                    if i < actual_sig.signature.params.len() {
                        let expected_type = actual_sig.signature.params[i].value_type;
                        let actual_type = builder.func.dfg.value_type(val);
                        if expected_type == types::I64 && actual_type == types::F64 {
                            builder.ins().bitcast(types::I64, MemFlags::new(), val)
                        } else if expected_type == types::F64 && actual_type == types::I64 {
                            builder.ins().bitcast(types::F64, MemFlags::new(), val)
                        } else {
                            val
                        }
                    } else {
                        val
                    }
                })
                .collect();

            // Pad arguments if needed (for optional parameters), using correct types
            while final_call_args.len() < expected_param_count {
                let expected_type = actual_sig.signature.params[final_call_args.len()].value_type;
                if expected_type == types::I64 {
                    final_call_args.push(builder.ins().iconst(types::I64, 0));
                } else {
                    final_call_args.push(builder.ins().f64const(f64::NAN));
                }
            }
            final_call_args.truncate(expected_param_count);

            let call = builder.ins().call(func_ref, &final_call_args);
            let result = builder.inst_results(call)[0];

            // For exported wrappers returning i64 (pointers), NaN-box to f64 for uniform ABI
            let final_result = if needs_return_boxing {
                // Use js_nanbox_string for string returns, js_nanbox_pointer for others
                let nanbox_func_name = if is_string_return { "js_nanbox_string" } else { "js_nanbox_pointer" };
                let nanbox_func_id = self.extern_funcs.get(nanbox_func_name)
                    .ok_or_else(|| anyhow!("{} not declared", nanbox_func_name))?;
                let nanbox_ref = self.module.declare_func_in_func(*nanbox_func_id, builder.func);
                let nanbox_call = builder.ins().call(nanbox_ref, &[result]);
                builder.inst_results(nanbox_call)[0]
            } else {
                result
            };

            builder.ins().return_(&[final_result]);
            builder.finalize();
        }

        self.module.define_function(wrapper_id, &mut self.ctx)?;
        self.module.clear_context(&mut self.ctx);

        self.func_wrapper_ids.insert(func_id, wrapper_id);
        Ok(wrapper_id)
    }

    fn compile_init(&mut self, module_name: &str, stmts: &[Stmt], exported_native_instances: &[(String, String, String)], exported_objects: &[String], exported_functions: &[(String, u32)]) -> Result<()> {
        // Create main function for init statements (entry module) or module init function (non-entry)
        let mut sig = self.module.make_signature();
        sig.returns.push(AbiParam::new(types::I32)); // returns i32

        let func_id = if self.is_entry_module {
            // Entry module: generate "main"
            match self.module.declare_function("main", Linkage::Export, &sig) {
                Ok(id) => id,
                Err(_) => {
                    // "main" already exists (likely user function with different signature)
                    // Use alternative name for the entry point
                    self.module.declare_function("_perry_main", Linkage::Export, &sig)?
                }
            }
        } else {
            // Non-entry module: generate "_perry_init_<module_name>" with export linkage
            // This function will be called by the entry module's main
            let sanitized_name = module_name.replace(|c: char| !c.is_alphanumeric() && c != '_', "_");
            let func_name = format!("_perry_init_{}", sanitized_name);
            self.module.declare_function(&func_name, Linkage::Export, &sig)?
        };

        self.ctx.func.signature = sig;

        // Collect all variables that will be mutably captured by closures (before borrowing self.ctx)
        let boxed_vars = self.collect_mutable_captures_from_stmts(stmts);

        // Check if we need to call js_runtime_init
        let needs_js_runtime = self.needs_js_runtime;
        let js_runtime_init_id = if needs_js_runtime {
            self.extern_funcs.get("js_runtime_init").copied()
        } else {
            None
        };

        // Collect exported native instance names for post-processing
        let exported_native_names: HashSet<String> = exported_native_instances.iter()
            .map(|(name, _, _)| name.clone())
            .collect();
        let exported_object_names: HashSet<String> = exported_objects.iter().cloned().collect();
        // Combine all exported names
        let exported_names: HashSet<String> = exported_native_names.iter()
            .chain(exported_object_names.iter())
            .cloned()
            .collect();

        // Collect exported function info for initializing their globals
        // Each entry is (func_name, data_id, wrapper_or_func_id)
        let exported_func_info: Vec<(String, cranelift_module::DataId, cranelift_module::FuncId)> = exported_functions
            .iter()
            .filter_map(|(func_name, hir_func_id)| {
                // Get the data ID for this exported function
                let (data_id, _) = self.exported_function_ids.get(func_name)?;
                // Get the wrapper function ID if it exists, otherwise the direct function ID
                let func_id = self.func_wrapper_ids.get(hir_func_id)
                    .copied()
                    .or_else(|| self.func_ids.get(hir_func_id).copied())?;
                Some((func_name.clone(), *data_id, func_id))
            })
            .collect();

        // Get js_closure_alloc function ID if we have exported functions
        let closure_alloc_id = if !exported_func_info.is_empty() {
            self.extern_funcs.get("js_closure_alloc").copied()
        } else {
            None
        };

        {
            let mut builder = FunctionBuilder::new(&mut self.ctx.func, &mut self.func_ctx);

            let entry_block = builder.create_block();
            builder.switch_to_block(entry_block);
            builder.seal_block(entry_block);

            // Initialize JS runtime at the start of main() if needed
            if let Some(init_func_id) = js_runtime_init_id {
                let init_func_ref = self.module.declare_func_in_func(init_func_id, builder.func);
                builder.ins().call(init_func_ref, &[]);
            }

            // Call imported native module init functions (for entry module only)
            // This ensures exports from other modules are initialized before we use them
            if self.is_entry_module {
                for init_func_name in &self.native_module_inits {
                    // Declare the external init function
                    let mut init_sig = self.module.make_signature();
                    init_sig.returns.push(AbiParam::new(types::I32));
                    if let Ok(init_func_id) = self.module.declare_function(init_func_name, Linkage::Import, &init_sig) {
                        let init_func_ref = self.module.declare_func_in_func(init_func_id, builder.func);
                        builder.ins().call(init_func_ref, &[]);
                    }
                }
            }

            // Auto-call dotenv.config() if dotenv/config was imported (side-effect import)
            if self.needs_dotenv_init {
                if let Some(dotenv_func_id) = self.extern_funcs.get("js_dotenv_config") {
                    let dotenv_func_ref = self.module.declare_func_in_func(*dotenv_func_id, builder.func);
                    builder.ins().call(dotenv_func_ref, &[]);
                }
            }

            let mut locals: HashMap<LocalId, LocalInfo> = HashMap::new();
            let mut next_var = 0;

            for stmt in stmts {
                // Check if this statement is a Let for a module-level variable
                if let Stmt::Let { name, init: Some(_init_expr), id, .. } = stmt {
                    // Compile the statement to get the value (this creates the local variable)
                    compile_stmt(&mut builder, &mut self.module, &self.func_ids, &self.closure_func_ids, &self.func_wrapper_ids, &self.extern_funcs, &self.async_func_ids, &self.closure_returning_funcs, &self.classes, &self.enums, &self.func_param_types, &self.func_union_params, &self.func_return_types, &self.func_hir_return_types, &self.func_rest_param_index, &self.imported_func_param_counts, &mut locals, &mut next_var, stmt, None, None, &boxed_vars)?;

                    // Get the value from the local variable
                    if let Some(local_info) = locals.get(id).cloned() {
                        let val = builder.use_var(local_info.var);

                        // Store to exported global if this is an exported variable
                        if exported_names.contains(name) {
                            let data_id = self.exported_native_instance_ids.get(name)
                                .or_else(|| self.exported_object_ids.get(name))
                                .copied();
                            if let Some(data_id) = data_id {
                                let global_val = self.module.declare_data_in_func(data_id, builder.func);
                                let ptr = builder.ins().global_value(types::I64, global_val);

                                // For pointer types (arrays, objects), NaN-box the pointer before storing
                                // so that importing modules can load them uniformly as f64
                                let val_to_store = if local_info.is_pointer && !local_info.is_string {
                                    // Get the NaN-boxing function
                                    let nanbox_func_id = self.extern_funcs.get("js_nanbox_pointer")
                                        .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                    let nanbox_ref = self.module.declare_func_in_func(*nanbox_func_id, builder.func);
                                    let call = builder.ins().call(nanbox_ref, &[val]);
                                    builder.inst_results(call)[0]
                                } else {
                                    val
                                };
                                builder.ins().store(MemFlags::new(), val_to_store, ptr, 0);
                            }
                        }

                        // Also store to module variable global for function access
                        if let Some(data_id) = self.module_var_data_ids.get(id).copied() {
                            let global_val = self.module.declare_data_in_func(data_id, builder.func);
                            let ptr = builder.ins().global_value(types::I64, global_val);
                            builder.ins().store(MemFlags::new(), val, ptr, 0);
                            // Store the LocalInfo so compile_function knows the type
                            self.module_level_locals.insert(*id, local_info);
                        }
                    }
                    continue;
                }
                compile_stmt(&mut builder, &mut self.module, &self.func_ids, &self.closure_func_ids, &self.func_wrapper_ids, &self.extern_funcs, &self.async_func_ids, &self.closure_returning_funcs, &self.classes, &self.enums, &self.func_param_types, &self.func_union_params, &self.func_return_types, &self.func_hir_return_types, &self.func_rest_param_index, &self.imported_func_param_counts, &mut locals, &mut next_var, stmt, None, None, &boxed_vars)?;
            }

            // Initialize exported function globals with closure values
            // This allows functions to be passed as values to other modules
            if let Some(alloc_func_id) = closure_alloc_id {
                let alloc_ref = self.module.declare_func_in_func(alloc_func_id, builder.func);
                // Get js_nanbox_pointer function for proper NaN-boxing
                let nanbox_func_id = self.extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = self.module.declare_func_in_func(*nanbox_func_id, builder.func);

                for (_func_name, data_id, wrapper_func_id) in &exported_func_info {
                    // Get the function address
                    let func_ref = self.module.declare_func_in_func(*wrapper_func_id, builder.func);
                    let func_ptr = builder.ins().func_addr(types::I64, func_ref);

                    // Allocate a closure with 0 captures
                    let capture_count = builder.ins().iconst(types::I32, 0);
                    let call = builder.ins().call(alloc_ref, &[func_ptr, capture_count]);
                    let closure_ptr = builder.inst_results(call)[0];

                    // Properly NaN-box the closure pointer using js_nanbox_pointer
                    // This ensures typeof returns "object" (closures are objects) and
                    // the value can be properly recognized by runtime functions
                    let nanbox_call = builder.ins().call(nanbox_ref, &[closure_ptr]);
                    let closure_val = builder.inst_results(nanbox_call)[0];

                    // Store to the exported global
                    let global_val = self.module.declare_data_in_func(*data_id, builder.func);
                    let ptr = builder.ins().global_value(types::I64, global_val);
                    builder.ins().store(MemFlags::new(), closure_val, ptr, 0);
                }
            }

            // Return 0 from main (if not already terminated)
            let current_block = builder.current_block().unwrap();
            if !is_block_filled(&builder, current_block) {
                let zero = builder.ins().iconst(types::I32, 0);
                builder.ins().return_(&[zero]);
            }

            builder.finalize();
        }

        self.module.define_function(func_id, &mut self.ctx)?;
        self.module.clear_context(&mut self.ctx);

        Ok(())
    }
}

/// Context for 'this' in constructors/methods
struct ThisContext {
    /// Variable holding 'this' pointer (i64)
    this_var: Variable,
    /// Class metadata for field lookup
    class_meta: ClassMeta,
}

/// Context for loops (for break/continue and bounds check elimination)
struct LoopContext {
    /// Block to jump to for 'break'
    exit_block: Block,
    /// Block to jump to for 'continue'
    header_block: Block,
    /// Bounds check elimination: maps index variable to (array_var, cached_length_value)
    /// When i is bounded by arr.length, arr[i] can skip bounds check
    bounded_indices: HashMap<LocalId, (LocalId, Value)>,
}

/// Check if a list of statements contains break or continue (for loop unrolling safety)
fn contains_loop_control(stmts: &[Stmt]) -> bool {
    for stmt in stmts {
        match stmt {
            Stmt::Break | Stmt::Continue => return true,
            Stmt::If { then_branch, else_branch, .. } => {
                if contains_loop_control(then_branch) { return true; }
                if let Some(else_b) = else_branch {
                    if contains_loop_control(else_b) { return true; }
                }
            }
            // Nested loops have their own break/continue scope, so we don't recurse
            Stmt::For { .. } | Stmt::While { .. } => {}
            Stmt::Try { body, catch, finally } => {
                if contains_loop_control(body) { return true; }
                if let Some(c) = catch {
                    if contains_loop_control(&c.body) { return true; }
                }
                if let Some(f) = finally {
                    if contains_loop_control(f) { return true; }
                }
            }
            _ => {}
        }
    }
    false
}

/// Compile a statement inside an async function (handles return specially)
fn compile_async_stmt(
    builder: &mut FunctionBuilder,
    module: &mut ObjectModule,
    func_ids: &HashMap<u32, cranelift_module::FuncId>,
    closure_func_ids: &HashMap<u32, cranelift_module::FuncId>,
    func_wrapper_ids: &HashMap<u32, cranelift_module::FuncId>,
    extern_funcs: &HashMap<String, cranelift_module::FuncId>,
    async_func_ids: &std::collections::HashSet<u32>,
    closure_returning_funcs: &std::collections::HashSet<u32>,
    classes: &HashMap<String, ClassMeta>,
    enums: &HashMap<(String, String), EnumMemberValue>,
    func_param_types: &HashMap<u32, Vec<types::Type>>, func_union_params: &HashMap<u32, Vec<bool>>,
    func_return_types: &HashMap<u32, types::Type>,
    func_hir_return_types: &HashMap<u32, perry_types::Type>,
    func_rest_param_index: &HashMap<u32, usize>,
    imported_func_param_counts: &HashMap<String, usize>,
    locals: &mut HashMap<LocalId, LocalInfo>,
    next_var: &mut usize,
    stmt: &Stmt,
    promise_var: Variable,
    boxed_vars: &std::collections::HashSet<LocalId>,
) -> Result<()> {
    match stmt {
        Stmt::Return(Some(expr)) => {
            // In async function, return resolves the promise and returns it
            let value = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, None)?;
            let promise_ptr = builder.use_var(promise_var);

            // Helper to detect if an expression returns a Promise
            // This is needed for Promise unwrapping - when returning a Promise from async function
            fn is_promise_expr(expr: &Expr, async_func_ids: &std::collections::HashSet<u32>) -> bool {
                match expr {
                    // new Promise(...) returns a Promise
                    Expr::New { class_name, .. } if class_name == "Promise" => true,
                    // Calling an async function returns a Promise
                    Expr::Call { callee, .. } => {
                        if let Expr::FuncRef(func_id) = callee.as_ref() {
                            async_func_ids.contains(func_id)
                        } else {
                            false
                        }
                    }
                    _ => false,
                }
            }

            // Helper to detect if an expression is an object/array (pointer type)
            fn is_object_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>, async_func_ids: &std::collections::HashSet<u32>) -> bool {
                // Promises are handled separately - don't treat them as generic objects
                if is_promise_expr(expr, async_func_ids) {
                    return false;
                }
                match expr {
                    Expr::Object(_) | Expr::Array(_) | Expr::ArraySpread(_) => true,
                    Expr::New { .. } => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_pointer && !i.is_string).unwrap_or(false),
                    Expr::JsonParse(_) => true,
                    _ => false,
                }
            }

            // Helper to detect if an expression is a string
            fn is_string_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    Expr::NativeMethodCall { module, method, .. } => {
                        (module == "path" && matches!(method.as_str(), "dirname" | "basename" | "extname" | "join" | "resolve"))
                        || (module == "fs" && method == "readFileSync")
                        || (module == "uuid" && matches!(method.as_str(), "v4" | "v1" | "v7"))
                        || (module == "crypto" && matches!(method.as_str(), "sha256" | "md5" | "randomUUID" | "hmacSha256" | "randomBytes"))
                    }
                    // String concatenation (+ with string operand) returns string
                    Expr::Binary { op: BinaryOp::Add, left, right } => {
                        is_string_expr(left, locals) || is_string_expr(right, locals)
                    }
                    // Property access on strings (like str.substring()) returns string
                    Expr::PropertyGet { object, property } => {
                        if is_string_expr(object, locals) {
                            matches!(property.as_str(), "substring" | "slice" | "toLowerCase" | "toUpperCase"
                                | "trim" | "trimStart" | "trimEnd" | "charAt" | "padStart" | "padEnd"
                                | "repeat" | "replace" | "replaceAll" | "concat")
                        } else {
                            false
                        }
                    }
                    Expr::Call { callee, .. } => {
                        // Check if it's a string method call
                        if let Expr::PropertyGet { object, property } = callee.as_ref() {
                            if is_string_expr(object, locals) {
                                return matches!(property.as_str(), "substring" | "slice" | "toLowerCase" | "toUpperCase"
                                    | "trim" | "trimStart" | "trimEnd" | "charAt" | "padStart" | "padEnd"
                                    | "repeat" | "replace" | "replaceAll" | "concat" | "split" | "join");
                            }
                        }
                        false
                    }
                    _ => false,
                }
            }

            // Check if we're returning a Promise - need special handling for Promise unwrapping
            if is_promise_expr(expr, async_func_ids) {
                // Returning a Promise from async function - chain the promises
                // The outer promise should adopt the inner promise's eventual value
                let inner_promise_ptr = ensure_i64(builder, value);
                let resolve_with_promise_func = extern_funcs.get("js_promise_resolve_with_promise")
                    .ok_or_else(|| anyhow!("js_promise_resolve_with_promise not declared"))?;
                let resolve_ref = module.declare_func_in_func(*resolve_with_promise_func, builder.func);
                builder.ins().call(resolve_ref, &[promise_ptr, inner_promise_ptr]);
            } else {
                // Resolve the promise with the value
                // NaN-box object/array pointers for proper typeof support
                let value_f64 = if is_object_expr(expr, locals, async_func_ids) {
                    // Object pointer needs NaN-boxing with POINTER_TAG
                    let ptr = ensure_i64(builder, value);
                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[ptr]);
                    builder.inst_results(call)[0]
                } else if is_string_expr(expr, locals) {
                    // String pointer needs NaN-boxing with STRING_TAG
                    let ptr = ensure_i64(builder, value);
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[ptr]);
                    builder.inst_results(call)[0]
                } else {
                    ensure_f64(builder, value)
                };

                let resolve_func = extern_funcs.get("js_promise_resolve")
                    .ok_or_else(|| anyhow!("js_promise_resolve not declared"))?;
                let resolve_ref = module.declare_func_in_func(*resolve_func, builder.func);
                builder.ins().call(resolve_ref, &[promise_ptr, value_f64]);
            }

            // Return the promise
            builder.ins().return_(&[promise_ptr]);
            Ok(())
        }
        Stmt::Return(None) => {
            // Return undefined
            let promise_ptr = builder.use_var(promise_var);

            let resolve_func = extern_funcs.get("js_promise_resolve")
                .ok_or_else(|| anyhow!("js_promise_resolve not declared"))?;
            let resolve_ref = module.declare_func_in_func(*resolve_func, builder.func);
            const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
            let undef_val = builder.ins().f64const(f64::from_bits(TAG_UNDEFINED));
            builder.ins().call(resolve_ref, &[promise_ptr, undef_val]);

            builder.ins().return_(&[promise_ptr]);
            Ok(())
        }
        // Handle If statements specially to ensure nested returns are compiled correctly
        Stmt::If { condition, then_branch, else_branch } => {
            let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, None)?;
            let cond_val = ensure_f64(builder, cond_val_raw);
            // Use js_is_truthy for proper JavaScript truthiness semantics
            let truthy_func = extern_funcs.get("js_is_truthy")
                .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
            let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
            let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
            let truthy_result = builder.inst_results(truthy_call)[0];
            let zero_i32 = builder.ins().iconst(types::I32, 0);
            let cond_bool = builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32);

            let then_block = builder.create_block();
            let else_block = builder.create_block();
            let merge_block = builder.create_block();

            builder.ins().brif(cond_bool, then_block, &[], else_block, &[]);

            // Then branch - use compile_async_stmt for nested statements
            builder.switch_to_block(then_block);
            builder.seal_block(then_block);
            for s in then_branch {
                compile_async_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, promise_var, boxed_vars)?;
            }
            let current = builder.current_block().unwrap();
            if !is_block_filled(builder, current) {
                builder.ins().jump(merge_block, &[]);
            }

            // Else branch - use compile_async_stmt for nested statements
            builder.switch_to_block(else_block);
            builder.seal_block(else_block);
            if let Some(else_stmts) = else_branch {
                for s in else_stmts {
                    compile_async_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, promise_var, boxed_vars)?;
                }
            }
            let current = builder.current_block().unwrap();
            if !is_block_filled(builder, current) {
                builder.ins().jump(merge_block, &[]);
            }

            // Merge
            builder.switch_to_block(merge_block);
            builder.seal_block(merge_block);
            Ok(())
        }
        // For other statements, use the regular compile_stmt
        _ => {
            compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, stmt, None, None, boxed_vars)
        }
    }
}

fn compile_stmt(
    builder: &mut FunctionBuilder,
    module: &mut ObjectModule,
    func_ids: &HashMap<u32, cranelift_module::FuncId>,
    closure_func_ids: &HashMap<u32, cranelift_module::FuncId>,
    func_wrapper_ids: &HashMap<u32, cranelift_module::FuncId>,
    extern_funcs: &HashMap<String, cranelift_module::FuncId>,
    async_func_ids: &std::collections::HashSet<u32>,
    closure_returning_funcs: &std::collections::HashSet<u32>,
    classes: &HashMap<String, ClassMeta>,
    enums: &HashMap<(String, String), EnumMemberValue>,
    func_param_types: &HashMap<u32, Vec<types::Type>>, func_union_params: &HashMap<u32, Vec<bool>>,
    func_return_types: &HashMap<u32, types::Type>,
    func_hir_return_types: &HashMap<u32, perry_types::Type>,
    func_rest_param_index: &HashMap<u32, usize>,
    imported_func_param_counts: &HashMap<String, usize>,
    locals: &mut HashMap<LocalId, LocalInfo>,
    next_var: &mut usize,
    stmt: &Stmt,
    this_ctx: Option<&ThisContext>,
    loop_ctx: Option<&LoopContext>,
    boxed_vars: &std::collections::HashSet<LocalId>,
) -> Result<()> {
    match stmt {
        Stmt::Let { id, name: var_name, mutable: _, ty, init, .. } => {
            // Use the declared type to determine the ABI type
            // Note: Type::Any and Type::Unknown use expression inference, not pointer type
            use perry_types::Type as HirType;
            let is_typed_pointer = matches!(ty, HirType::String | HirType::Array(_) |
                HirType::Object(_) | HirType::Named(_) | HirType::Generic { .. } |
                HirType::Function(_));
            let is_typed_string = matches!(ty, HirType::String);
            let is_typed_bigint_check = matches!(ty, HirType::BigInt);

            // Helper to detect if an expression produces a string (fallback for untyped cases)
            // Note: EnvGet is NOT included here because it can return undefined if the env var doesn't exist
            fn is_string_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    // EnvGet is NOT included - it returns string OR undefined (handled as union)
                    Expr::FsReadFileSync(_) => true, // fs.readFileSync returns a string
                    // All path operations return strings
                    Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                    Expr::PathExtname(_) | Expr::PathResolve(_) | Expr::JsonStringify(_) => true,
                    // All crypto operations return strings (hex or UUID format)
                    Expr::CryptoRandomBytes(_) | Expr::CryptoRandomUUID |
                    Expr::CryptoSha256(_) | Expr::CryptoMd5(_) => true,
                    // Date.toISOString() returns a string
                    Expr::DateToISOString(_) => true,
                    // OS operations that return strings
                    Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                    Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    Expr::Binary { op: BinaryOp::Add, left, right } => {
                        is_string_expr(left, locals) || is_string_expr(right, locals)
                    }
                    Expr::Call { callee, .. } => {
                        // Check if it's a string method call (slice/substring/trim/toLowerCase/toUpperCase returns string)
                        if let Expr::PropertyGet { object, property } = callee.as_ref() {
                            if property == "slice" || property == "substring" || property == "trim"
                               || property == "toLowerCase" || property == "toUpperCase" || property == "replace"
                               || property == "padStart" || property == "padEnd" || property == "repeat" || property == "charAt" {
                                if let Expr::LocalGet(id) = object.as_ref() {
                                    // If we can find the local, check if it's a string
                                    // Otherwise, assume it is (since we know it's a string method)
                                    return locals.get(id).map(|i| i.is_string).unwrap_or(true);
                                }
                                // For non-LocalGet (like property chains), assume it's a string method
                                return true;
                            }
                            // Check if it's buffer.toString() which returns a string
                            if property == "toString" {
                                if let Expr::LocalGet(id) = object.as_ref() {
                                    if locals.get(id).map(|i| i.is_buffer).unwrap_or(false) {
                                        return true;
                                    }
                                }
                            }
                        }
                        // Check if it's an external function that returns a string
                        if let Expr::ExternFuncRef { name: func_name, return_type, .. } = callee.as_ref() {
                            // Use the return type if available
                            if matches!(return_type, perry_types::Type::String) {
                                return true;
                            }
                            // Fallback: HTTP request methods that return strings
                            if func_name.starts_with("js_http_request_method")
                                || func_name.starts_with("js_http_request_path")
                                || func_name.starts_with("js_http_request_query")
                                || func_name.starts_with("js_http_request_body")
                                || func_name.starts_with("js_http_request_content_type")
                                || func_name.starts_with("js_http_request_header")
                            {
                                return true;
                            }
                        }
                        false
                    }
                    // NativeMethodCall methods that return strings
                    Expr::NativeMethodCall { module, method, .. } => {
                        // Decimal/Big.js toString and toFixed return strings
                        ((module == "decimal.js" || module == "big.js" || module == "bignumber.js") &&
                         (method == "toString" || method == "toFixed"))
                        // Path module functions return strings
                        || (module == "path" && matches!(method.as_str(), "dirname" | "basename" | "extname" | "join" | "resolve"))
                        // fs.readFileSync returns string
                        || (module == "fs" && method == "readFileSync")
                        // uuid functions return strings
                        || (module == "uuid" && matches!(method.as_str(), "v4" | "v1" | "v7"))
                        // crypto functions return strings
                        || (module == "crypto" && matches!(method.as_str(), "sha256" | "md5" | "randomUUID" | "hmacSha256" | "randomBytes"))
                    }
                    _ => false,
                }
            }

            // Helper to detect if an expression produces a BigInt
            fn is_bigint_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::BigInt(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_bigint).unwrap_or(false),
                    Expr::Binary { left, right, .. } => {
                        is_bigint_expr(left, locals) || is_bigint_expr(right, locals)
                    }
                    // NativeMethodCall methods that return BigInt
                    Expr::NativeMethodCall { module, method, .. } => {
                        // ethers parseUnits/parseEther return BigInt
                        module == "ethers" && (method == "parseUnits" || method == "parseEther")
                    }
                    _ => false,
                }
            }

            // Helper to detect if an expression produces a Closure
            fn is_closure_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>, closure_returning_funcs: &std::collections::HashSet<u32>) -> bool {
                match expr {
                    Expr::Closure { .. } => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_closure).unwrap_or(false),
                    // Check for function calls that return closures
                    Expr::Call { callee, .. } => {
                        match callee.as_ref() {
                            Expr::FuncRef(func_id) => closure_returning_funcs.contains(func_id),
                            _ => false,
                        }
                    }
                    _ => false,
                }
            }

            // Helper to detect if an expression produces an integer value (for native i64 optimization)
            fn is_integer_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    // Integer literals
                    Expr::Integer(_) => true,
                    // Variable that was tracked as integer
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_integer).unwrap_or(false),
                    // Bitwise operations always produce integers
                    Expr::Binary { op: BinaryOp::BitAnd | BinaryOp::BitOr | BinaryOp::BitXor |
                                       BinaryOp::Shl | BinaryOp::Shr | BinaryOp::UShr, .. } => true,
                    // Arithmetic operations produce integers if both operands are integers
                    Expr::Binary { op: BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul | BinaryOp::Mod, left, right } => {
                        is_integer_expr(left, locals) && is_integer_expr(right, locals)
                    }
                    // Unary minus on integer is still integer
                    Expr::Unary { op: UnaryOp::Neg, operand } => is_integer_expr(operand, locals),
                    // Bitwise NOT always produces integer
                    Expr::Unary { op: UnaryOp::BitNot, .. } => true,
                    // Array/string .length is always an integer
                    Expr::PropertyGet { property, object } if property == "length" => {
                        if let Expr::LocalGet(id) = object.as_ref() {
                            locals.get(id).map(|i| i.is_array || i.is_string).unwrap_or(false)
                        } else {
                            false
                        }
                    }
                    _ => false,
                }
            }

            // Determine variable type - prefer declared type, fall back to init expression inference
            let is_typed_array = matches!(ty, HirType::Array(_));
            let is_typed_bigint = matches!(ty, HirType::BigInt);
            let is_typed_closure = matches!(ty, HirType::Function(_));
            let is_typed_map = matches!(ty, HirType::Generic { base, .. } if base == "Map");
            let is_typed_set = matches!(ty, HirType::Generic { base, .. } if base == "Set");
            let is_typed_union = matches!(ty, HirType::Union(_));
            // Named/Object types may contain NaN-boxed values when fields are accessed
            let is_typed_generic_object = matches!(ty, HirType::Named(_) | HirType::Object(_) | HirType::Any);

            // Helper to detect mixed-type array from expression
            fn is_mixed_array_expr(expr: &Expr, _locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::Array(elements) => {
                        // Check if array contains both strings and numbers
                        let has_string = elements.iter().any(|e| matches!(e, Expr::String(_)));
                        let has_number = elements.iter().any(|e| matches!(e, Expr::Number(_) | Expr::Integer(_) | Expr::Bool(_)));
                        has_string && has_number
                    }
                    // ProcessArgv returns an array of NaN-boxed strings
                    Expr::ProcessArgv => true,
                    _ => false,
                }
            }

            // Check if array has mixed element types (union or any) - from type or expression
            // Also check source variables for LocalGet to propagate is_mixed_array
            let is_mixed_array_from_type = if let HirType::Array(elem_ty) = ty {
                matches!(elem_ty.as_ref(), HirType::Union(_) | HirType::Any)
            } else if let Some(expr) = init {
                is_mixed_array_expr(expr, locals)
            } else {
                false
            };
            let is_mixed_array_from_source = if let Some(Expr::LocalGet(src_id)) = init {
                locals.get(src_id).map(|i| i.is_mixed_array || i.is_union).unwrap_or(false)
            } else {
                false
            };
            let is_mixed_array = is_mixed_array_from_type || is_mixed_array_from_source;

            // Extract class name from Named type (also check union types for named class)
            let typed_class_name = if let HirType::Named(name) = ty {
                Some(name.clone())
            } else if let HirType::Union(types) = ty {
                // For union types like `Person | null`, extract the class name from Named types
                types.iter().find_map(|t| {
                    if let HirType::Named(name) = t {
                        Some(name.clone())
                    } else {
                        None
                    }
                })
            } else {
                None
            };

            // Helper to detect if an expression produces a buffer
            fn is_buffer_expr(expr: &Expr) -> bool {
                matches!(expr,
                    Expr::BufferFrom { .. } | Expr::BufferAlloc { .. } | Expr::BufferAllocUnsafe(_) |
                    Expr::BufferConcat(_) | Expr::BufferSlice { .. } |
                    Expr::ChildProcessExecSync { .. }
                )
            }

            // Use declared type information first, fall back to expression inference
            // For union types, we should NOT infer is_string etc. based on initialization
            let (class_name, is_pointer, is_array, is_string, is_bigint, is_closure, is_map, is_set, is_buffer, is_event_emitter) = if is_typed_union {
                // Union types use f64 (NaN-boxed), but track class_name if available for property access
                (typed_class_name.clone(), false, false, false, false, false, false, false, false, false)
            } else if is_typed_string {
                // String type uses f64 (NaN-boxed) but is_string = true for console.log
                (None, false, false, true, false, false, false, false, false, false)
            } else if is_typed_bigint_check {
                // BigInt type uses f64 (NaN-boxed) but is_bigint = true for method calls
                (None, false, false, false, true, false, false, false, false, false)
            } else if is_typed_pointer {
                // Type annotation tells us the type (non-string pointer types use i64)
                let class_name = typed_class_name.or_else(|| {
                    if let Some(Expr::New { class_name, .. }) = init {
                        Some(class_name.clone())
                    } else {
                        None
                    }
                });
                (class_name, true, is_typed_array, false, is_typed_bigint, is_typed_closure, is_typed_map, is_typed_set, false, false)
            } else {
                // Fall back to expression inference for untyped cases
                match init {
                    Some(Expr::New { class_name, .. }) => {
                        // Native handle-based classes use f64 (handles bitcast to f64), not i64 pointers
                        let is_native_handle_class = matches!(class_name.as_str(),
                            "Decimal" | "Big" | "BigNumber" | "LRUCache" | "Command" | "EventEmitter" | "Redis");
                        let is_event_emitter = class_name == "EventEmitter";
                        (Some(class_name.clone()), !is_native_handle_class, false, false, false, false, false, false, false, is_event_emitter)
                    }
                    Some(Expr::Array(_)) | Some(Expr::ArraySpread(_)) | Some(Expr::ProcessArgv) => (None, true, true, false, false, false, false, false, false, false),
                    // Object literals return object pointers
                    Some(Expr::Object(_)) => (None, true, false, false, false, false, false, false, false, false),
                    // ArrayMap, ArrayFilter, ArraySlice, and ArraySplice return arrays
                    Some(Expr::ArrayMap { .. }) | Some(Expr::ArrayFilter { .. }) |
                    Some(Expr::ArraySlice { .. }) | Some(Expr::ArraySplice { .. }) => (None, true, true, false, false, false, false, false, false, false),
                    // MapNew returns a Map pointer
                    Some(Expr::MapNew) => (None, true, false, false, false, false, true, false, false, false),
                    // SetNew returns a Set pointer
                    Some(Expr::SetNew) => (None, true, false, false, false, false, false, true, false, false),
                    // Buffer expressions return buffer pointers
                    Some(expr) if is_buffer_expr(expr) => (None, true, false, false, false, false, false, false, true, false),
                    Some(Expr::Closure { .. }) => (None, true, false, false, false, true, false, false, false, false),
                    // BigInt literals - stored as NaN-boxed F64 (is_pointer = false)
                    Some(Expr::BigInt(_)) => (None, false, false, false, true, false, false, false, false, false),
                    Some(expr) if is_bigint_expr(expr, locals) => (None, false, false, false, true, false, false, false, false, false),
                    Some(expr) if is_string_expr(expr, locals) => (None, false, false, true, false, false, false, false, false, false),
                    Some(expr) if is_closure_expr(expr, locals, closure_returning_funcs) => (None, true, false, false, false, true, false, false, false, false),
                    // JsonParse returns any type - mark as union for dynamic typeof
                    Some(Expr::JsonParse(_)) => (None, false, false, false, false, false, false, false, false, false),
                    // Await expression - the result is already NaN-boxed (not a raw pointer)
                    // is_pointer must be false so we don't try to re-NaN-box when returning
                    Some(Expr::Await(_)) => (None, false, false, false, false, false, false, false, false, false),
                    // Function call - check if the function returns a pointer type (i64)
                    // Also check for array method calls like .map(), .filter(), .slice() which return arrays
                    Some(Expr::Call { callee, .. }) => {
                        if let Expr::FuncRef(func_id) = callee.as_ref() {
                            // Check the HIR return type to detect Map, Set, Array, etc.
                            if let Some(hir_ret_type) = func_hir_return_types.get(func_id) {
                                match hir_ret_type {
                                    perry_types::Type::Generic { base, .. } if base == "Map" => {
                                        // Function returns Map<K, V>
                                        (None, true, false, false, false, false, true, false, false, false)
                                    }
                                    perry_types::Type::Generic { base, .. } if base == "Set" => {
                                        // Function returns Set<T>
                                        (None, true, false, false, false, false, false, true, false, false)
                                    }
                                    perry_types::Type::Array(_) => {
                                        // Function returns Array<T>
                                        (None, true, true, false, false, false, false, false, false, false)
                                    }
                                    perry_types::Type::String => {
                                        // Function returns string
                                        (None, false, false, true, false, false, false, false, false, false)
                                    }
                                    _ => {
                                        // Check ABI type for other pointer types
                                        if let Some(&ret_type) = func_return_types.get(func_id) {
                                            if ret_type == types::I64 {
                                                (None, true, false, false, false, false, false, false, false, false)
                                            } else {
                                                (None, false, false, false, false, false, false, false, false, false)
                                            }
                                        } else {
                                            (None, false, false, false, false, false, false, false, false, false)
                                        }
                                    }
                                }
                            } else if let Some(&ret_type) = func_return_types.get(func_id) {
                                if ret_type == types::I64 {
                                    // Function returns i64 (string/array/object pointer)
                                    (None, true, false, false, false, false, false, false, false, false)
                                } else {
                                    (None, false, false, false, false, false, false, false, false, false)
                                }
                            } else {
                                (None, false, false, false, false, false, false, false, false, false)
                            }
                        } else if let Expr::PropertyGet { object, property } = callee.as_ref() {
                            // Check for array methods that return arrays
                            if property == "slice" {
                                // slice could be array or string method - check the object
                                if let Expr::LocalGet(id) = object.as_ref() {
                                    if let Some(src_info) = locals.get(id) {
                                        if src_info.is_string {
                                            // String.slice returns NaN-boxed string (f64, not i64 pointer)
                                            (None, false, false, true, false, false, false, false, false, false)
                                        } else if src_info.is_array {
                                            // Array.slice returns array
                                            (None, true, true, false, false, false, false, false, false, false)
                                        } else {
                                            (None, false, false, false, false, false, false, false, false, false)
                                        }
                                    } else {
                                        (None, false, false, false, false, false, false, false, false, false)
                                    }
                                } else {
                                    (None, false, false, false, false, false, false, false, false, false)
                                }
                            } else if property == "substring" || property == "trim" || property == "toLowerCase"
                                || property == "toUpperCase" || property == "charAt" || property == "padStart"
                                || property == "padEnd" || property == "repeat" || property == "replace" {
                                // String methods that return NaN-boxed strings (f64, not i64 pointers)
                                // is_pointer must be false so the variable uses f64 type
                                (None, false, false, true, false, false, false, false, false, false)
                            } else if property == "map" || property == "filter" ||
                               property == "concat" || property == "flat" || property == "flatMap" ||
                               property == "reverse" || property == "sort" || property == "toSorted" ||
                               property == "toReversed" || property == "with" {
                                (None, true, true, false, false, false, false, false, false, false)
                            } else if property == "split" {
                                // split() on strings returns a NaN-boxed array pointer (f64)
                                // is_pointer must be false so the variable uses f64 type
                                (None, false, true, false, false, false, false, false, false, false)
                            } else {
                                (None, false, false, false, false, false, false, false, false, false)
                            }
                        } else {
                            (None, false, false, false, false, false, false, false, false, false)
                        }
                    }
                    // LocalGet inherits pointer-ness from source variable
                    Some(Expr::LocalGet(src_id)) => {
                        if let Some(src_info) = locals.get(src_id) {
                            (src_info.class_name.clone(), src_info.is_pointer, src_info.is_array, src_info.is_string, src_info.is_bigint, src_info.is_closure, src_info.is_map, src_info.is_set, src_info.is_buffer, src_info.is_event_emitter)
                        } else {
                            (None, false, false, false, false, false, false, false, false, false)
                        }
                    }
                    _ => (None, false, false, false, false, false, false, false, false, false),
                }
            };

            // Check if initialized with JsonParse - need is_union for proper typeof
            let is_json_parse_init = matches!(init, Some(Expr::JsonParse(_)));

            // Check if initialized from PropertyGet on a non-class object (e.g., object destructuring)
            // These values are NaN-boxed and need dynamic handling
            let is_property_from_generic_object = matches!(init, Some(Expr::PropertyGet { object, property })
                if property != "length" && matches!(object.as_ref(), Expr::LocalGet(id)
                    if locals.get(id).map(|info| !info.is_array && !info.is_string && !info.is_map && !info.is_set && info.class_name.is_none()).unwrap_or(true)));

            // Check if initialized from JS interop expressions (JsCallFunction, JsGetExport, JsCallMethod)
            // These return NaN-boxed values that could be any type
            let is_js_interop_init = matches!(init, Some(Expr::JsCallFunction { .. }) | Some(Expr::JsGetExport { .. }) | Some(Expr::JsCallMethod { .. }));

            // NOTE: String method calls (substring, slice, trim, etc.) return NaN-boxed f64 strings.
            // is_string is set to true, and is_pointer is false, so they use f64 variable type.
            // js_get_string_pointer_unified handles both NaN-boxed and raw pointer strings.

            // Check if initialized from a conditional (ternary) expression
            // These can return different types from each branch
            let is_conditional_init = matches!(init, Some(Expr::Conditional { .. }));

            // Check if initialized from await expression
            // Await results are NaN-boxed and need dynamic typeof handling
            let is_await_init = matches!(init, Some(Expr::Await(_)));

            // Check if initialized from EnvGet/EnvGetDynamic (process.env.VAR or process.env[key])
            // EnvGet/EnvGetDynamic returns a NaN-boxed value: string if the env var exists, undefined if not
            let is_envget_init = matches!(init, Some(Expr::EnvGet(_)) | Some(Expr::EnvGetDynamic(_)));

            // Check if initialized from IndexGet (array element access)
            // Array elements from mixed/union arrays are NaN-boxed and need dynamic handling
            let is_indexget_init = if let Some(Expr::IndexGet { object, .. }) = init {
                // If the array is marked as mixed or union, elements need union handling
                if let Expr::LocalGet(arr_id) = object.as_ref() {
                    locals.get(arr_id).map(|i| i.is_mixed_array || i.is_union || i.is_array).unwrap_or(true)
                } else {
                    true // Conservative: unknown array sources need union handling
                }
            } else {
                false
            };

            // Check if initialized from a LocalGet to a variable that has is_union or is_mixed_array
            // This propagates the union/mixed flags for variables like for...of internal arrays
            let (is_localget_union, is_localget_mixed_array) = if let Some(Expr::LocalGet(src_id)) = init {
                if let Some(src_info) = locals.get(src_id) {
                    (src_info.is_union || src_info.is_mixed_array, src_info.is_mixed_array)
                } else {
                    (false, false)
                }
            } else {
                (false, false)
            };

            // Don't mark as union if we know the concrete type from expression inference
            // This prevents strings/arrays/etc with ty=Any from being treated as union
            let is_typed_generic_object_union = is_typed_generic_object && !is_string && !is_array && !is_bigint && !is_closure && !is_map && !is_set && !is_buffer;

            let is_union = is_typed_union || is_typed_generic_object_union || is_json_parse_init || is_property_from_generic_object || is_js_interop_init || is_conditional_init || is_await_init || is_localget_union || is_indexget_init || is_envget_init;

            // Extract type arguments from Expr::New for generic class instances
            let type_args = if let Some(Expr::New { type_args, .. }) = init {
                type_args.clone()
            } else {
                Vec::new()
            };

            // Detect if the variable should be stored as native i32
            // IMPORTANT: We do NOT automatically use i32 for integer-initialized variables
            // because they can overflow (e.g., `let sum = 0` can accumulate to huge values).
            // The loop counter i32 optimization is handled separately during BCE detection,
            // which properly bounds the loop counter by the array length or constant limit.
            let should_use_i32 = false;

            let var = Variable::new(*next_var);
            *next_var += 1;

            // Use i64 for pointers, i32 for integer accumulators, f64 for other numbers
            // Union types use f64 because they contain NaN-boxed values that need the type tag
            let var_type = if is_pointer && !is_union { types::I64 } else if should_use_i32 { types::I32 } else { types::F64 };
            builder.declare_var(var, var_type);

            if let Some(init_expr) = init {
                if should_use_i32 {
                    // Initialize i32 variable directly
                    let init_val = match init_expr {
                        Expr::Integer(n) => builder.ins().iconst(types::I32, *n),
                        Expr::Number(f) => builder.ins().iconst(types::I32, *f as i64),
                        _ => {
                            // Fallback: compile expression and convert
                            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, init_expr, this_ctx)?;
                            // fcvt_to_sint requires f64 input, so ensure the value is f64
                            let val_f64 = ensure_f64(builder, val);
                            builder.ins().fcvt_to_sint(types::I32, val_f64)
                        }
                    };
                    builder.def_var(var, init_val);
                } else {
                    // Compile the expression and assign directly - typed expressions now return correct types
                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, init_expr, this_ctx)?;

                    // Check if this is a string from an array IndexGet (NaN-boxed string needs un-boxing)
                    let is_string_from_array = is_string && matches!(init_expr, Expr::IndexGet { object, .. }
                        if matches!(object.as_ref(), Expr::LocalGet(id) if locals.get(id).map(|i| i.is_array).unwrap_or(false)));

                    // For union types, we need to NaN-box pointer values (strings, objects, etc.)
                    // so they can be distinguished from regular numbers at runtime
                    let val = if is_typed_union && is_string_expr(init_expr, locals) {
                        // String expression returns f64 (bitcast from i64 pointer)
                        // Convert back to i64 and wrap with NaN-boxing using STRING_TAG
                        let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                        let call = builder.ins().call(nanbox_ref, &[ptr]);
                        builder.inst_results(call)[0]
                    } else if is_string_from_array {
                        // String from array is NaN-boxed - extract the raw pointer
                        let get_str_ptr_func = extern_funcs.get("js_nanbox_get_string_pointer")
                            .ok_or_else(|| anyhow!("js_nanbox_get_string_pointer not declared"))?;
                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                        let call = builder.ins().call(get_str_ptr_ref, &[val]);
                        let str_ptr = builder.inst_results(call)[0];
                        // Bitcast i64 to f64 for storage (string variables use f64 representation)
                        builder.ins().bitcast(types::F64, MemFlags::new(), str_ptr)
                    } else if is_pointer && !is_union {
                        // If variable is i64 (pointer) but expression returns f64, we need to handle
                        // NaN-boxed values properly. IndexGet and PropertyGet return NaN-boxed F64
                        // values that need to have the pointer extracted, not just bitcast.
                        let val_type = builder.func.dfg.value_type(val);
                        if val_type == types::F64 {
                            // Check if this is a NaN-boxed expression (IndexGet, PropertyGet on generic objects, etc.)
                            let is_nanboxed_expr = match init_expr {
                                Expr::IndexGet { .. } => true,
                                Expr::PropertyGet { object, property } => {
                                    // PropertyGet on generic objects (not arrays/maps/etc.) returns NaN-boxed
                                    if let Expr::LocalGet(id) = object.as_ref() {
                                        locals.get(id).map(|info| {
                                            !info.is_array && !info.is_string && !info.is_map && !info.is_set && info.class_name.is_none()
                                        }).unwrap_or(true) && property != "length"
                                    } else {
                                        true
                                    }
                                }
                                _ => false,
                            };

                            if is_nanboxed_expr {
                                // Extract the raw pointer from NaN-boxed value
                                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                                let call = builder.ins().call(get_ptr_ref, &[val]);
                                builder.inst_results(call)[0]
                            } else {
                                // Regular bitcast for values that are already raw pointers
                                builder.ins().bitcast(types::I64, MemFlags::new(), val)
                            }
                        } else {
                            val
                        }
                    } else if is_union {
                        // Union types use NaN-boxed f64 values - keep as f64
                        let val_type = builder.func.dfg.value_type(val);
                        if val_type == types::I64 {
                            builder.ins().bitcast(types::F64, MemFlags::new(), val)
                        } else {
                            val
                        }
                    } else {
                        // Variable is f64, but expression might return i64 (e.g., function call returning pointer)
                        // Check and convert if needed
                        let val_type = builder.func.dfg.value_type(val);
                        if val_type == types::I64 && var_type == types::F64 {
                            builder.ins().bitcast(types::F64, MemFlags::new(), val)
                        } else {
                            val
                        }
                    };
                    builder.def_var(var, val);
                }
            } else {
                // Initialize to undefined/null/0 depending on the type
                if is_pointer && !is_union {
                    // Raw pointer type - use null pointer (0)
                    let zero = builder.ins().iconst(types::I64, 0);
                    builder.def_var(var, zero);
                } else if should_use_i32 {
                    let zero = builder.ins().iconst(types::I32, 0);
                    builder.def_var(var, zero);
                } else {
                    // f64 type - use TAG_UNDEFINED for proper JavaScript semantics
                    const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                    let undef = builder.ins().f64const(f64::from_bits(TAG_UNDEFINED));
                    builder.def_var(var, undef);
                }
            }

            // Detect if the variable contains an integer value (for native i64 optimization)
            // Only track as integer if not a pointer type and initialized with an integer expression
            let is_integer = !is_pointer && init.as_ref().map(|e| is_integer_expr(e, locals)).unwrap_or(false);

            let i32_shadow: Option<Variable> = None;

            locals.insert(*id, LocalInfo { var, name: Some(var_name.clone()), class_name, type_args, is_pointer, is_array, is_string, is_bigint, is_closure, is_boxed: false, is_map, is_set, is_buffer, is_event_emitter, is_union, is_mixed_array, is_integer, is_integer_array: false, is_i32: should_use_i32, i32_shadow, bounded_by_array: None, bounded_by_constant: None, scalar_fields: None, squared_cache: None, product_cache: None });
        }
        Stmt::Return(expr) => {
            // Get expected return type from function signature
            let ret_type = builder.func.signature.returns.first().map(|p| p.value_type).unwrap_or(types::F64);

            let val = if let Some(e) = expr {
                compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, e, this_ctx)?
            } else {
                // Return 0 in the appropriate type for the function signature
                match ret_type {
                    types::I32 => builder.ins().iconst(types::I32, 0),
                    types::I64 => builder.ins().iconst(types::I64, 0),
                    _ => builder.ins().f64const(0.0),
                }
            };
            // Check if return type expects i64 but expression returns f64 (or vice versa)
            // This handles cases like returning array literals from functions with array return type
            let val_type = builder.func.dfg.value_type(val);
            let val = if ret_type == types::I64 && val_type == types::F64 {
                // Expression returned f64, need i64 - bitcast
                builder.ins().bitcast(types::I64, MemFlags::new(), val)
            } else if ret_type == types::F64 && val_type == types::I64 {
                // Expression returned i64 (pointer), convert to f64 for function returning f64
                builder.ins().bitcast(types::F64, MemFlags::new(), val)
            } else if ret_type == types::I32 && val_type == types::F64 {
                // Expression returned f64, need i32 - truncate
                builder.ins().fcvt_to_sint(types::I32, val)
            } else if ret_type == types::I32 && val_type == types::I64 {
                // Expression returned i64, need i32 - truncate
                builder.ins().ireduce(types::I32, val)
            } else {
                val
            };
            builder.ins().return_(&[val]);
        }
        Stmt::If { condition, then_branch, else_branch } => {
            let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
            // Ensure cond_val is f64 for js_is_truthy
            let cond_val = ensure_f64(builder, cond_val_raw);
            // Use js_is_truthy for proper JavaScript truthiness semantics
            let truthy_func = extern_funcs.get("js_is_truthy")
                .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
            let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
            let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
            let truthy_result = builder.inst_results(truthy_call)[0];
            let zero_i32 = builder.ins().iconst(types::I32, 0);
            let cond_bool = builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32);

            let then_block = builder.create_block();
            let else_block = builder.create_block();
            let merge_block = builder.create_block();

            builder.ins().brif(cond_bool, then_block, &[], else_block, &[]);

            // Then branch
            builder.switch_to_block(then_block);
            builder.seal_block(then_block);
            for s in then_branch {
                compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, loop_ctx, boxed_vars)?;
            }
            let current = builder.current_block().unwrap();
            if !is_block_filled(builder, current) {
                builder.ins().jump(merge_block, &[]);
            }

            // Else branch
            builder.switch_to_block(else_block);
            builder.seal_block(else_block);
            if let Some(else_stmts) = else_branch {
                for s in else_stmts {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, loop_ctx, boxed_vars)?;
                }
            }
            let current = builder.current_block().unwrap();
            if !is_block_filled(builder, current) {
                builder.ins().jump(merge_block, &[]);
            }

            // Merge
            builder.switch_to_block(merge_block);
            builder.seal_block(merge_block);
        }
        Stmt::While { condition, body } => {
            // WHILE LOOP I32 COUNTER OPTIMIZATION
            // Detect patterns like: while (... && iter < limit) { ...; iter = iter + 1; }
            // If found, keep iter as native i32 for faster arithmetic and comparison

            // CSE: Find var * var expressions (squared variables)
            fn find_squared_vars_in_expr(expr: &Expr, vars: &mut HashSet<LocalId>) {
                match expr {
                    Expr::Binary { op: BinaryOp::Mul, left, right } => {
                        if let (Expr::LocalGet(l_id), Expr::LocalGet(r_id)) = (left.as_ref(), right.as_ref()) {
                            if l_id == r_id {
                                vars.insert(*l_id);
                            }
                        }
                        find_squared_vars_in_expr(left, vars);
                        find_squared_vars_in_expr(right, vars);
                    }
                    Expr::Binary { left, right, .. } |
                    Expr::Compare { left, right, .. } |
                    Expr::Logical { left, right, .. } => {
                        find_squared_vars_in_expr(left, vars);
                        find_squared_vars_in_expr(right, vars);
                    }
                    Expr::Unary { operand, .. } => find_squared_vars_in_expr(operand, vars),
                    Expr::LocalSet(_, val) => find_squared_vars_in_expr(val, vars),
                    _ => {}
                }
            }

            fn find_squared_vars_in_stmt(stmt: &Stmt, vars: &mut HashSet<LocalId>) {
                match stmt {
                    Stmt::Expr(e) => find_squared_vars_in_expr(e, vars),
                    Stmt::Let { init: Some(e), .. } => find_squared_vars_in_expr(e, vars),
                    _ => {}
                }
            }

            // Helper to find counter pattern in condition: returns (counter_id, limit_expr)
            fn find_counter_in_condition(cond: &Expr) -> Option<(LocalId, &Expr)> {
                match cond {
                    // Direct: iter < limit
                    Expr::Compare { op: CompareOp::Lt, left, right } => {
                        if let Expr::LocalGet(id) = left.as_ref() {
                            Some((*id, right.as_ref()))
                        } else { None }
                    }
                    // AND condition: ... && iter < limit
                    Expr::Logical { op: LogicalOp::And, left, right } => {
                        // Check right side first (more common pattern)
                        find_counter_in_condition(right)
                            .or_else(|| find_counter_in_condition(left))
                    }
                    _ => None,
                }
            }

            // Helper to check if body increments the counter: iter = iter + 1
            fn body_increments_counter(body: &[Stmt], counter_id: LocalId) -> bool {
                for stmt in body {
                    if let Stmt::Expr(expr) = stmt {
                        match expr {
                            Expr::LocalSet(id, value) if *id == counter_id => {
                                if let Expr::Binary { op: BinaryOp::Add, left, right } = value.as_ref() {
                                    if let Expr::LocalGet(left_id) = left.as_ref() {
                                        if *left_id == counter_id {
                                            if matches!(right.as_ref(), Expr::Integer(1)) {
                                                return true;
                                            }
                                        }
                                    }
                                }
                            }
                            Expr::Update { id, op: UpdateOp::Increment, .. } if *id == counter_id => {
                                return true;
                            }
                            _ => {}
                        }
                    }
                }
                false
            }

            // Try to detect and optimize integer counter
            let mut counter_opt: Option<(LocalId, Variable, Variable)> = None;  // (counter_id, i32_var, limit_var)
            let mut original_f64_var: Option<Variable> = None;

            if let Some((counter_id, limit_expr)) = find_counter_in_condition(condition) {
                if body_increments_counter(body, counter_id) {
                    // Get limit as i32
                    let limit_i32 = match limit_expr {
                        Expr::Integer(n) if *n >= 0 && *n <= i32::MAX as i64 => {
                            Some(builder.ins().iconst(types::I32, *n))
                        }
                        Expr::Number(n) if *n >= 0.0 && *n <= i32::MAX as f64 && n.fract() == 0.0 => {
                            Some(builder.ins().iconst(types::I32, *n as i64))
                        }
                        Expr::LocalGet(limit_id) => {
                            if let Some(limit_info) = locals.get(limit_id) {
                                if limit_info.is_i32 {
                                    Some(builder.use_var(limit_info.var))
                                } else {
                                    let limit_val = builder.use_var(limit_info.var);
                                    // Ensure f64 for fcvt_to_sint (value may be i64 if NaN-boxed)
                                    let limit_f64 = ensure_f64(builder, limit_val);
                                    Some(builder.ins().fcvt_to_sint(types::I32, limit_f64))
                                }
                            } else { None }
                        }
                        // GlobalGet (like MAX_ITER) - skip for now, complex to handle
                        _ => None,
                    };

                    if let Some(limit_val) = limit_i32 {
                        if let Some(counter_info) = locals.get(&counter_id) {
                            if !counter_info.is_i32 {
                                // Cache limit in a variable
                                let limit_var = Variable::new(*next_var);
                                *next_var += 1;
                                builder.declare_var(limit_var, types::I32);
                                builder.def_var(limit_var, limit_val);

                                // Create i32 variable for counter
                                let i32_var = Variable::new(*next_var);
                                *next_var += 1;
                                builder.declare_var(i32_var, types::I32);

                                // Initialize from current value (may be i64 if NaN-boxed)
                                let counter_val = builder.use_var(counter_info.var);
                                let counter_f64 = ensure_f64(builder, counter_val);
                                let counter_i32 = builder.ins().fcvt_to_sint(types::I32, counter_f64);
                                builder.def_var(i32_var, counter_i32);

                                // Store original f64 var for restoration
                                original_f64_var = Some(counter_info.var);

                                // Update LocalInfo to use i32 variable
                                if let Some(info) = locals.get_mut(&counter_id) {
                                    info.var = i32_var;
                                    info.is_i32 = true;
                                }

                                counter_opt = Some((counter_id, i32_var, limit_var));
                            }
                        }
                    }
                }
            }

            // CSE OPTIMIZATION: Detect var * var and var * other_var patterns
            // If found in both condition and body, cache at the start of each iteration

            // Helper to find product pairs (x * y where x != y)
            // Also detects patterns like (const * x) * y -> record (x, y)
            fn find_product_pairs_in_expr(expr: &Expr, pairs: &mut HashSet<(LocalId, LocalId)>) {
                match expr {
                    Expr::Binary { op: BinaryOp::Mul, left, right } => {
                        // Direct pattern: x * y
                        if let (Expr::LocalGet(l_id), Expr::LocalGet(r_id)) = (left.as_ref(), right.as_ref()) {
                            if l_id != r_id {
                                let pair = if l_id < r_id { (*l_id, *r_id) } else { (*r_id, *l_id) };
                                pairs.insert(pair);
                            }
                        }
                        // Pattern: (const * x) * y or (x * const) * y
                        if let Expr::Binary { op: BinaryOp::Mul, left: inner_left, right: inner_right } = left.as_ref() {
                            // (const * x) * y
                            if let (Expr::Number(_) | Expr::Integer(_), Expr::LocalGet(x_id)) = (inner_left.as_ref(), inner_right.as_ref()) {
                                if let Expr::LocalGet(y_id) = right.as_ref() {
                                    if x_id != y_id {
                                        let pair = if x_id < y_id { (*x_id, *y_id) } else { (*y_id, *x_id) };
                                        pairs.insert(pair);
                                    }
                                }
                            }
                            // (x * const) * y
                            if let (Expr::LocalGet(x_id), Expr::Number(_) | Expr::Integer(_)) = (inner_left.as_ref(), inner_right.as_ref()) {
                                if let Expr::LocalGet(y_id) = right.as_ref() {
                                    if x_id != y_id {
                                        let pair = if x_id < y_id { (*x_id, *y_id) } else { (*y_id, *x_id) };
                                        pairs.insert(pair);
                                    }
                                }
                            }
                        }
                        // Pattern: x * (const * y) or x * (y * const)
                        if let Expr::Binary { op: BinaryOp::Mul, left: inner_left, right: inner_right } = right.as_ref() {
                            // x * (const * y)
                            if let (Expr::Number(_) | Expr::Integer(_), Expr::LocalGet(y_id)) = (inner_left.as_ref(), inner_right.as_ref()) {
                                if let Expr::LocalGet(x_id) = left.as_ref() {
                                    if x_id != y_id {
                                        let pair = if x_id < y_id { (*x_id, *y_id) } else { (*y_id, *x_id) };
                                        pairs.insert(pair);
                                    }
                                }
                            }
                            // x * (y * const)
                            if let (Expr::LocalGet(y_id), Expr::Number(_) | Expr::Integer(_)) = (inner_left.as_ref(), inner_right.as_ref()) {
                                if let Expr::LocalGet(x_id) = left.as_ref() {
                                    if x_id != y_id {
                                        let pair = if x_id < y_id { (*x_id, *y_id) } else { (*y_id, *x_id) };
                                        pairs.insert(pair);
                                    }
                                }
                            }
                        }
                        find_product_pairs_in_expr(left, pairs);
                        find_product_pairs_in_expr(right, pairs);
                    }
                    Expr::Binary { left, right, .. } |
                    Expr::Compare { left, right, .. } |
                    Expr::Logical { left, right, .. } => {
                        find_product_pairs_in_expr(left, pairs);
                        find_product_pairs_in_expr(right, pairs);
                    }
                    Expr::Unary { operand, .. } => find_product_pairs_in_expr(operand, pairs),
                    Expr::LocalSet(_, val) => find_product_pairs_in_expr(val, pairs),
                    _ => {}
                }
            }

            fn find_product_pairs_in_stmt(stmt: &Stmt, pairs: &mut HashSet<(LocalId, LocalId)>) {
                match stmt {
                    Stmt::Expr(e) => find_product_pairs_in_expr(e, pairs),
                    Stmt::Let { init: Some(e), .. } => find_product_pairs_in_expr(e, pairs),
                    _ => {}
                }
            }

            let mut cse_squared_vars: Vec<LocalId> = Vec::new();
            let mut cse_product_pairs: Vec<(LocalId, LocalId)> = Vec::new();
            {
                let mut cond_squared: HashSet<LocalId> = HashSet::new();
                let mut body_squared: HashSet<LocalId> = HashSet::new();
                let mut cond_products: HashSet<(LocalId, LocalId)> = HashSet::new();
                let mut body_products: HashSet<(LocalId, LocalId)> = HashSet::new();

                find_squared_vars_in_expr(condition, &mut cond_squared);
                find_product_pairs_in_expr(condition, &mut cond_products);
                for stmt in body.iter() {
                    find_squared_vars_in_stmt(stmt, &mut body_squared);
                    find_product_pairs_in_stmt(stmt, &mut body_products);
                }

                // Find intersection - vars that are squared in both condition and body
                for var_id in cond_squared.intersection(&body_squared) {
                    cse_squared_vars.push(*var_id);
                }

                // Find product pairs used in body (for mandelbrot, x*y is only in body, not condition)
                // But we still benefit from caching it since it's recomputed after x and y change
                for pair in &body_products {
                    cse_product_pairs.push(*pair);
                }
            }

            // Create cache variables for CSE and set up squared_cache in LocalInfo
            for var_id in &cse_squared_vars {
                let cache_var = Variable::new(*next_var);
                *next_var += 1;
                builder.declare_var(cache_var, types::F64);
                // Initialize to 0 (will be computed at loop header)
                let zero = builder.ins().f64const(0.0);
                builder.def_var(cache_var, zero);

                if let Some(info) = locals.get_mut(var_id) {
                    info.squared_cache = Some(cache_var);
                }
            }

            // Create cache variables for product pairs and set up product_cache in LocalInfo
            let mut product_cache_vars: HashMap<(LocalId, LocalId), Variable> = HashMap::new();
            for (id1, id2) in &cse_product_pairs {
                let cache_var = Variable::new(*next_var);
                *next_var += 1;
                builder.declare_var(cache_var, types::F64);
                let zero = builder.ins().f64const(0.0);
                builder.def_var(cache_var, zero);

                product_cache_vars.insert((*id1, *id2), cache_var);

                // Set up product_cache in both variables' LocalInfo
                if let Some(info) = locals.get_mut(id1) {
                    if info.product_cache.is_none() {
                        info.product_cache = Some(HashMap::new());
                    }
                    if let Some(ref mut pc) = info.product_cache {
                        pc.insert(*id2, cache_var);
                    }
                }
                if let Some(info) = locals.get_mut(id2) {
                    if info.product_cache.is_none() {
                        info.product_cache = Some(HashMap::new());
                    }
                    if let Some(ref mut pc) = info.product_cache {
                        pc.insert(*id1, cache_var);
                    }
                }
            }

            let header_block = builder.create_block();
            let body_block = builder.create_block();
            let exit_block = builder.create_block();

            builder.ins().jump(header_block, &[]);

            // Header (condition check)
            builder.switch_to_block(header_block);

            // CSE: Compute squared values at start of each iteration
            for var_id in &cse_squared_vars {
                if let Some(info) = locals.get(var_id) {
                    if let Some(cache_var) = info.squared_cache {
                        let val = builder.use_var(info.var);
                        let squared = builder.ins().fmul(val, val);
                        builder.def_var(cache_var, squared);
                    }
                }
            }

            // CSE: Compute product pairs at start of each iteration
            for ((id1, id2), cache_var) in &product_cache_vars {
                if let (Some(info1), Some(info2)) = (locals.get(id1), locals.get(id2)) {
                    let val1 = builder.use_var(info1.var);
                    let val2 = builder.use_var(info2.var);
                    let product = builder.ins().fmul(val1, val2);
                    builder.def_var(*cache_var, product);
                }
            }

            // Compile condition - if we have i32 counter, optimize the counter < limit part
            if let Some((counter_id, i32_var, limit_var)) = counter_opt {
                // Compile condition with optimized i32 comparison for the counter
                let cond_bool = match condition {
                    // Direct: iter < limit - use icmp
                    Expr::Compare { op: CompareOp::Lt, left, .. } => {
                        if let Expr::LocalGet(id) = left.as_ref() {
                            if *id == counter_id {
                                let counter_i32 = builder.use_var(i32_var);
                                let limit_i32 = builder.use_var(limit_var);
                                builder.ins().icmp(IntCC::SignedLessThan, counter_i32, limit_i32)
                            } else {
                                let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                                let cond_val = ensure_f64(builder, cond_val_raw);
                                let truthy_func = extern_funcs.get("js_is_truthy")
                                    .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                                let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                                let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                                let truthy_result = builder.inst_results(truthy_call)[0];
                                let zero_i32 = builder.ins().iconst(types::I32, 0);
                                builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32)
                            }
                        } else {
                            let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                            let cond_val = ensure_f64(builder, cond_val_raw);
                            let truthy_func = extern_funcs.get("js_is_truthy")
                                .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                            let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                            let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                            let truthy_result = builder.inst_results(truthy_call)[0];
                            let zero_i32 = builder.ins().iconst(types::I32, 0);
                            builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32)
                        }
                    }
                    // AND condition: ... && iter < limit
                    Expr::Logical { op: LogicalOp::And, left, right } => {
                        if let Expr::Compare { op: CompareOp::Lt, left: cmp_left, .. } = right.as_ref() {
                            if let Expr::LocalGet(id) = cmp_left.as_ref() {
                                if *id == counter_id {
                                    // Compile left side normally - use js_is_truthy
                                    let left_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                                    let left_val = ensure_f64(builder, left_val_raw);
                                    let truthy_func = extern_funcs.get("js_is_truthy")
                                        .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                                    let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                                    let truthy_call = builder.ins().call(truthy_ref, &[left_val]);
                                    let truthy_result = builder.inst_results(truthy_call)[0];
                                    let zero_i32 = builder.ins().iconst(types::I32, 0);
                                    let left_bool = builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32);

                                    // Use icmp for counter comparison
                                    let counter_i32 = builder.use_var(i32_var);
                                    let limit_i32 = builder.use_var(limit_var);
                                    let right_bool = builder.ins().icmp(IntCC::SignedLessThan, counter_i32, limit_i32);

                                    // AND them together
                                    builder.ins().band(left_bool, right_bool)
                                } else {
                                    let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                                    let cond_val = ensure_f64(builder, cond_val_raw);
                                    let truthy_func = extern_funcs.get("js_is_truthy")
                                        .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                                    let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                                    let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                                    let truthy_result = builder.inst_results(truthy_call)[0];
                                    let zero_i32 = builder.ins().iconst(types::I32, 0);
                                    builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32)
                                }
                            } else {
                                let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                                let cond_val = ensure_f64(builder, cond_val_raw);
                                let truthy_func = extern_funcs.get("js_is_truthy")
                                    .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                                let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                                let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                                let truthy_result = builder.inst_results(truthy_call)[0];
                                let zero_i32 = builder.ins().iconst(types::I32, 0);
                                builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32)
                            }
                        } else {
                            let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                            let cond_val = ensure_f64(builder, cond_val_raw);
                            let truthy_func = extern_funcs.get("js_is_truthy")
                                .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                            let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                            let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                            let truthy_result = builder.inst_results(truthy_call)[0];
                            let zero_i32 = builder.ins().iconst(types::I32, 0);
                            builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32)
                        }
                    }
                    _ => {
                        let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                        let cond_val = ensure_f64(builder, cond_val_raw);
                        let truthy_func = extern_funcs.get("js_is_truthy")
                            .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                        let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                        let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                        let truthy_result = builder.inst_results(truthy_call)[0];
                        let zero_i32 = builder.ins().iconst(types::I32, 0);
                        builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32)
                    }
                };
                builder.ins().brif(cond_bool, body_block, &[], exit_block, &[]);
            } else {
                // Non-optimized path
                let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                let cond_val = ensure_f64(builder, cond_val_raw);
                let truthy_func = extern_funcs.get("js_is_truthy")
                    .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                let truthy_result = builder.inst_results(truthy_call)[0];
                let zero_i32 = builder.ins().iconst(types::I32, 0);
                let cond_bool = builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32);
                builder.ins().brif(cond_bool, body_block, &[], exit_block, &[]);
            }

            // Create loop context for break/continue
            let while_loop_ctx = LoopContext { exit_block, header_block, bounded_indices: HashMap::new() };

            // Body - with optional unrolling for CSE loops
            builder.switch_to_block(body_block);
            builder.seal_block(body_block);

            // WHILE LOOP UNROLLING: For loops with CSE, unroll by 8 to reduce branch overhead
            let should_unroll = !cse_squared_vars.is_empty() && body.len() >= 2;

            if should_unroll {
                // First iteration
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }

                // Create blocks for iterations 2-8
                let check2_block = builder.create_block();
                let body2_block = builder.create_block();
                let check3_block = builder.create_block();
                let body3_block = builder.create_block();
                let check4_block = builder.create_block();
                let body4_block = builder.create_block();
                let check5_block = builder.create_block();
                let body5_block = builder.create_block();
                let check6_block = builder.create_block();
                let body6_block = builder.create_block();
                let check7_block = builder.create_block();
                let body7_block = builder.create_block();
                let check8_block = builder.create_block();
                let body8_block = builder.create_block();

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(check2_block, &[]);
                }

                // Check and iteration 2
                builder.switch_to_block(check2_block);
                for var_id in &cse_squared_vars {
                    if let Some(info) = locals.get(var_id) {
                        if let Some(cache_var) = info.squared_cache {
                            let val = builder.use_var(info.var);
                            let squared = builder.ins().fmul(val, val);
                            builder.def_var(cache_var, squared);
                        }
                    }
                }
                for ((id1, id2), cache_var) in &product_cache_vars {
                    if let (Some(info1), Some(info2)) = (locals.get(id1), locals.get(id2)) {
                        let val1 = builder.use_var(info1.var);
                        let val2 = builder.use_var(info2.var);
                        let product = builder.ins().fmul(val1, val2);
                        builder.def_var(*cache_var, product);
                    }
                }
                let cond_val2_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                let cond_val2 = ensure_f64(builder, cond_val2_raw);
                let zero2 = builder.ins().f64const(0.0);
                let cond_bool2 = builder.ins().fcmp(FloatCC::NotEqual, cond_val2, zero2);
                builder.ins().brif(cond_bool2, body2_block, &[], exit_block, &[]);

                builder.switch_to_block(body2_block);
                builder.seal_block(body2_block);
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(check3_block, &[]);
                }

                // Check and iteration 3
                builder.switch_to_block(check3_block);
                for var_id in &cse_squared_vars {
                    if let Some(info) = locals.get(var_id) {
                        if let Some(cache_var) = info.squared_cache {
                            let val = builder.use_var(info.var);
                            let squared = builder.ins().fmul(val, val);
                            builder.def_var(cache_var, squared);
                        }
                    }
                }
                for ((id1, id2), cache_var) in &product_cache_vars {
                    if let (Some(info1), Some(info2)) = (locals.get(id1), locals.get(id2)) {
                        let val1 = builder.use_var(info1.var);
                        let val2 = builder.use_var(info2.var);
                        let product = builder.ins().fmul(val1, val2);
                        builder.def_var(*cache_var, product);
                    }
                }
                let cond_val3_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                let cond_val3 = ensure_f64(builder, cond_val3_raw);
                let zero3 = builder.ins().f64const(0.0);
                let cond_bool3 = builder.ins().fcmp(FloatCC::NotEqual, cond_val3, zero3);
                builder.ins().brif(cond_bool3, body3_block, &[], exit_block, &[]);

                builder.switch_to_block(body3_block);
                builder.seal_block(body3_block);
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(check4_block, &[]);
                }

                // Check and iteration 4
                builder.switch_to_block(check4_block);
                for var_id in &cse_squared_vars {
                    if let Some(info) = locals.get(var_id) {
                        if let Some(cache_var) = info.squared_cache {
                            let val = builder.use_var(info.var);
                            let squared = builder.ins().fmul(val, val);
                            builder.def_var(cache_var, squared);
                        }
                    }
                }
                for ((id1, id2), cache_var) in &product_cache_vars {
                    if let (Some(info1), Some(info2)) = (locals.get(id1), locals.get(id2)) {
                        let val1 = builder.use_var(info1.var);
                        let val2 = builder.use_var(info2.var);
                        let product = builder.ins().fmul(val1, val2);
                        builder.def_var(*cache_var, product);
                    }
                }
                let cond_val4_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                let cond_val4 = ensure_f64(builder, cond_val4_raw);
                let zero4 = builder.ins().f64const(0.0);
                let cond_bool4 = builder.ins().fcmp(FloatCC::NotEqual, cond_val4, zero4);
                builder.ins().brif(cond_bool4, body4_block, &[], exit_block, &[]);

                builder.switch_to_block(body4_block);
                builder.seal_block(body4_block);
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(check5_block, &[]);
                }

                // Check and iteration 5
                builder.switch_to_block(check5_block);
                for var_id in &cse_squared_vars {
                    if let Some(info) = locals.get(var_id) {
                        if let Some(cache_var) = info.squared_cache {
                            let val = builder.use_var(info.var);
                            let squared = builder.ins().fmul(val, val);
                            builder.def_var(cache_var, squared);
                        }
                    }
                }
                for ((id1, id2), cache_var) in &product_cache_vars {
                    if let (Some(info1), Some(info2)) = (locals.get(id1), locals.get(id2)) {
                        let val1 = builder.use_var(info1.var);
                        let val2 = builder.use_var(info2.var);
                        let product = builder.ins().fmul(val1, val2);
                        builder.def_var(*cache_var, product);
                    }
                }
                let cond_val5_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                let cond_val5 = ensure_f64(builder, cond_val5_raw);
                let zero5 = builder.ins().f64const(0.0);
                let cond_bool5 = builder.ins().fcmp(FloatCC::NotEqual, cond_val5, zero5);
                builder.ins().brif(cond_bool5, body5_block, &[], exit_block, &[]);

                builder.switch_to_block(body5_block);
                builder.seal_block(body5_block);
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(check6_block, &[]);
                }

                // Check and iteration 6
                builder.switch_to_block(check6_block);
                for var_id in &cse_squared_vars {
                    if let Some(info) = locals.get(var_id) {
                        if let Some(cache_var) = info.squared_cache {
                            let val = builder.use_var(info.var);
                            let squared = builder.ins().fmul(val, val);
                            builder.def_var(cache_var, squared);
                        }
                    }
                }
                for ((id1, id2), cache_var) in &product_cache_vars {
                    if let (Some(info1), Some(info2)) = (locals.get(id1), locals.get(id2)) {
                        let val1 = builder.use_var(info1.var);
                        let val2 = builder.use_var(info2.var);
                        let product = builder.ins().fmul(val1, val2);
                        builder.def_var(*cache_var, product);
                    }
                }
                let cond_val6_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                let cond_val6 = ensure_f64(builder, cond_val6_raw);
                let zero6 = builder.ins().f64const(0.0);
                let cond_bool6 = builder.ins().fcmp(FloatCC::NotEqual, cond_val6, zero6);
                builder.ins().brif(cond_bool6, body6_block, &[], exit_block, &[]);

                builder.switch_to_block(body6_block);
                builder.seal_block(body6_block);
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(check7_block, &[]);
                }

                // Check and iteration 7
                builder.switch_to_block(check7_block);
                for var_id in &cse_squared_vars {
                    if let Some(info) = locals.get(var_id) {
                        if let Some(cache_var) = info.squared_cache {
                            let val = builder.use_var(info.var);
                            let squared = builder.ins().fmul(val, val);
                            builder.def_var(cache_var, squared);
                        }
                    }
                }
                for ((id1, id2), cache_var) in &product_cache_vars {
                    if let (Some(info1), Some(info2)) = (locals.get(id1), locals.get(id2)) {
                        let val1 = builder.use_var(info1.var);
                        let val2 = builder.use_var(info2.var);
                        let product = builder.ins().fmul(val1, val2);
                        builder.def_var(*cache_var, product);
                    }
                }
                let cond_val7_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                let cond_val7 = ensure_f64(builder, cond_val7_raw);
                let zero7 = builder.ins().f64const(0.0);
                let cond_bool7 = builder.ins().fcmp(FloatCC::NotEqual, cond_val7, zero7);
                builder.ins().brif(cond_bool7, body7_block, &[], exit_block, &[]);

                builder.switch_to_block(body7_block);
                builder.seal_block(body7_block);
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(check8_block, &[]);
                }

                // Check and iteration 8
                builder.switch_to_block(check8_block);
                for var_id in &cse_squared_vars {
                    if let Some(info) = locals.get(var_id) {
                        if let Some(cache_var) = info.squared_cache {
                            let val = builder.use_var(info.var);
                            let squared = builder.ins().fmul(val, val);
                            builder.def_var(cache_var, squared);
                        }
                    }
                }
                for ((id1, id2), cache_var) in &product_cache_vars {
                    if let (Some(info1), Some(info2)) = (locals.get(id1), locals.get(id2)) {
                        let val1 = builder.use_var(info1.var);
                        let val2 = builder.use_var(info2.var);
                        let product = builder.ins().fmul(val1, val2);
                        builder.def_var(*cache_var, product);
                    }
                }
                let cond_val8_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
                let cond_val8 = ensure_f64(builder, cond_val8_raw);
                let zero8 = builder.ins().f64const(0.0);
                let cond_bool8 = builder.ins().fcmp(FloatCC::NotEqual, cond_val8, zero8);
                builder.ins().brif(cond_bool8, body8_block, &[], exit_block, &[]);

                builder.switch_to_block(body8_block);
                builder.seal_block(body8_block);
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }

                // Seal check blocks (now that all predecessors are known)
                builder.seal_block(check2_block);
                builder.seal_block(check3_block);
                builder.seal_block(check4_block);
                builder.seal_block(check5_block);
                builder.seal_block(check6_block);
                builder.seal_block(check7_block);
                builder.seal_block(check8_block);

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(header_block, &[]);
                }
            } else {
                // Normal (non-unrolled) body
                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&while_loop_ctx), boxed_vars)?;
                }
                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(header_block, &[]);
                }
            }

            // Now seal header - all predecessors (entry jump + back-edge) are known
            builder.seal_block(header_block);

            // Exit
            builder.switch_to_block(exit_block);
            builder.seal_block(exit_block);

            // Restore f64 variable after loop
            if let Some((counter_id, i32_var, _)) = counter_opt {
                if let Some(orig_f64_var) = original_f64_var {
                    // Convert final i32 value back to f64
                    let final_i32 = builder.use_var(i32_var);
                    let final_f64 = builder.ins().fcvt_from_sint(types::F64, final_i32);
                    builder.def_var(orig_f64_var, final_f64);

                    // Restore LocalInfo
                    if let Some(info) = locals.get_mut(&counter_id) {
                        info.var = orig_f64_var;
                        info.is_i32 = false;
                    }
                }
            }

            // Clear CSE squared_cache after loop
            for var_id in &cse_squared_vars {
                if let Some(info) = locals.get_mut(var_id) {
                    info.squared_cache = None;
                }
            }
        }
        Stmt::For { init, condition, update, body } => {
            // Execute init statement (if any) in current block (outside loop context)
            if let Some(init_stmt) = init {
                compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, init_stmt, this_ctx, loop_ctx, boxed_vars)?;
            }

            // LOOP COUNTER OPTIMIZATION: Detect patterns `i < arr.length` or `i < CONSTANT`
            // If found, use native i32 for loop counter to eliminate f64 conversion overhead
            let mut bounded_indices: HashMap<LocalId, (LocalId, Value)> = HashMap::new();
            let mut cached_length_var: Option<Variable> = None;  // Stores i32 limit
            let mut bce_index_var: Option<LocalId> = None;
            let mut bce_array_var: Option<LocalId> = None;
            let mut bce_constant_limit: Option<i64> = None;  // For constant bound BCE
            let mut original_f64_var: Option<Variable> = None;  // Store original f64 var for restoration

            if let Some(cond) = condition {
                // Check for pattern: Compare { op: Lt, left: LocalGet(i), right: ... }
                if let Expr::Compare { left, op: CompareOp::Lt, right } = cond {
                    if let Expr::LocalGet(index_id) = left.as_ref() {
                        let idx_var = locals.get(index_id).map(|i| i.var);

                        // Try to get the limit as i32
                        let limit_i32: Option<Value> = match right.as_ref() {
                            // Pattern 1: i < arr.length
                            Expr::PropertyGet { object, property } if property == "length" => {
                                if let Expr::LocalGet(array_id) = object.as_ref() {
                                    if let Some(arr_info) = locals.get(array_id) {
                                        if arr_info.is_array {
                                            let arr_val = builder.use_var(arr_info.var);
                                            // For union-typed arrays (from await, etc.), the value is NaN-boxed
                                            // and needs pointer extraction. For non-union arrays, it's a raw pointer.
                                            let arr_ptr = if arr_info.is_union || arr_info.is_mixed_array {
                                                // Use js_nanbox_get_pointer to extract the pointer
                                                let arr_f64 = ensure_f64(builder, arr_val);
                                                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                                                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                                                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                                                let call = builder.ins().call(get_ptr_ref, &[arr_f64]);
                                                builder.inst_results(call)[0]
                                            } else {
                                                ensure_i64(builder, arr_val)
                                            };
                                            let length_i32 = builder.ins().load(types::I32, MemFlags::new(), arr_ptr, 0);
                                            bce_array_var = Some(*array_id);
                                            Some(length_i32)
                                        } else { None }
                                    } else { None }
                                } else { None }
                            }
                            // Pattern 2: i < INTEGER_CONSTANT
                            Expr::Integer(n) if *n >= 0 && *n <= i32::MAX as i64 => {
                                bce_constant_limit = Some(*n);
                                Some(builder.ins().iconst(types::I32, *n))
                            }
                            // Pattern 3: i < FLOAT_CONSTANT (if it's a whole number)
                            Expr::Number(f) if *f >= 0.0 && *f <= i32::MAX as f64 && f.fract() == 0.0 => {
                                bce_constant_limit = Some(*f as i64);
                                Some(builder.ins().iconst(types::I32, *f as i64))
                            }
                            // Pattern 4: i < other_local (if it's an integer variable)
                            Expr::LocalGet(limit_id) => {
                                if let Some(limit_info) = locals.get(limit_id) {
                                    if limit_info.is_i32 {
                                        Some(builder.use_var(limit_info.var))
                                    } else if limit_info.is_integer {
                                        // Convert to i32 once before the loop (may be i64 if NaN-boxed)
                                        let limit_val = builder.use_var(limit_info.var);
                                        let limit_f64 = ensure_f64(builder, limit_val);
                                        Some(builder.ins().fcvt_to_sint(types::I32, limit_f64))
                                    } else { None }
                                } else { None }
                            }
                            _ => None,
                        };

                        if let (Some(idx_v), Some(limit_val)) = (idx_var, limit_i32) {
                            // Check if the index variable is already i32
                            let idx_already_i32 = locals.get(index_id).map(|i| i.is_i32).unwrap_or(false);

                            if idx_already_i32 {
                                // Variable is already i32, just cache the limit
                                let len_var = Variable::new(*next_var);
                                *next_var += 1;
                                builder.declare_var(len_var, types::I32);
                                builder.def_var(len_var, limit_val);

                                cached_length_var = Some(len_var);
                                bce_index_var = Some(*index_id);
                                if let Some(arr_id) = bce_array_var {
                                    bounded_indices.insert(*index_id, (arr_id, limit_val));
                                }
                                // No need to store original_f64_var since it's already i32
                            } else {
                                // Found optimizable pattern! Use native i32 for loop counter

                                // Cache limit as i32 variable
                                let len_var = Variable::new(*next_var);
                                *next_var += 1;
                                builder.declare_var(len_var, types::I32);
                                builder.def_var(len_var, limit_val);

                                // Create new i32 variable to replace the f64 one
                                let i32_var = Variable::new(*next_var);
                                *next_var += 1;
                                builder.declare_var(i32_var, types::I32);

                                // Initialize from current value (may be i64 if NaN-boxed)
                                let idx_val = builder.use_var(idx_v);
                                let idx_f64 = ensure_f64(builder, idx_val);
                                let idx_i32 = builder.ins().fcvt_to_sint(types::I32, idx_f64);
                                builder.def_var(i32_var, idx_i32);

                                cached_length_var = Some(len_var);
                                bce_index_var = Some(*index_id);
                                if let Some(arr_id) = bce_array_var {
                                    bounded_indices.insert(*index_id, (arr_id, limit_val));
                                }

                                // Store original f64 var and update LocalInfo to use i32 variable
                                original_f64_var = Some(idx_v);
                                if let Some(idx_info) = locals.get_mut(index_id) {
                                    idx_info.var = i32_var;      // Replace variable
                                    idx_info.is_i32 = true;      // Mark as i32
                                    idx_info.i32_shadow = None;  // No longer need shadow
                                }
                            }
                        }
                    }
                }
            }

            // LOOP UNROLLING: Unroll by factor of 8 when profitable
            // Conditions: BCE optimization active, no break/continue in body, update is simple i++ or i = i + constant
            const UNROLL_FACTOR: i64 = 8;

            // Detect loop stride: 1 for i++, N for i = i + N
            let loop_stride: Option<i64> = update.as_ref().and_then(|u| {
                match u {
                    // i++ has stride 1
                    Expr::Update { op: UpdateOp::Increment, .. } => Some(1),
                    // i = i + constant has stride = constant
                    Expr::LocalSet(set_id, value) => {
                        if let Expr::Binary { op: BinaryOp::Add, left, right } = value.as_ref() {
                            if let Expr::LocalGet(get_id) = left.as_ref() {
                                if get_id == set_id {
                                    match right.as_ref() {
                                        Expr::Integer(n) if *n > 0 && *n <= 1000 => Some(*n),
                                        _ => None,
                                    }
                                } else { None }
                            } else { None }
                        } else { None }
                    }
                    _ => None,
                }
            });

            let can_unroll = cached_length_var.is_some()
                && bce_index_var.is_some()
                && !contains_loop_control(body)
                && loop_stride.is_some();

            if can_unroll {
                // UNROLLED LOOP: Main loop (8 iterations at a time) + Remainder loop
                let len_var = cached_length_var.unwrap();
                let idx_id = bce_index_var.unwrap();
                let stride = loop_stride.unwrap();

                // PATTERN DETECTION: Check what optimizations we can apply
                // Pattern 1: x = x + constant -> strength reduction
                // Pattern 2: x = x + arr[i] -> SIMD multiple accumulators
                // Pattern 3: x = x + f(i) -> scalar multiple accumulators (generic)
                // Pattern 4: obj.field = obj.field + constant -> field strength reduction
                // Pattern 5: const p = new Point(i, j); sum = sum + p.x + p.y; -> escape analysis/scalar replacement
                let mut use_strength_reduction: Option<(LocalId, f64)> = None;  // (sum_var, constant)
                let mut use_multi_accum: Option<(LocalId, LocalId)> = None;  // (sum_var, arr_var)
                let mut use_generic_accum: Option<LocalId> = None;  // sum_var for generic pattern
                let mut use_field_strength_reduction: Option<(LocalId, String, f64)> = None;  // (obj_id, property, constant)
                // Pattern 5: escape analysis - (obj_id, class_name, field_args: Vec<(field_name, arg_expr)>)
                let mut use_scalar_replacement: Option<(LocalId, String, Vec<(String, Expr)>)> = None;

                // Helper to check if expression references a specific local
                fn expr_references_local(expr: &Expr, target: LocalId) -> bool {
                    match expr {
                        Expr::LocalGet(id) | Expr::LocalSet(id, _) => *id == target,
                        Expr::Update { id, .. } => *id == target,
                        Expr::Binary { left, right, .. } | Expr::Logical { left, right, .. } |
                        Expr::Compare { left, right, .. } => {
                            expr_references_local(left, target) || expr_references_local(right, target)
                        }
                        Expr::Unary { operand, .. } => expr_references_local(operand, target),
                        Expr::Conditional { condition, then_expr, else_expr } => {
                            expr_references_local(condition, target) ||
                            expr_references_local(then_expr, target) ||
                            expr_references_local(else_expr, target)
                        }
                        Expr::Call { callee, args, .. } => {
                            expr_references_local(callee, target) ||
                            args.iter().any(|a| expr_references_local(a, target))
                        }
                        Expr::IndexGet { object, index } => {
                            expr_references_local(object, target) || expr_references_local(index, target)
                        }
                        Expr::PropertyGet { object, .. } => expr_references_local(object, target),
                        _ => false,
                    }
                }

                if body.len() == 1 {
                    if let Stmt::Expr(expr) = &body[0] {
                        if let Expr::LocalSet(set_id, value) = expr {
                            if let Expr::Binary { op: BinaryOp::Add, left, right } = value.as_ref() {
                                if let Expr::LocalGet(get_id) = left.as_ref() {
                                    if get_id == set_id {
                                        // Pattern 1: x = x + constant
                                        if let Some(c) = match right.as_ref() {
                                            Expr::Integer(n) => Some(*n as f64),
                                            Expr::Number(f) => Some(*f),
                                            _ => None,
                                        } {
                                            use_strength_reduction = Some((*set_id, c));
                                        }

                                        // Pattern 2: x = x + arr[i]
                                        if use_strength_reduction.is_none() {
                                            if let Expr::IndexGet { object, index } = right.as_ref() {
                                                if let (Expr::LocalGet(arr_id), Expr::LocalGet(index_id)) = (object.as_ref(), index.as_ref()) {
                                                    if index_id == &idx_id {
                                                        if let Some(arr_info) = locals.get(arr_id) {
                                                            if arr_info.is_array {
                                                                use_multi_accum = Some((*set_id, *arr_id));
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }

                                        // Pattern 3: x = x + f(i) where f(i) doesn't reference x
                                        // This is a generic accumulation pattern
                                        if use_strength_reduction.is_none() && use_multi_accum.is_none() {
                                            if !expr_references_local(right, *set_id) {
                                                use_generic_accum = Some(*set_id);
                                            }
                                        }
                                    }
                                }
                            }
                        // Pattern 4: obj.field = obj.field + constant
                        } else if let Expr::PropertySet { object, property, value } = expr {
                            if let Expr::LocalGet(obj_id) = object.as_ref() {
                                if let Expr::Binary { op: BinaryOp::Add, left, right } = value.as_ref() {
                                    if let Expr::PropertyGet { object: get_obj, property: get_prop } = left.as_ref() {
                                        if let Expr::LocalGet(get_obj_id) = get_obj.as_ref() {
                                            if get_obj_id == obj_id && get_prop == property {
                                                // Pattern: obj.field = obj.field + constant
                                                if let Some(c) = match right.as_ref() {
                                                    Expr::Integer(n) => Some(*n as f64),
                                                    Expr::Number(f) => Some(*f),
                                                    _ => None,
                                                } {
                                                    use_field_strength_reduction = Some((*obj_id, property.clone(), c));
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Pattern 5: Escape analysis for non-escaping objects
                // Pattern: const p = new Point(i, i+1); sum = sum + p.x + p.y;
                // Detect: 2 statements, first is Let with New, second only uses the object via PropertyGet
                if body.len() == 2 {
                    if let Stmt::Let { id: obj_id, init: Some(init_expr), .. } = &body[0] {
                        if let Expr::New { class_name, args, .. } = init_expr {
                            // Check if this class exists and we can map args to fields
                            if let Some(class_meta) = classes.get(class_name) {
                                // Check if constructor just assigns args to fields in order
                                // Most simple Point-like classes do: constructor(x, y) { this.x = x; this.y = y; }
                                // For now, assume args map to fields in field order
                                let field_names: Vec<String> = class_meta.field_indices.iter()
                                    .map(|(name, idx)| (name.clone(), *idx))
                                    .collect::<Vec<_>>()
                                    .into_iter()
                                    .filter(|(_, idx)| (*idx as usize) < args.len())
                                    .map(|(name, _)| name)
                                    .collect();

                                if field_names.len() == args.len() {
                                    // Helper to check if object only used via PropertyGet
                                    fn expr_only_propertyget(expr: &Expr, obj_id: LocalId) -> bool {
                                        match expr {
                                            // Object is used via PropertyGet - OK
                                            Expr::PropertyGet { object, .. } => {
                                                if let Expr::LocalGet(id) = object.as_ref() {
                                                    if *id == obj_id { return true; }
                                                }
                                                expr_only_propertyget(object, obj_id)
                                            }
                                            // Direct use of object - NOT OK (escapes)
                                            Expr::LocalGet(id) => *id != obj_id,
                                            // Recurse through expressions
                                            Expr::Binary { left, right, .. } |
                                            Expr::Compare { left, right, .. } |
                                            Expr::Logical { left, right, .. } => {
                                                expr_only_propertyget(left, obj_id) && expr_only_propertyget(right, obj_id)
                                            }
                                            Expr::LocalSet(_, val) => expr_only_propertyget(val, obj_id),
                                            Expr::Unary { operand, .. } => expr_only_propertyget(operand, obj_id),
                                            Expr::Call { args, .. } => {
                                                // If object is passed to a function, it escapes
                                                args.iter().all(|a| expr_only_propertyget(a, obj_id))
                                            }
                                            _ => true,
                                        }
                                    }

                                    fn stmt_only_propertyget(stmt: &Stmt, obj_id: LocalId) -> bool {
                                        match stmt {
                                            Stmt::Expr(e) => expr_only_propertyget(e, obj_id),
                                            _ => false,
                                        }
                                    }

                                    // Check if second statement only uses object via PropertyGet
                                    if stmt_only_propertyget(&body[1], *obj_id) {
                                        // Map field names to their argument expressions
                                        let mut field_args: Vec<(String, Expr)> = Vec::new();
                                        for (name, idx) in &class_meta.field_indices {
                                            if (*idx as usize) < args.len() {
                                                field_args.push((name.clone(), args[*idx as usize].clone()));
                                            }
                                        }

                                        use_scalar_replacement = Some((*obj_id, class_name.clone(), field_args));
                                    }
                                }
                            }
                        }
                    }
                }

                // Create blocks for main loop
                let main_header = builder.create_block();
                let main_body = builder.create_block();
                let main_update = builder.create_block();

                // Create blocks for remainder loop
                let rem_combine = builder.create_block();  // Combine accumulators (runs once)
                let rem_header = builder.create_block();   // Check condition (loop header)
                let rem_body = builder.create_block();
                let rem_update = builder.create_block();

                let exit_block = builder.create_block();

                // SIMD VECTORIZATION: Create F64X2 vector accumulators (4 vectors = 8 f64 values)
                // Using 128-bit vectors (F64X2) for portable SIMD across x86-64 and ARM64
                let f64x2_type = types::F64X2;
                let mut simd_accumulators: Option<([Variable; 4], LocalId)> = None;
                if let Some((sum_id, arr_id)) = use_multi_accum {
                    if let Some(_sum_info) = locals.get(&sum_id) {
                        // Create 4 vector accumulator variables (4 x F64X2 = 8 f64 values)
                        let mut vec_accs = [Variable::new(0); 4];
                        for i in 0..4 {
                            vec_accs[i] = Variable::new(*next_var);
                            *next_var += 1;
                            builder.declare_var(vec_accs[i], f64x2_type);
                        }

                        // Initialize all vector accumulators to [0.0, 0.0]
                        let zero = builder.ins().f64const(0.0);
                        let zero_vec = builder.ins().splat(f64x2_type, zero);
                        for acc in &vec_accs {
                            builder.def_var(*acc, zero_vec);
                        }

                        simd_accumulators = Some((vec_accs, arr_id));
                    }
                }

                // GENERIC ACCUMULATORS: Create 8 scalar f64 accumulators for Pattern 3
                // This breaks the dependency chain for x = x + f(i) patterns
                let mut generic_accumulators: Option<([Variable; 8], LocalId, Variable)> = None;  // (accs, sum_id, original_var)
                if let Some(sum_id) = use_generic_accum {
                    if let Some(sum_info) = locals.get(&sum_id) {
                        // Create 8 scalar accumulator variables
                        let mut accs = [Variable::new(0); 8];
                        for i in 0..8 {
                            accs[i] = Variable::new(*next_var);
                            *next_var += 1;
                            builder.declare_var(accs[i], types::F64);
                        }

                        // Initialize all accumulators to 0
                        let zero = builder.ins().f64const(0.0);
                        for acc in &accs {
                            builder.def_var(*acc, zero);
                        }

                        generic_accumulators = Some((accs, sum_id, sum_info.var));
                    }
                }

                // SCALAR REPLACEMENT: Create scalar variables for each field (Pattern 5)
                // This eliminates heap allocation by keeping field values in registers
                let mut scalar_replacement_vars: Option<(LocalId, HashMap<String, Variable>)> = None;
                if let Some((obj_id, ref _class_name, ref field_args)) = use_scalar_replacement {
                    let mut field_vars: HashMap<String, Variable> = HashMap::new();

                    for (field_name, _arg_expr) in field_args {
                        let var = Variable::new(*next_var);
                        *next_var += 1;
                        builder.declare_var(var, types::F64);
                        // Initialize to 0 (will be set in loop body)
                        let zero = builder.ins().f64const(0.0);
                        builder.def_var(var, zero);
                        field_vars.insert(field_name.clone(), var);
                    }

                    // Create a "fake" LocalInfo for the object that uses scalar fields
                    // This allows PropertyGet to use the scalar variables instead of heap access
                    let dummy_var = Variable::new(*next_var);
                    *next_var += 1;
                    builder.declare_var(dummy_var, types::F64);
                    let zero = builder.ins().f64const(0.0);
                    builder.def_var(dummy_var, zero);

                    locals.insert(obj_id, LocalInfo {
                        var: dummy_var,
                        name: None, // Scalar replacement uses internal variables
                        class_name: Some(_class_name.clone()),
                        type_args: Vec::new(),
                        is_pointer: false,
                        is_array: false,
                        is_string: false,
                        is_bigint: false,
                        is_closure: false,
                        is_boxed: false,
                        is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: false,
                        is_mixed_array: false,
                        is_integer: false,
                        is_integer_array: false,
                        is_i32: false,
                        i32_shadow: None,
                        bounded_by_array: None,
                        bounded_by_constant: None,
                        scalar_fields: Some(field_vars.clone()),
                        squared_cache: None, product_cache: None,
                    });

                    scalar_replacement_vars = Some((obj_id, field_vars));
                }

                // Jump to main loop
                builder.ins().jump(main_header, &[]);

                // === MAIN LOOP (processes UNROLL_FACTOR iterations at a time) ===
                builder.switch_to_block(main_header);

                // Check: i + UNROLL_FACTOR * stride <= limit
                let idx_info = locals.get(&idx_id).ok_or_else(|| anyhow!("Index variable not found"))?;
                let idx_i32 = builder.use_var(idx_info.var);
                let length_i32 = builder.use_var(len_var);
                let idx_plus_unroll = builder.ins().iadd_imm(idx_i32, UNROLL_FACTOR * stride);
                let can_do_unroll = builder.ins().icmp(IntCC::SignedLessThanOrEqual, idx_plus_unroll, length_i32);
                builder.ins().brif(can_do_unroll, main_body, &[], rem_combine, &[]);

                // Main loop context
                let main_loop_ctx = LoopContext { exit_block, header_block: main_update, bounded_indices: bounded_indices.clone() };

                // Set BCE for loop counter
                if let Some(arr_id) = bce_array_var {
                    if let Some(idx_info) = locals.get_mut(&idx_id) {
                        idx_info.bounded_by_array = Some(arr_id);
                    }
                }

                // Main loop body
                builder.switch_to_block(main_body);
                builder.seal_block(main_body);

                let mut optimized = false;

                // OPTIMIZATION 1: Strength reduction for x = x + constant
                if let Some((sum_id, constant)) = use_strength_reduction {
                    let combined_const = constant * (UNROLL_FACTOR as f64);
                    if let Some(info) = locals.get(&sum_id) {
                        let current = builder.use_var(info.var);
                        let add_val = builder.ins().f64const(combined_const);
                        let new_val = builder.ins().fadd(current, add_val);
                        builder.def_var(info.var, new_val);
                        optimized = true;
                    }
                }

                // OPTIMIZATION 2: SIMD vector operations for x = x + arr[i]
                if let Some((vec_accs, arr_id)) = simd_accumulators.as_ref() {
                    if let Some(arr_info) = locals.get(arr_id) {
                        let idx_info = locals.get(&idx_id).ok_or_else(|| anyhow!("Index variable not found"))?;

                        // Get array data pointer (skip 8-byte header)
                        let arr_val = builder.use_var(arr_info.var);
                        let arr_ptr = ensure_i64(builder, arr_val);
                        let data_ptr = builder.ins().iadd_imm(arr_ptr, 8);

                        // Get current index and compute base byte offset
                        let idx_i32 = builder.use_var(idx_info.var);
                        let base_byte_offset = builder.ins().ishl_imm(idx_i32, 3); // idx * 8 bytes
                        let base_byte_offset_i64 = builder.ins().sextend(types::I64, base_byte_offset);
                        let base_ptr = builder.ins().iadd(data_ptr, base_byte_offset_i64);

                        // Load 4 pairs of elements (8 total) using SIMD vector loads
                        // Each vector load gets 2 consecutive f64 values (16 bytes)
                        for k in 0..4 {
                            // Calculate pointer for this vector (k * 16 bytes)
                            let vec_ptr = if k == 0 {
                                base_ptr
                            } else {
                                builder.ins().iadd_imm(base_ptr, (k * 16) as i64)
                            };

                            // Vector load: load 2 f64 values at once
                            let vec_val = builder.ins().load(f64x2_type, MemFlags::new(), vec_ptr, 0);

                            // Vector add to accumulator
                            let acc_var = vec_accs[k as usize];
                            let acc_val = builder.use_var(acc_var);
                            let new_acc = builder.ins().fadd(acc_val, vec_val);
                            builder.def_var(acc_var, new_acc);
                        }
                        optimized = true;
                    }
                }

                // OPTIMIZATION 4: Field strength reduction for obj.field = obj.field + constant
                if let Some((obj_id, ref property, constant)) = use_field_strength_reduction {
                    if let Some(obj_info) = locals.get(&obj_id) {
                        let combined_const = constant * (UNROLL_FACTOR as f64);

                        // Get the object pointer
                        let obj_f64 = builder.use_var(obj_info.var);
                        let obj_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), obj_f64);

                        // Look up field offset from class metadata
                        if let Some(class_name) = &obj_info.class_name {
                            if let Some(class_meta) = classes.get(class_name) {
                                if let Some(&field_idx) = class_meta.field_indices.get(property) {
                                    // ObjectHeader is 24 bytes, fields start after that
                                    let field_offset = 24 + (field_idx as i32) * 8;

                                    // Load current value
                                    let current_val = builder.ins().load(types::F64, MemFlags::new(), obj_ptr, field_offset);

                                    // Add combined constant
                                    let add_val = builder.ins().f64const(combined_const);
                                    let new_val = builder.ins().fadd(current_val, add_val);

                                    // Store back
                                    builder.ins().store(MemFlags::new(), new_val, obj_ptr, field_offset);

                                    optimized = true;
                                }
                            }
                        }
                    }
                }

                // OPTIMIZATION 5: Scalar replacement for non-escaping objects
                // Skip allocation, compile constructor args directly to scalar variables
                if let Some((obj_id, ref field_vars)) = scalar_replacement_vars.as_ref() {
                    if let Some((_obj_id, _class_name, ref field_args)) = use_scalar_replacement.as_ref() {
                        for unroll_iter in 0..UNROLL_FACTOR {
                            // Initialize scalar fields from constructor args
                            for (field_name, arg_expr) in field_args {
                                if let Some(var) = field_vars.get(field_name) {
                                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg_expr, this_ctx)?;
                                    builder.def_var(*var, val);
                                }
                            }

                            // Compile only the second statement (the one that uses the object)
                            // The first statement (Let with New) is replaced by scalar initialization above
                            if body.len() >= 2 {
                                compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, &body[1], this_ctx, Some(&main_loop_ctx), boxed_vars)?;
                            }

                            // Increment loop counter by stride (except for last iteration)
                            if unroll_iter < UNROLL_FACTOR - 1 {
                                let idx_info = locals.get(&idx_id).ok_or_else(|| anyhow!("Index variable not found"))?;
                                let current = builder.use_var(idx_info.var);
                                let incremented = builder.ins().iadd_imm(current, stride);
                                builder.def_var(idx_info.var, incremented);
                            }
                        }
                        optimized = true;
                    }
                }

                // OPTIMIZATION 3: Generic accumulator pattern for x = x + f(i)
                // Compile body 8 times, but redirect sum writes to separate accumulators
                if let Some((ref accs, sum_id, original_sum_var)) = generic_accumulators {
                    for unroll_iter in 0..UNROLL_FACTOR {
                        // Temporarily redirect sum variable to accumulator[k]
                        let acc_var = accs[unroll_iter as usize];
                        if let Some(sum_info) = locals.get_mut(&sum_id) {
                            sum_info.var = acc_var;
                        }

                        // Compile the body (writes to accumulator instead of sum)
                        for s in body {
                            compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&main_loop_ctx), boxed_vars)?;
                        }

                        // Increment loop counter by stride (except for last iteration - update block handles it)
                        if unroll_iter < UNROLL_FACTOR - 1 {
                            let idx_info = locals.get(&idx_id).ok_or_else(|| anyhow!("Index variable not found"))?;
                            let current = builder.use_var(idx_info.var);
                            let incremented = builder.ins().iadd_imm(current, stride);
                            builder.def_var(idx_info.var, incremented);
                        }
                    }

                    // Restore original sum variable
                    if let Some(sum_info) = locals.get_mut(&sum_id) {
                        sum_info.var = original_sum_var;
                    }

                    optimized = true;
                }

                if optimized && generic_accumulators.is_none() && scalar_replacement_vars.is_none() {
                    // Increment loop counter by (UNROLL_FACTOR - 1) * stride (update block does +stride)
                    // Only for strength reduction and SIMD which don't have per-iteration increments
                    let idx_info = locals.get(&idx_id).ok_or_else(|| anyhow!("Index variable not found"))?;
                    let current = builder.use_var(idx_info.var);
                    let incremented = builder.ins().iadd_imm(current, (UNROLL_FACTOR - 1) * stride);
                    builder.def_var(idx_info.var, incremented);
                } else if !optimized {
                    // Normal unrolling: compile body UNROLL_FACTOR times
                    for unroll_iter in 0..UNROLL_FACTOR {
                        // Compile all body statements
                        for s in body {
                            compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&main_loop_ctx), boxed_vars)?;
                        }

                        // Increment loop counter by stride (except for last iteration - update block handles it)
                        if unroll_iter < UNROLL_FACTOR - 1 {
                            let idx_info = locals.get(&idx_id).ok_or_else(|| anyhow!("Index variable not found"))?;
                            let current = builder.use_var(idx_info.var);
                            let incremented = builder.ins().iadd_imm(current, stride);
                            builder.def_var(idx_info.var, incremented);
                        }
                    }
                }

                // Jump to main update
                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(main_update, &[]);
                }

                // Main loop update - execute original update expression (i++)
                builder.switch_to_block(main_update);
                builder.seal_block(main_update);
                if let Some(upd) = update {
                    compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, upd, this_ctx)?;
                }
                builder.ins().jump(main_header, &[]);
                builder.seal_block(main_header);

                // === REMAINDER SECTION (combine accumulators, then process remaining iterations) ===

                // rem_combine block: Combine accumulators (runs once when exiting main loop)
                builder.switch_to_block(rem_combine);
                builder.seal_block(rem_combine);

                // COMBINE SIMD ACCUMULATORS: sum = original_sum + horizontal_sum(vec_acc0..vec_acc3)
                if let Some((vec_accs, _arr_id)) = simd_accumulators.as_ref() {
                    if let Some((sum_id, _)) = use_multi_accum {
                        if let Some(sum_info) = locals.get(&sum_id) {
                            let original_sum = builder.use_var(sum_info.var);

                            // Load all 4 vector accumulators
                            let v0 = builder.use_var(vec_accs[0]); // [a0, a1]
                            let v1 = builder.use_var(vec_accs[1]); // [a2, a3]
                            let v2 = builder.use_var(vec_accs[2]); // [a4, a5]
                            let v3 = builder.use_var(vec_accs[3]); // [a6, a7]

                            // Combine vectors pairwise: v01 = v0 + v1, v23 = v2 + v3
                            let v01 = builder.ins().fadd(v0, v1); // [(a0+a2), (a1+a3)]
                            let v23 = builder.ins().fadd(v2, v3); // [(a4+a6), (a5+a7)]

                            // Combine to single vector
                            let v_all = builder.ins().fadd(v01, v23); // [sum_even, sum_odd]

                            // Extract lanes and sum horizontally
                            let lane0 = builder.ins().extractlane(v_all, 0); // sum of even indices
                            let lane1 = builder.ins().extractlane(v_all, 1); // sum of odd indices
                            let accum_total = builder.ins().fadd(lane0, lane1);

                            let total = builder.ins().fadd(original_sum, accum_total);
                            builder.def_var(sum_info.var, total);
                        }
                    }
                }

                // COMBINE GENERIC ACCUMULATORS: sum = original_sum + acc0 + acc1 + ... + acc7
                if let Some((ref accs, sum_id, _original_sum_var)) = generic_accumulators {
                    if let Some(sum_info) = locals.get(&sum_id) {
                        let original_sum = builder.use_var(sum_info.var);

                        // Load all 8 accumulators
                        let a: Vec<_> = accs.iter().map(|acc| builder.use_var(*acc)).collect();

                        // Combine in tree fashion: ((a0+a1)+(a2+a3)) + ((a4+a5)+(a6+a7))
                        let sum01 = builder.ins().fadd(a[0], a[1]);
                        let sum23 = builder.ins().fadd(a[2], a[3]);
                        let sum45 = builder.ins().fadd(a[4], a[5]);
                        let sum67 = builder.ins().fadd(a[6], a[7]);
                        let sum0123 = builder.ins().fadd(sum01, sum23);
                        let sum4567 = builder.ins().fadd(sum45, sum67);
                        let accum_total = builder.ins().fadd(sum0123, sum4567);

                        let total = builder.ins().fadd(original_sum, accum_total);
                        builder.def_var(sum_info.var, total);
                    }
                }

                // Jump to remainder loop header
                builder.ins().jump(rem_header, &[]);

                // rem_header block: Check condition (loop header)
                builder.switch_to_block(rem_header);

                // Check: i < limit
                let idx_info = locals.get(&idx_id).ok_or_else(|| anyhow!("Index variable not found"))?;
                let idx_i32 = builder.use_var(idx_info.var);
                let length_i32 = builder.use_var(len_var);
                let in_bounds = builder.ins().icmp(IntCC::SignedLessThan, idx_i32, length_i32);
                builder.ins().brif(in_bounds, rem_body, &[], exit_block, &[]);

                // Remainder loop context
                let rem_loop_ctx = LoopContext { exit_block, header_block: rem_update, bounded_indices };

                // Remainder loop body
                builder.switch_to_block(rem_body);
                builder.seal_block(rem_body);

                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&rem_loop_ctx), boxed_vars)?;
                }

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(rem_update, &[]);
                }

                // Remainder loop update
                builder.switch_to_block(rem_update);
                builder.seal_block(rem_update);
                if let Some(upd) = update {
                    compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, upd, this_ctx)?;
                }
                builder.ins().jump(rem_header, &[]);
                builder.seal_block(rem_header);

                // Exit
                builder.switch_to_block(exit_block);
                builder.seal_block(exit_block);

                // Clean up after loop
                if let Some(orig_f64_var) = original_f64_var {
                    if let Some(idx_info) = locals.get_mut(&idx_id) {
                        let final_i32 = builder.use_var(idx_info.var);
                        let final_f64 = builder.ins().fcvt_from_sint(types::F64, final_i32);
                        builder.def_var(orig_f64_var, final_f64);
                        idx_info.var = orig_f64_var;
                        idx_info.is_i32 = false;
                        idx_info.bounded_by_array = None;
                    }
                }
            } else {
                // NON-UNROLLED LOOP: Original implementation
                let header_block = builder.create_block();
                let body_block = builder.create_block();
                let update_block = builder.create_block();
                let exit_block = builder.create_block();

                builder.ins().jump(header_block, &[]);

                // Header (condition check)
                builder.switch_to_block(header_block);

                if let Some(cond) = condition {
                    // Use optimized condition if BCE pattern was detected
                    if let (Some(len_var), Some(idx_id)) = (cached_length_var, bce_index_var) {
                        if let Some(idx_info) = locals.get(&idx_id) {
                            let idx_i32 = builder.use_var(idx_info.var);
                            let length_i32 = builder.use_var(len_var);
                            let in_bounds = builder.ins().icmp(IntCC::SignedLessThan, idx_i32, length_i32);
                            builder.ins().brif(in_bounds, body_block, &[], exit_block, &[]);
                        } else {
                            let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, cond, this_ctx)?;
                            let cond_val = ensure_f64(builder, cond_val_raw);
                            let truthy_func = extern_funcs.get("js_is_truthy")
                                .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                            let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                            let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                            let truthy_result = builder.inst_results(truthy_call)[0];
                            let zero_i32 = builder.ins().iconst(types::I32, 0);
                            let cond_bool = builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32);
                            builder.ins().brif(cond_bool, body_block, &[], exit_block, &[]);
                        }
                    } else {
                        let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, cond, this_ctx)?;
                        let cond_val = ensure_f64(builder, cond_val_raw);
                        let truthy_func = extern_funcs.get("js_is_truthy")
                            .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                        let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                        let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
                        let truthy_result = builder.inst_results(truthy_call)[0];
                        let zero_i32 = builder.ins().iconst(types::I32, 0);
                        let cond_bool = builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32);
                        builder.ins().brif(cond_bool, body_block, &[], exit_block, &[]);
                    }
                } else {
                    builder.ins().jump(body_block, &[]);
                }

                let for_loop_ctx = LoopContext { exit_block, header_block: update_block, bounded_indices };

                // Set BCE information on index variable
                if let Some(idx_id) = bce_index_var {
                    if let Some(idx_info) = locals.get_mut(&idx_id) {
                        if let Some(arr_id) = bce_array_var {
                            idx_info.bounded_by_array = Some(arr_id);
                        }
                        if let Some(limit) = bce_constant_limit {
                            idx_info.bounded_by_constant = Some(limit);
                        }
                    }
                }

                builder.switch_to_block(body_block);
                builder.seal_block(body_block);

                for s in body {
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, s, this_ctx, Some(&for_loop_ctx), boxed_vars)?;
                }

                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    builder.ins().jump(update_block, &[]);
                }

                builder.switch_to_block(update_block);
                builder.seal_block(update_block);
                if let Some(upd) = update {
                    compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, upd, this_ctx)?;
                }

                builder.ins().jump(header_block, &[]);
                builder.seal_block(header_block);

                builder.switch_to_block(exit_block);
                builder.seal_block(exit_block);

                if let (Some(idx_id), Some(orig_f64_var)) = (bce_index_var, original_f64_var) {
                    if let Some(idx_info) = locals.get_mut(&idx_id) {
                        let final_i32 = builder.use_var(idx_info.var);
                        let final_f64 = builder.ins().fcvt_from_sint(types::F64, final_i32);
                        builder.def_var(orig_f64_var, final_f64);
                        idx_info.var = orig_f64_var;
                        idx_info.is_i32 = false;
                        idx_info.bounded_by_array = None;
                    }
                }
            }
        }
        Stmt::Expr(expr) => {
            compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
        }
        Stmt::Break => {
            if let Some(ctx) = loop_ctx {
                builder.ins().jump(ctx.exit_block, &[]);
            }
            // If no loop context, break is invalid but we silently ignore for now
        }
        Stmt::Continue => {
            if let Some(ctx) = loop_ctx {
                builder.ins().jump(ctx.header_block, &[]);
            }
            // If no loop context, continue is invalid but we silently ignore for now
        }
        Stmt::Throw(expr) => {
            // Compile the expression to throw
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;

            // Call js_throw(value) - this function never returns (uses longjmp)
            // js_throw expects f64. If the value is an i64 (pointer), we need to NaN-box it
            // so that the catch block can correctly identify it as an object.
            let val_type = builder.func.dfg.value_type(val);
            let val_f64 = if val_type == types::I64 {
                // i64 pointer - NaN-box it as an object
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[val]);
                builder.inst_results(call)[0]
            } else {
                // Already f64 (number, NaN-boxed value, etc.)
                val
            };
            let throw_func = extern_funcs.get("js_throw")
                .ok_or_else(|| anyhow!("js_throw not declared"))?;
            let throw_ref = module.declare_func_in_func(*throw_func, builder.func);
            builder.ins().call(throw_ref, &[val_f64]);

            // js_throw never returns, but Cranelift needs a terminator.
            // Create a new unreachable block and jump to it, then trap there.
            // This prevents the trap from being placed inline after the call.
            let unreachable_block = builder.create_block();
            builder.ins().jump(unreachable_block, &[]);
            builder.switch_to_block(unreachable_block);
            builder.seal_block(unreachable_block);
            builder.ins().trap(TrapCode::user(1).unwrap());
        }
        Stmt::Try { body, catch, finally } => {
            // Collect LocalIds that are assigned in the try body
            // These need stack slots to preserve values across longjmp
            fn collect_assigned_in_stmts(stmts: &[Stmt], assigned: &mut std::collections::HashSet<LocalId>) {
                for stmt in stmts {
                    collect_assigned_in_stmt(stmt, assigned);
                }
            }
            fn collect_assigned_in_stmt(stmt: &Stmt, assigned: &mut std::collections::HashSet<LocalId>) {
                match stmt {
                    Stmt::Expr(expr) => collect_assigned_in_expr(expr, assigned),
                    Stmt::If { condition, then_branch, else_branch } => {
                        collect_assigned_in_expr(condition, assigned);
                        collect_assigned_in_stmts(then_branch, assigned);
                        if let Some(else_stmts) = else_branch {
                            collect_assigned_in_stmts(else_stmts, assigned);
                        }
                    }
                    Stmt::While { condition, body } => {
                        collect_assigned_in_expr(condition, assigned);
                        collect_assigned_in_stmts(body, assigned);
                    }
                    Stmt::For { init, condition, update, body } => {
                        if let Some(init_stmt) = init {
                            collect_assigned_in_stmt(init_stmt, assigned);
                        }
                        if let Some(cond) = condition {
                            collect_assigned_in_expr(cond, assigned);
                        }
                        if let Some(upd) = update {
                            collect_assigned_in_expr(upd, assigned);
                        }
                        collect_assigned_in_stmts(body, assigned);
                    }
                    Stmt::Return(Some(expr)) | Stmt::Throw(expr) => {
                        collect_assigned_in_expr(expr, assigned);
                    }
                    _ => {}
                }
            }
            fn collect_assigned_in_expr(expr: &Expr, assigned: &mut std::collections::HashSet<LocalId>) {
                match expr {
                    Expr::LocalSet(id, val) => {
                        assigned.insert(*id);
                        collect_assigned_in_expr(val, assigned);
                    }
                    Expr::Binary { left, right, .. } | Expr::Compare { left, right, .. } => {
                        collect_assigned_in_expr(left, assigned);
                        collect_assigned_in_expr(right, assigned);
                    }
                    Expr::Unary { operand, .. } => collect_assigned_in_expr(operand, assigned),
                    Expr::Call { callee, args, .. } => {
                        collect_assigned_in_expr(callee, assigned);
                        for arg in args {
                            collect_assigned_in_expr(arg, assigned);
                        }
                    }
                    _ => {}
                }
            }

            let mut try_assigned: std::collections::HashSet<LocalId> = std::collections::HashSet::new();
            collect_assigned_in_stmts(body, &mut try_assigned);

            // Create stack slots for variables that exist before the try and are assigned in try
            // Map: LocalId -> (StackSlot, is_i64)
            let mut try_var_slots: HashMap<LocalId, (StackSlot, bool)> = HashMap::new();
            for local_id in &try_assigned {
                if let Some(info) = locals.get(local_id) {
                    // Variable is stored as i64 only if is_pointer && !is_union
                    let var_type = if info.is_pointer && !info.is_union { types::I64 } else { types::F64 };
                    let is_i64 = info.is_pointer && !info.is_union;
                    let slot = builder.create_sized_stack_slot(StackSlotData::new(
                        StackSlotKind::ExplicitSlot,
                        8, // f64 or i64 = 8 bytes
                        8, // alignment
                    ));
                    // Store current value to slot before setjmp
                    let val = builder.use_var(info.var);
                    builder.ins().stack_store(val, slot, 0);
                    try_var_slots.insert(*local_id, (slot, is_i64));
                }
            }

            // Generate control flow blocks
            let try_body_block = builder.create_block();
            let catch_block = builder.create_block();
            let finally_block = builder.create_block();
            let merge_block = builder.create_block();

            // Call js_try_push() to get a pointer to the jmp_buf
            let try_push_func = extern_funcs.get("js_try_push")
                .ok_or_else(|| anyhow!("js_try_push not declared"))?;
            let try_push_ref = module.declare_func_in_func(*try_push_func, builder.func);
            let call = builder.ins().call(try_push_ref, &[]);
            let jmp_buf_ptr = builder.inst_results(call)[0];

            // Call setjmp directly with the jmp_buf pointer
            // This is critical: setjmp must be called from this stack frame, not from inside a helper function
            let setjmp_func = extern_funcs.get("setjmp")
                .ok_or_else(|| anyhow!("setjmp not declared"))?;
            let setjmp_ref = module.declare_func_in_func(*setjmp_func, builder.func);
            let call = builder.ins().call(setjmp_ref, &[jmp_buf_ptr]);
            let setjmp_result = builder.inst_results(call)[0];

            // Branch: if setjmp returned 0, go to try body; otherwise go to catch
            let zero = builder.ins().iconst(types::I32, 0);
            let is_normal = builder.ins().icmp(IntCC::Equal, setjmp_result, zero);
            builder.ins().brif(is_normal, try_body_block, &[], catch_block, &[]);

            // Try body
            builder.switch_to_block(try_body_block);
            builder.seal_block(try_body_block);
            for stmt in body {
                // Check if block is already filled (e.g., by throw/return)
                let current = builder.current_block().unwrap();
                if is_block_filled(builder, current) {
                    break;
                }
                compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, stmt, this_ctx, loop_ctx, boxed_vars)?;

                // After compiling each statement, store modified variables to stack slots
                // This ensures the value survives longjmp
                // Only do this if the block isn't already terminated (e.g., by throw)
                let current_after = builder.current_block().unwrap();
                if !is_block_filled(builder, current_after) {
                    for (local_id, (slot, _is_i64)) in &try_var_slots {
                        if let Some(info) = locals.get(local_id) {
                            let val = builder.use_var(info.var);
                            builder.ins().stack_store(val, *slot, 0);
                        }
                    }
                }
            }
            // Jump to finally (or merge if no finally)
            let current = builder.current_block().unwrap();
            if !is_block_filled(builder, current) {
                if finally.is_some() {
                    builder.ins().jump(finally_block, &[]);
                } else {
                    // Call js_try_end() before leaving
                    let try_end_func = extern_funcs.get("js_try_end")
                        .ok_or_else(|| anyhow!("js_try_end not declared"))?;
                    let try_end_ref = module.declare_func_in_func(*try_end_func, builder.func);
                    builder.ins().call(try_end_ref, &[]);
                    builder.ins().jump(merge_block, &[]);
                }
            }

            // Catch block
            builder.switch_to_block(catch_block);
            builder.seal_block(catch_block);

            // Restore variables from stack slots (longjmp may have clobbered SSA values)
            for (local_id, (slot, is_i64)) in &try_var_slots {
                if let Some(info) = locals.get(local_id) {
                    let var_type = if *is_i64 { types::I64 } else { types::F64 };
                    let val = builder.ins().stack_load(var_type, *slot, 0);
                    builder.def_var(info.var, val);
                }
            }

            // Pop this try level FIRST, before executing catch body
            // This ensures any throw inside catch propagates to outer try
            {
                let try_end_func_catch = extern_funcs.get("js_try_end")
                    .ok_or_else(|| anyhow!("js_try_end not declared"))?;
                let try_end_ref_catch = module.declare_func_in_func(*try_end_func_catch, builder.func);
                builder.ins().call(try_end_ref_catch, &[]);
            }

            if let Some(catch_clause) = catch {
                // Get the exception value
                let get_exc_func = extern_funcs.get("js_get_exception")
                    .ok_or_else(|| anyhow!("js_get_exception not declared"))?;
                let get_exc_ref = module.declare_func_in_func(*get_exc_func, builder.func);
                let call = builder.ins().call(get_exc_ref, &[]);
                let exc_val = builder.inst_results(call)[0];

                // If catch has a parameter, bind it
                if let Some((param_id, param_name)) = &catch_clause.param {
                    let var = Variable::new(*next_var);
                    *next_var += 1;
                    builder.declare_var(var, types::F64);
                    builder.def_var(var, exc_val);
                    locals.insert(*param_id, LocalInfo {
                        var,
                        name: Some(param_name.clone()),
                        class_name: None,
                        type_args: Vec::new(),
                        is_pointer: false,
                        is_array: false,
                        is_string: false,
                        is_bigint: false,
                        is_closure: false,
                        is_boxed: false,
                        // Caught exceptions can be any type, so mark as union for runtime type checking
                        is_map: false, is_set: false, is_buffer: false, is_event_emitter: false, is_union: true,
                        is_mixed_array: false,
                        is_integer: false,
                        is_integer_array: false,
                        is_i32: false,
                        i32_shadow: None,
                        bounded_by_array: None,
                        bounded_by_constant: None,
                        scalar_fields: None,
                        squared_cache: None, product_cache: None,
                    });
                }

                // Clear the exception since we're handling it
                let clear_exc_func = extern_funcs.get("js_clear_exception")
                    .ok_or_else(|| anyhow!("js_clear_exception not declared"))?;
                let clear_exc_ref = module.declare_func_in_func(*clear_exc_func, builder.func);
                builder.ins().call(clear_exc_ref, &[]);

                // Compile catch body
                for stmt in &catch_clause.body {
                    let current = builder.current_block().unwrap();
                    if is_block_filled(builder, current) {
                        break;
                    }
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, stmt, this_ctx, loop_ctx, boxed_vars)?;
                }
            }

            // After catch, jump to finally (or merge)
            // Note: js_try_end() was already called at the start of catch block
            let current = builder.current_block().unwrap();
            if !is_block_filled(builder, current) {
                if finally.is_some() {
                    builder.ins().jump(finally_block, &[]);
                } else {
                    builder.ins().jump(merge_block, &[]);
                }
            }

            // Finally block (if present)
            builder.switch_to_block(finally_block);
            builder.seal_block(finally_block);

            if let Some(finally_stmts) = finally {
                // Mark entering finally
                let enter_finally_func = extern_funcs.get("js_enter_finally")
                    .ok_or_else(|| anyhow!("js_enter_finally not declared"))?;
                let enter_finally_ref = module.declare_func_in_func(*enter_finally_func, builder.func);
                builder.ins().call(enter_finally_ref, &[]);

                // Compile finally body
                for stmt in finally_stmts {
                    let current = builder.current_block().unwrap();
                    if is_block_filled(builder, current) {
                        break;
                    }
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, stmt, this_ctx, loop_ctx, boxed_vars)?;
                }

                // Mark leaving finally
                let leave_finally_func = extern_funcs.get("js_leave_finally")
                    .ok_or_else(|| anyhow!("js_leave_finally not declared"))?;
                let leave_finally_ref = module.declare_func_in_func(*leave_finally_func, builder.func);
                builder.ins().call(leave_finally_ref, &[]);
            }

            // Call js_try_end() after finally
            let try_end_func = extern_funcs.get("js_try_end")
                .ok_or_else(|| anyhow!("js_try_end not declared"))?;
            let try_end_ref = module.declare_func_in_func(*try_end_func, builder.func);
            builder.ins().call(try_end_ref, &[]);

            let current = builder.current_block().unwrap();
            if !is_block_filled(builder, current) {
                builder.ins().jump(merge_block, &[]);
            }

            // Merge block - continue after try-catch-finally
            builder.switch_to_block(merge_block);
            builder.seal_block(merge_block);
        }
        Stmt::Switch { discriminant, cases } => {
            // Check if this is a string switch (any case has a string literal test)
            let is_string_switch = cases.iter().any(|c| {
                matches!(c.test.as_ref(), Some(Expr::String(_)))
            });

            // Evaluate the discriminant once
            let disc_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, discriminant, this_ctx)?;
            let disc_val = ensure_f64(builder, disc_val_raw);

            // For string switches, extract the discriminant string pointer once
            let disc_str_ptr = if is_string_switch {
                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                let disc_call = builder.ins().call(get_str_ptr_ref, &[disc_val]);
                Some(builder.inst_results(disc_call)[0])
            } else {
                None
            };

            // Create blocks for each case body and a merge block
            let merge_block = builder.create_block();
            let case_blocks: Vec<_> = cases.iter().map(|_| builder.create_block()).collect();

            // Find the default case index (if any)
            let default_idx = cases.iter().position(|c| c.test.is_none());

            // Create a block for each case's test (for non-default cases)
            let mut test_blocks: Vec<_> = (0..cases.len()).map(|_| builder.create_block()).collect();

            // Start by jumping to the first test block (or default/merge if no cases)
            if cases.is_empty() {
                builder.ins().jump(merge_block, &[]);
            } else {
                builder.ins().jump(test_blocks[0], &[]);
            }

            // Generate test blocks - each tests its case value and jumps accordingly
            for (i, case) in cases.iter().enumerate() {
                builder.switch_to_block(test_blocks[i]);
                builder.seal_block(test_blocks[i]);

                if let Some(ref test_expr) = case.test {
                    // Compare discriminant with case value
                    let test_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, test_expr, this_ctx)?;
                    let test_val = ensure_f64(builder, test_val_raw);

                    let eq = if is_string_switch {
                        // String comparison: use js_string_equals
                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                        let test_call = builder.ins().call(get_str_ptr_ref, &[test_val]);
                        let test_str_ptr = builder.inst_results(test_call)[0];

                        let equals_func = extern_funcs.get("js_string_equals")
                            .ok_or_else(|| anyhow!("js_string_equals not declared"))?;
                        let equals_ref = module.declare_func_in_func(*equals_func, builder.func);
                        let cmp_call = builder.ins().call(equals_ref, &[disc_str_ptr.unwrap(), test_str_ptr]);
                        let result = builder.inst_results(cmp_call)[0]; // i32 bool
                        builder.ins().icmp_imm(IntCC::NotEqual, result, 0)
                    } else {
                        // Numeric comparison
                        builder.ins().fcmp(FloatCC::Equal, disc_val, test_val)
                    };

                    // If equal, jump to case body; otherwise, try next case
                    let next_test = if i + 1 < cases.len() {
                        test_blocks[i + 1]
                    } else if let Some(def_idx) = default_idx {
                        case_blocks[def_idx]
                    } else {
                        merge_block
                    };
                    builder.ins().brif(eq, case_blocks[i], &[], next_test, &[]);
                } else {
                    // Default case - will be reached via fallthrough from last non-matching test
                    // Just jump to the case body
                    builder.ins().jump(case_blocks[i], &[]);
                }
            }

            // Generate case body blocks with fall-through semantics
            // Set up loop context for break statements to target merge_block
            let switch_loop_ctx = Some(LoopContext {
                exit_block: merge_block,
                header_block: merge_block, // continue in switch goes to merge (unusual but safe)
                bounded_indices: HashMap::new(),
            });

            for (i, case) in cases.iter().enumerate() {
                builder.switch_to_block(case_blocks[i]);
                builder.seal_block(case_blocks[i]);

                // Compile case body
                for stmt in &case.body {
                    let current = builder.current_block().unwrap();
                    if is_block_filled(builder, current) {
                        break;
                    }
                    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, stmt, this_ctx, switch_loop_ctx.as_ref(), boxed_vars)?;
                }

                // Fall through to next case body (if not already terminated by break/return)
                let current = builder.current_block().unwrap();
                if !is_block_filled(builder, current) {
                    let next_block = if i + 1 < cases.len() {
                        case_blocks[i + 1]
                    } else {
                        merge_block
                    };
                    builder.ins().jump(next_block, &[]);
                }
            }

            // Merge block
            builder.switch_to_block(merge_block);
            builder.seal_block(merge_block);
        }
    }
    Ok(())
}

fn compile_expr(
    builder: &mut FunctionBuilder,
    module: &mut ObjectModule,
    func_ids: &HashMap<u32, cranelift_module::FuncId>,
    closure_func_ids: &HashMap<u32, cranelift_module::FuncId>,
    func_wrapper_ids: &HashMap<u32, cranelift_module::FuncId>,
    extern_funcs: &HashMap<String, cranelift_module::FuncId>,
    async_func_ids: &std::collections::HashSet<u32>,
    classes: &HashMap<String, ClassMeta>,
    enums: &HashMap<(String, String), EnumMemberValue>,
    func_param_types: &HashMap<u32, Vec<types::Type>>, func_union_params: &HashMap<u32, Vec<bool>>,
    func_return_types: &HashMap<u32, types::Type>,
    func_hir_return_types: &HashMap<u32, perry_types::Type>,
    func_rest_param_index: &HashMap<u32, usize>,
    imported_func_param_counts: &HashMap<String, usize>,
    locals: &HashMap<LocalId, LocalInfo>,
    expr: &Expr,
    this_ctx: Option<&ThisContext>,
) -> Result<Value> {
    match expr {
        Expr::Number(n) => Ok(builder.ins().f64const(*n)),
        Expr::Integer(n) => Ok(builder.ins().f64const(*n as f64)),
        Expr::Bool(b) => {
            // Use NaN-boxed boolean tags for proper identification
            // TAG_TRUE = 0x7FFC_0000_0000_0004
            // TAG_FALSE = 0x7FFC_0000_0000_0003
            const TAG_TRUE: u64 = 0x7FFC_0000_0000_0004;
            const TAG_FALSE: u64 = 0x7FFC_0000_0000_0003;
            let tag = if *b { TAG_TRUE } else { TAG_FALSE };
            Ok(builder.ins().f64const(f64::from_bits(tag)))
        }
        Expr::String(s) => {
            // Create a string at runtime by storing bytes on the stack
            let bytes = s.as_bytes();
            let len = bytes.len();

            if len == 0 {
                // Empty string - allocate and NaN-box
                let alloc_func = extern_funcs.get("js_string_from_bytes")
                    .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                let null_ptr = builder.ins().iconst(types::I64, 0);
                let zero_len = builder.ins().iconst(types::I32, 0);
                let call = builder.ins().call(alloc_ref, &[null_ptr, zero_len]);
                let str_ptr = builder.inst_results(call)[0];
                // NaN-box the string pointer for proper type identification
                let nanbox_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let nanbox_call = builder.ins().call(nanbox_ref, &[str_ptr]);
                return Ok(builder.inst_results(nanbox_call)[0]);
            }

            // Create a stack slot for the string bytes
            let slot = builder.create_sized_stack_slot(StackSlotData::new(
                StackSlotKind::ExplicitSlot,
                len as u32,
                0,
            ));

            // Store each byte (we'll do this in chunks of 8 bytes where possible)
            let mut offset = 0usize;
            while offset + 8 <= len {
                let chunk = &bytes[offset..offset + 8];
                let val = u64::from_le_bytes(chunk.try_into().unwrap());
                let val_i64 = builder.ins().iconst(types::I64, val as i64);
                builder.ins().stack_store(val_i64, slot, offset as i32);
                offset += 8;
            }
            // Handle remaining bytes one by one
            while offset < len {
                let byte_val = builder.ins().iconst(types::I8, bytes[offset] as i64);
                builder.ins().stack_store(byte_val, slot, offset as i32);
                offset += 1;
            }

            // Get the stack slot address
            let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);

            // Call js_string_from_bytes to allocate the string
            let alloc_func = extern_funcs.get("js_string_from_bytes")
                .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
            let len_val = builder.ins().iconst(types::I32, len as i64);
            let call = builder.ins().call(alloc_ref, &[slot_addr, len_val]);
            let str_ptr = builder.inst_results(call)[0];
            // NaN-box the string pointer for proper type identification
            let nanbox_func = extern_funcs.get("js_nanbox_string")
                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let nanbox_call = builder.ins().call(nanbox_ref, &[str_ptr]);
            Ok(builder.inst_results(nanbox_call)[0])
        }
        Expr::BigInt(s) => {
            // Create a BigInt from the string representation
            // BigInt literals in JS look like "123n" but HIR stores just the digits
            let bytes = s.as_bytes();
            let len = bytes.len();

            // Create a stack slot for the string bytes
            let slot = builder.create_sized_stack_slot(StackSlotData::new(
                StackSlotKind::ExplicitSlot,
                len as u32,
                0,
            ));

            // Store bytes
            let mut offset = 0usize;
            while offset + 8 <= len {
                let chunk = &bytes[offset..offset + 8];
                let val = u64::from_le_bytes(chunk.try_into().unwrap());
                let val_i64 = builder.ins().iconst(types::I64, val as i64);
                builder.ins().stack_store(val_i64, slot, offset as i32);
                offset += 8;
            }
            while offset < len {
                let byte_val = builder.ins().iconst(types::I8, bytes[offset] as i64);
                builder.ins().stack_store(byte_val, slot, offset as i32);
                offset += 1;
            }

            // Get the stack slot address
            let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);

            // Call js_bigint_from_string
            let alloc_func = extern_funcs.get("js_bigint_from_string")
                .ok_or_else(|| anyhow!("js_bigint_from_string not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
            let len_val = builder.ins().iconst(types::I32, len as i64);
            let call = builder.ins().call(alloc_ref, &[slot_addr, len_val]);
            let bigint_ptr = builder.inst_results(call)[0];

            // NaN-box the BigInt pointer for proper type identification
            let nanbox_func = extern_funcs.get("js_nanbox_bigint")
                .ok_or_else(|| anyhow!("js_nanbox_bigint not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let nanbox_call = builder.ins().call(nanbox_ref, &[bigint_ptr]);
            Ok(builder.inst_results(nanbox_call)[0])
        }
        Expr::EnumMember { enum_name, member_name } => {
            // Look up the enum member value
            let key = (enum_name.clone(), member_name.clone());
            match enums.get(&key) {
                Some(EnumMemberValue::Number(n)) => {
                    // Numeric enum - return as f64
                    Ok(builder.ins().f64const(*n as f64))
                }
                Some(EnumMemberValue::String(s)) => {
                    // String enum - create a string at runtime
                    let bytes = s.as_bytes();
                    let len = bytes.len();

                    if len == 0 {
                        let alloc_func = extern_funcs.get("js_string_from_bytes")
                            .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
                        let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                        let null_ptr = builder.ins().iconst(types::I64, 0);
                        let zero_len = builder.ins().iconst(types::I32, 0);
                        let call = builder.ins().call(alloc_ref, &[null_ptr, zero_len]);
                        let str_ptr = builder.inst_results(call)[0];
                        return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), str_ptr));
                    }

                    let slot = builder.create_sized_stack_slot(StackSlotData::new(
                        StackSlotKind::ExplicitSlot,
                        len as u32,
                        0,
                    ));

                    let mut offset = 0usize;
                    while offset + 8 <= len {
                        let chunk = &bytes[offset..offset + 8];
                        let val = u64::from_le_bytes(chunk.try_into().unwrap());
                        let val_i64 = builder.ins().iconst(types::I64, val as i64);
                        builder.ins().stack_store(val_i64, slot, offset as i32);
                        offset += 8;
                    }
                    while offset < len {
                        let byte_val = builder.ins().iconst(types::I8, bytes[offset] as i64);
                        builder.ins().stack_store(byte_val, slot, offset as i32);
                        offset += 1;
                    }

                    let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
                    let alloc_func = extern_funcs.get("js_string_from_bytes")
                        .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
                    let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                    let len_val = builder.ins().iconst(types::I32, len as i64);
                    let call = builder.ins().call(alloc_ref, &[slot_addr, len_val]);
                    let str_ptr = builder.inst_results(call)[0];
                    Ok(builder.ins().bitcast(types::F64, MemFlags::new(), str_ptr))
                }
                None => Err(anyhow!("Unknown enum member: {}.{}", enum_name, member_name)),
            }
        }
        Expr::StaticFieldGet { class_name, field_name } => {
            // Get the data ID for the static field
            let class_meta = classes.get(class_name)
                .ok_or_else(|| anyhow!("Unknown class: {}", class_name))?;
            let data_id = class_meta.static_field_ids.get(field_name)
                .ok_or_else(|| anyhow!("Unknown static field: {}.{}", class_name, field_name))?;

            // Get the global value reference and load from it
            let global_val = module.declare_data_in_func(*data_id, builder.func);
            let ptr = builder.ins().global_value(types::I64, global_val);
            let value = builder.ins().load(types::F64, MemFlags::new(), ptr, 0);
            Ok(value)
        }
        Expr::StaticFieldSet { class_name, field_name, value } => {
            // Compile the value to store
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Get the data ID for the static field
            let class_meta = classes.get(class_name)
                .ok_or_else(|| anyhow!("Unknown class: {}", class_name))?;
            let data_id = class_meta.static_field_ids.get(field_name)
                .ok_or_else(|| anyhow!("Unknown static field: {}.{}", class_name, field_name))?;

            // Store to the global
            let global_val = module.declare_data_in_func(*data_id, builder.func);
            let ptr = builder.ins().global_value(types::I64, global_val);
            builder.ins().store(MemFlags::new(), val, ptr, 0);

            // Return the value (assignment expression evaluates to the assigned value)
            Ok(val)
        }
        Expr::StaticMethodCall { class_name, method_name, args } => {
            // Get the function ID for the static method
            let class_meta = classes.get(class_name)
                .ok_or_else(|| anyhow!("Unknown class: {}", class_name))?;
            let method_id = class_meta.static_method_ids.get(method_name)
                .ok_or_else(|| anyhow!("Unknown static method: {}.{}", class_name, method_name))?;

            // Compile arguments
            let mut arg_vals = Vec::new();
            for arg in args {
                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                arg_vals.push(val);
            }

            // Convert arguments to f64 - static methods are declared with f64 parameters
            let converted_args: Vec<Value> = arg_vals.iter()
                .map(|&val| ensure_f64(builder, val))
                .collect();

            // Call the static method (no 'this' argument)
            let func_ref = module.declare_func_in_func(*method_id, builder.func);

            // Get expected parameter count from the function signature
            let actual_sig = module.declarations().get_function_decl(*method_id);
            let expected_param_count = actual_sig.signature.params.len();

            // Pad or truncate arguments to match expected count
            let mut final_call_args = converted_args;
            while final_call_args.len() < expected_param_count {
                // Add undefined (f64 NaN) for missing optional arguments
                final_call_args.push(builder.ins().f64const(f64::NAN));
            }
            final_call_args.truncate(expected_param_count);

            let call = builder.ins().call(func_ref, &final_call_args);
            let result = builder.inst_results(call)[0];
            Ok(result)
        }
        Expr::EnvGet(var_name) => {
            // Create a string with the env var name
            let bytes = var_name.as_bytes();
            let len = bytes.len();

            // Create stack slot for the var name string
            let slot = builder.create_sized_stack_slot(StackSlotData::new(
                StackSlotKind::ExplicitSlot,
                len as u32,
                0,
            ));

            // Copy bytes to stack
            let mut offset = 0usize;
            while offset + 8 <= len {
                let chunk = &bytes[offset..offset + 8];
                let val = u64::from_le_bytes(chunk.try_into().unwrap());
                let val_i64 = builder.ins().iconst(types::I64, val as i64);
                builder.ins().stack_store(val_i64, slot, offset as i32);
                offset += 8;
            }
            while offset < len {
                let byte_val = builder.ins().iconst(types::I8, bytes[offset] as i64);
                builder.ins().stack_store(byte_val, slot, offset as i32);
                offset += 1;
            }

            let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);

            // Create JS string for the var name
            let string_alloc_func = extern_funcs.get("js_string_from_bytes")
                .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
            let string_alloc_ref = module.declare_func_in_func(*string_alloc_func, builder.func);
            let len_val = builder.ins().iconst(types::I32, len as i64);
            let call = builder.ins().call(string_alloc_ref, &[slot_addr, len_val]);
            let name_str_ptr = builder.inst_results(call)[0];

            // Call js_getenv
            let getenv_func = extern_funcs.get("js_getenv")
                .ok_or_else(|| anyhow!("js_getenv not declared"))?;
            let getenv_ref = module.declare_func_in_func(*getenv_func, builder.func);
            let call = builder.ins().call(getenv_ref, &[name_str_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            // Check if result is null (env var not found)
            // In JS, process.env.NONEXISTENT returns undefined, not null
            let zero = builder.ins().iconst(types::I64, 0);
            let is_null = builder.ins().icmp(IntCC::Equal, result_ptr, zero);

            // Create blocks for the conditional
            let found_block = builder.create_block();
            let not_found_block = builder.create_block();
            let merge_block = builder.create_block();
            builder.append_block_param(merge_block, types::F64);

            builder.ins().brif(is_null, not_found_block, &[], found_block, &[]);

            // Not found block: return undefined (TAG_UNDEFINED from perry-runtime)
            builder.switch_to_block(not_found_block);
            builder.seal_block(not_found_block);
            // Use the proper TAG_UNDEFINED value: 0x7FFC_0000_0000_0001
            let undefined_val = builder.ins().f64const(f64::from_bits(0x7FFC_0000_0000_0001_u64));
            builder.ins().jump(merge_block, &[undefined_val]);

            // Found block: NaN-box the string pointer
            builder.switch_to_block(found_block);
            builder.seal_block(found_block);
            let nanbox_func = extern_funcs.get("js_nanbox_string")
                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let call = builder.ins().call(nanbox_ref, &[result_ptr]);
            let nanboxed_val = builder.inst_results(call)[0];
            builder.ins().jump(merge_block, &[nanboxed_val]);

            // Merge block: return the result
            builder.switch_to_block(merge_block);
            builder.seal_block(merge_block);
            let result = builder.block_params(merge_block)[0];
            Ok(result)
        }
        Expr::EnvGetDynamic(key_expr) => {
            // Compile the key expression to get the env var name
            let key_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, key_expr, this_ctx)?;

            // The key is a string - extract the string pointer
            // It might be NaN-boxed if it came from a cross-module call or other sources
            let key_f64 = ensure_f64(builder, key_val);
            let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
            let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
            let call = builder.ins().call(get_str_ptr_ref, &[key_f64]);
            let name_str_ptr = builder.inst_results(call)[0];

            // Call js_getenv with the string pointer
            let getenv_func = extern_funcs.get("js_getenv")
                .ok_or_else(|| anyhow!("js_getenv not declared"))?;
            let getenv_ref = module.declare_func_in_func(*getenv_func, builder.func);
            let call = builder.ins().call(getenv_ref, &[name_str_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            // Check if result is null (env var not found)
            let zero = builder.ins().iconst(types::I64, 0);
            let is_null = builder.ins().icmp(IntCC::Equal, result_ptr, zero);

            // Create blocks for the conditional
            let found_block = builder.create_block();
            let not_found_block = builder.create_block();
            let merge_block = builder.create_block();
            builder.append_block_param(merge_block, types::F64);

            builder.ins().brif(is_null, not_found_block, &[], found_block, &[]);

            // Not found block: return undefined
            builder.switch_to_block(not_found_block);
            builder.seal_block(not_found_block);
            let undefined_val = builder.ins().f64const(f64::from_bits(0x7FFC_0000_0000_0001_u64));
            builder.ins().jump(merge_block, &[undefined_val]);

            // Found block: NaN-box the string pointer
            builder.switch_to_block(found_block);
            builder.seal_block(found_block);
            let nanbox_func = extern_funcs.get("js_nanbox_string")
                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let call = builder.ins().call(nanbox_ref, &[result_ptr]);
            let nanboxed_val = builder.inst_results(call)[0];
            builder.ins().jump(merge_block, &[nanboxed_val]);

            // Merge block: return the result
            builder.switch_to_block(merge_block);
            builder.seal_block(merge_block);
            let result = builder.block_params(merge_block)[0];
            Ok(result)
        }
        Expr::FsReadFileSync(path_expr) => {
            // Compile the path expression
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            // Convert f64 to i64 pointer
            let path_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), path_val);

            // Call js_fs_read_file_sync
            let func = extern_funcs.get("js_fs_read_file_sync")
                .ok_or_else(|| anyhow!("js_fs_read_file_sync not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            // NaN-box the string pointer with STRING_TAG
            let nanbox_func = extern_funcs.get("js_nanbox_string")
                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let call = builder.ins().call(nanbox_ref, &[result_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::FsWriteFileSync(path_expr, content_expr) => {
            // Compile path and content expressions
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let content_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, content_expr, this_ctx)?;
            // Convert f64 to i64 pointers
            let path_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), path_val);
            let content_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), content_val);

            // Call js_fs_write_file_sync
            let func = extern_funcs.get("js_fs_write_file_sync")
                .ok_or_else(|| anyhow!("js_fs_write_file_sync not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr, content_ptr]);
            let result_i32 = builder.inst_results(call)[0];

            // Return as f64 (1.0 = success, 0.0 = failure)
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::FsAppendFileSync(path_expr, content_expr) => {
            // Compile path and content expressions
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let content_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, content_expr, this_ctx)?;
            // Convert f64 to i64 pointers
            let path_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), path_val);
            let content_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), content_val);

            // Call js_fs_append_file_sync
            let func = extern_funcs.get("js_fs_append_file_sync")
                .ok_or_else(|| anyhow!("js_fs_append_file_sync not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr, content_ptr]);
            let result_i32 = builder.inst_results(call)[0];

            // Return as f64 (1.0 = success, 0.0 = failure)
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::FsExistsSync(path_expr) => {
            // Compile the path expression
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let path_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), path_val);

            // Call js_fs_exists_sync
            let func = extern_funcs.get("js_fs_exists_sync")
                .ok_or_else(|| anyhow!("js_fs_exists_sync not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr]);
            let result_i32 = builder.inst_results(call)[0];

            // Return as f64 (1.0 = true, 0.0 = false)
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::FsMkdirSync(path_expr) => {
            // Compile the path expression
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let path_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), path_val);

            // Call js_fs_mkdir_sync
            let func = extern_funcs.get("js_fs_mkdir_sync")
                .ok_or_else(|| anyhow!("js_fs_mkdir_sync not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr]);
            let result_i32 = builder.inst_results(call)[0];

            // Return as f64 (1.0 = success, 0.0 = failure)
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::FsUnlinkSync(path_expr) => {
            // Compile the path expression
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let path_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), path_val);

            // Call js_fs_unlink_sync
            let func = extern_funcs.get("js_fs_unlink_sync")
                .ok_or_else(|| anyhow!("js_fs_unlink_sync not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr]);
            let result_i32 = builder.inst_results(call)[0];

            // Return as f64 (1.0 = success, 0.0 = failure)
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::PathJoin(a_expr, b_expr) => {
            // Compile both path expressions
            let a_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, a_expr, this_ctx)?;
            let b_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, b_expr, this_ctx)?;
            let a_ptr = ensure_i64(builder, a_val);
            let b_ptr = ensure_i64(builder, b_val);

            // Call js_path_join
            let func = extern_funcs.get("js_path_join")
                .ok_or_else(|| anyhow!("js_path_join not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[a_ptr, b_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::PathDirname(path_expr) => {
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let path_ptr = ensure_i64(builder, path_val);

            let func = extern_funcs.get("js_path_dirname")
                .ok_or_else(|| anyhow!("js_path_dirname not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::PathBasename(path_expr) => {
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let path_ptr = ensure_i64(builder, path_val);

            let func = extern_funcs.get("js_path_basename")
                .ok_or_else(|| anyhow!("js_path_basename not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::PathExtname(path_expr) => {
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let path_ptr = ensure_i64(builder, path_val);

            let func = extern_funcs.get("js_path_extname")
                .ok_or_else(|| anyhow!("js_path_extname not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::PathResolve(path_expr) => {
            let path_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, path_expr, this_ctx)?;
            let path_ptr = ensure_i64(builder, path_val);

            let func = extern_funcs.get("js_path_resolve")
                .ok_or_else(|| anyhow!("js_path_resolve not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[path_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::JsonParse(json_str_expr) => {
            // Compile the JSON string expression
            let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, json_str_expr, this_ctx)?;
            let str_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), str_val);

            // Call js_json_parse - returns JSValue bits as i64
            let func = extern_funcs.get("js_json_parse")
                .ok_or_else(|| anyhow!("js_json_parse not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[str_ptr]);
            let result_bits = builder.inst_results(call)[0];
            // Bitcast i64 bits to f64 value
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_bits))
        }
        Expr::JsonStringify(value_expr) => {
            // Check if the value is a string expression - need to call specialized stringify
            fn is_string_value_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) |
                    Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                    Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                    Expr::Binary { op: BinaryOp::Add, left, right } => {
                        is_string_value_expr(left, locals) || is_string_value_expr(right, locals)
                    }
                    _ => false,
                }
            }

            // Compile the value expression
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value_expr, this_ctx)?;

            if is_string_value_expr(value_expr, locals) {
                // Use specialized string stringify function
                let func = extern_funcs.get("js_json_stringify_string")
                    .ok_or_else(|| anyhow!("js_json_stringify_string not declared"))?;
                let func_ref = module.declare_func_in_func(*func, builder.func);

                // String value is already a pointer (bitcast from f64)
                let str_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                let call = builder.ins().call(func_ref, &[str_ptr]);
                let result_ptr = builder.inst_results(call)[0];
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
            } else {
                // Use generic stringify - handles numbers, booleans, etc.
                let func = extern_funcs.get("js_json_stringify")
                    .ok_or_else(|| anyhow!("js_json_stringify not declared"))?;
                let func_ref = module.declare_func_in_func(*func, builder.func);

                // Ensure the value is f64 (js_json_stringify expects f64 JSValue)
                // For pointer expressions (arrays, objects), we need to NaN-box them properly
                // Check both Cranelift type (for variables) and expression type (for literals)
                let val_type = builder.func.dfg.value_type(val);
                let is_pointer_expr = matches!(value_expr.as_ref(),
                    Expr::Array(_) | Expr::ArraySpread(_) | Expr::Object(_) |
                    Expr::New { .. } | Expr::MapNew | Expr::SetNew
                ) || match value_expr.as_ref() {
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_pointer || i.is_array).unwrap_or(false),
                    _ => false,
                };

                let val_f64 = if val_type == types::I64 || is_pointer_expr {
                    // NaN-box the pointer so js_json_stringify can recognize it
                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    // If val is f64 (already bitcast), convert back to i64 first
                    let ptr_val = if val_type == types::F64 {
                        builder.ins().bitcast(types::I64, MemFlags::new(), val)
                    } else {
                        val
                    };
                    let call = builder.ins().call(nanbox_ref, &[ptr_val]);
                    builder.inst_results(call)[0]
                } else {
                    val
                };

                let call = builder.ins().call(func_ref, &[val_f64]);
                let result_ptr = builder.inst_results(call)[0];

                // Convert i64 pointer to f64 (NaN-boxed)
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
            }
        }
        // Math operations - using Cranelift's built-in floating-point instructions
        Expr::MathFloor(expr) => {
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
            Ok(builder.ins().floor(val))
        }
        Expr::MathCeil(expr) => {
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
            Ok(builder.ins().ceil(val))
        }
        Expr::MathRound(expr) => {
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
            Ok(builder.ins().nearest(val))
        }
        Expr::MathAbs(expr) => {
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
            Ok(builder.ins().fabs(val))
        }
        Expr::MathSqrt(expr) => {
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
            Ok(builder.ins().sqrt(val))
        }
        Expr::MathPow(base_expr, exp_expr) => {
            let base = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, base_expr, this_ctx)?;
            let exp = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, exp_expr, this_ctx)?;
            // Call js_math_pow runtime function
            let func = extern_funcs.get("js_math_pow")
                .ok_or_else(|| anyhow!("js_math_pow not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[base, exp]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::MathMin(ref args) => {
            if args.is_empty() {
                // Math.min() with no args returns Infinity
                Ok(builder.ins().f64const(f64::INFINITY))
            } else {
                let first_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                // Ensure f64 for fmin (values may be i64 for Any-typed parameters)
                let mut result = ensure_f64(builder, first_val);
                for arg in &args[1..] {
                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                    let val_f64 = ensure_f64(builder, val);
                    result = builder.ins().fmin(result, val_f64);
                }
                Ok(result)
            }
        }
        Expr::MathMax(ref args) => {
            if args.is_empty() {
                // Math.max() with no args returns -Infinity
                Ok(builder.ins().f64const(f64::NEG_INFINITY))
            } else {
                let first_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                // Ensure f64 for fmax (values may be i64 for Any-typed parameters)
                let mut result = ensure_f64(builder, first_val);
                for arg in &args[1..] {
                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                    let val_f64 = ensure_f64(builder, val);
                    result = builder.ins().fmax(result, val_f64);
                }
                Ok(result)
            }
        }
        Expr::MathRandom => {
            // Call js_math_random runtime function
            let func = extern_funcs.get("js_math_random")
                .ok_or_else(|| anyhow!("js_math_random not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            Ok(builder.inst_results(call)[0])
        }
        // Crypto operations
        Expr::CryptoRandomBytes(size_expr) => {
            // Compile size argument (number)
            let size_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, size_expr, this_ctx)?;
            // Call js_crypto_random_bytes_hex runtime function
            let func = extern_funcs.get("js_crypto_random_bytes_hex")
                .ok_or_else(|| anyhow!("js_crypto_random_bytes_hex not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[size_val]);
            let result_ptr = builder.inst_results(call)[0];
            // Convert i64 pointer to f64 (NaN-boxed)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::CryptoRandomUUID => {
            // Call js_crypto_random_uuid runtime function
            let func = extern_funcs.get("js_crypto_random_uuid")
                .ok_or_else(|| anyhow!("js_crypto_random_uuid not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            // Convert i64 pointer to f64 (NaN-boxed)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::CryptoSha256(data_expr) => {
            // Compile data argument (string)
            let data_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, data_expr, this_ctx)?;
            // Convert f64 to i64 pointer for runtime call
            let data_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), data_val);
            // Call js_crypto_sha256 runtime function
            let func = extern_funcs.get("js_crypto_sha256")
                .ok_or_else(|| anyhow!("js_crypto_sha256 not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[data_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            // Convert i64 pointer to f64 (NaN-boxed)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::CryptoMd5(data_expr) => {
            // Compile data argument (string)
            let data_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, data_expr, this_ctx)?;
            // Convert f64 to i64 pointer for runtime call
            let data_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), data_val);
            // Call js_crypto_md5 runtime function
            let func = extern_funcs.get("js_crypto_md5")
                .ok_or_else(|| anyhow!("js_crypto_md5 not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[data_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            // Convert i64 pointer to f64 (NaN-boxed)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        // OS operations
        Expr::OsPlatform => {
            let func = extern_funcs.get("js_os_platform")
                .ok_or_else(|| anyhow!("js_os_platform not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsArch => {
            let func = extern_funcs.get("js_os_arch")
                .ok_or_else(|| anyhow!("js_os_arch not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsHostname => {
            let func = extern_funcs.get("js_os_hostname")
                .ok_or_else(|| anyhow!("js_os_hostname not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsHomedir => {
            let func = extern_funcs.get("js_os_homedir")
                .ok_or_else(|| anyhow!("js_os_homedir not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsTmpdir => {
            let func = extern_funcs.get("js_os_tmpdir")
                .ok_or_else(|| anyhow!("js_os_tmpdir not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsTotalmem => {
            let func = extern_funcs.get("js_os_totalmem")
                .ok_or_else(|| anyhow!("js_os_totalmem not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::OsFreemem => {
            let func = extern_funcs.get("js_os_freemem")
                .ok_or_else(|| anyhow!("js_os_freemem not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::OsUptime => {
            let func = extern_funcs.get("js_os_uptime")
                .ok_or_else(|| anyhow!("js_os_uptime not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::ProcessUptime => {
            let func = extern_funcs.get("js_process_uptime")
                .ok_or_else(|| anyhow!("js_process_uptime not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::ProcessCwd => {
            let func = extern_funcs.get("js_process_cwd")
                .ok_or_else(|| anyhow!("js_process_cwd not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::ProcessArgv => {
            let func = extern_funcs.get("js_process_argv")
                .ok_or_else(|| anyhow!("js_process_argv not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsType => {
            let func = extern_funcs.get("js_os_type")
                .ok_or_else(|| anyhow!("js_os_type not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsRelease => {
            let func = extern_funcs.get("js_os_release")
                .ok_or_else(|| anyhow!("js_os_release not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsCpus => {
            let func = extern_funcs.get("js_os_cpus")
                .ok_or_else(|| anyhow!("js_os_cpus not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsNetworkInterfaces => {
            let func = extern_funcs.get("js_os_network_interfaces")
                .ok_or_else(|| anyhow!("js_os_network_interfaces not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsUserInfo => {
            let func = extern_funcs.get("js_os_user_info")
                .ok_or_else(|| anyhow!("js_os_user_info not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::OsEOL => {
            let func = extern_funcs.get("js_os_eol")
                .ok_or_else(|| anyhow!("js_os_eol not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        // Buffer operations
        Expr::BufferFrom { data, encoding } => {
            let data_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, data, this_ctx)?;
            let data_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), data_val);
            // Encoding: 0=utf8, 1=hex, 2=base64
            let encoding_val = if let Some(enc_expr) = encoding {
                let enc = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, enc_expr, this_ctx)?;
                let enc_f64 = ensure_f64(builder, enc);
                builder.ins().fcvt_to_sint(types::I32, enc_f64)
            } else {
                builder.ins().iconst(types::I32, 0)
            };
            let func = extern_funcs.get("js_buffer_from_string")
                .ok_or_else(|| anyhow!("js_buffer_from_string not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[data_ptr, encoding_val]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::BufferAlloc { size, fill } => {
            let size_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, size, this_ctx)?;
            let size_f64 = ensure_f64(builder, size_val);
            let size_i32 = builder.ins().fcvt_to_sint(types::I32, size_f64);
            let fill_val = if let Some(fill_expr) = fill {
                let f = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, fill_expr, this_ctx)?;
                let f_f64 = ensure_f64(builder, f);
                builder.ins().fcvt_to_sint(types::I32, f_f64)
            } else {
                builder.ins().iconst(types::I32, 0)
            };
            let func = extern_funcs.get("js_buffer_alloc")
                .ok_or_else(|| anyhow!("js_buffer_alloc not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[size_i32, fill_val]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::BufferAllocUnsafe(size) => {
            let size_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, size, this_ctx)?;
            let size_f64 = ensure_f64(builder, size_val);
            let size_i32 = builder.ins().fcvt_to_sint(types::I32, size_f64);
            let func = extern_funcs.get("js_buffer_alloc_unsafe")
                .ok_or_else(|| anyhow!("js_buffer_alloc_unsafe not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[size_i32]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::BufferConcat(list) => {
            let list_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, list, this_ctx)?;
            let list_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), list_val);
            let func = extern_funcs.get("js_buffer_concat")
                .ok_or_else(|| anyhow!("js_buffer_concat not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[list_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::BufferIsBuffer(obj) => {
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, obj, this_ctx)?;
            let obj_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), obj_val);
            let func = extern_funcs.get("js_buffer_is_buffer")
                .ok_or_else(|| anyhow!("js_buffer_is_buffer not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[obj_ptr]);
            let result_i32 = builder.inst_results(call)[0];
            // Convert i32 to f64 boolean (0.0 or 1.0)
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::BufferByteLength(string) => {
            let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, string, this_ctx)?;
            let str_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), str_val);
            let func = extern_funcs.get("js_buffer_byte_length")
                .ok_or_else(|| anyhow!("js_buffer_byte_length not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[str_ptr]);
            let result_i32 = builder.inst_results(call)[0];
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::BufferToString { buffer, encoding } => {
            let buf_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, buffer, this_ctx)?;
            let buf_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf_val);
            let encoding_val = if let Some(enc_expr) = encoding {
                let enc = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, enc_expr, this_ctx)?;
                let enc_f64 = ensure_f64(builder, enc);
                builder.ins().fcvt_to_sint(types::I32, enc_f64)
            } else {
                builder.ins().iconst(types::I32, 0)
            };
            let func = extern_funcs.get("js_buffer_to_string")
                .ok_or_else(|| anyhow!("js_buffer_to_string not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[buf_ptr, encoding_val]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::BufferLength(buffer) => {
            let buf_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, buffer, this_ctx)?;
            let buf_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf_val);
            let func = extern_funcs.get("js_buffer_length")
                .ok_or_else(|| anyhow!("js_buffer_length not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[buf_ptr]);
            let result_i32 = builder.inst_results(call)[0];
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::BufferSlice { buffer, start, end } => {
            let buf_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, buffer, this_ctx)?;
            let buf_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf_val);
            let start_val = if let Some(s) = start {
                let sv = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, s, this_ctx)?;
                let sv_f64 = ensure_f64(builder, sv);
                builder.ins().fcvt_to_sint(types::I32, sv_f64)
            } else {
                builder.ins().iconst(types::I32, 0)
            };
            let end_val = if let Some(e) = end {
                let ev = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, e, this_ctx)?;
                let ev_f64 = ensure_f64(builder, ev);
                builder.ins().fcvt_to_sint(types::I32, ev_f64)
            } else {
                builder.ins().iconst(types::I32, i32::MAX as i64)
            };
            let func = extern_funcs.get("js_buffer_slice")
                .ok_or_else(|| anyhow!("js_buffer_slice not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[buf_ptr, start_val, end_val]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::BufferCopy { source, target, target_start, source_start, source_end } => {
            let src_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, source, this_ctx)?;
            let src_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), src_val);
            let dst_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, target, this_ctx)?;
            let dst_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), dst_val);
            let ts = if let Some(t) = target_start {
                let tv = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, t, this_ctx)?;
                let tv_f64 = ensure_f64(builder, tv);
                builder.ins().fcvt_to_sint(types::I32, tv_f64)
            } else {
                builder.ins().iconst(types::I32, 0)
            };
            let ss = if let Some(s) = source_start {
                let sv = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, s, this_ctx)?;
                let sv_f64 = ensure_f64(builder, sv);
                builder.ins().fcvt_to_sint(types::I32, sv_f64)
            } else {
                builder.ins().iconst(types::I32, 0)
            };
            let se = if let Some(e) = source_end {
                let ev = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, e, this_ctx)?;
                let ev_f64 = ensure_f64(builder, ev);
                builder.ins().fcvt_to_sint(types::I32, ev_f64)
            } else {
                builder.ins().iconst(types::I32, -1)
            };
            let func = extern_funcs.get("js_buffer_copy")
                .ok_or_else(|| anyhow!("js_buffer_copy not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[src_ptr, dst_ptr, ts, ss, se]);
            let result_i32 = builder.inst_results(call)[0];
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::BufferWrite { buffer, string, offset, encoding } => {
            let buf_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, buffer, this_ctx)?;
            let buf_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf_val);
            let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, string, this_ctx)?;
            let str_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), str_val);
            let off = if let Some(o) = offset {
                let ov = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, o, this_ctx)?;
                let ov_f64 = ensure_f64(builder, ov);
                builder.ins().fcvt_to_sint(types::I32, ov_f64)
            } else {
                builder.ins().iconst(types::I32, 0)
            };
            let enc = if let Some(e) = encoding {
                let ev = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, e, this_ctx)?;
                let ev_f64 = ensure_f64(builder, ev);
                builder.ins().fcvt_to_sint(types::I32, ev_f64)
            } else {
                builder.ins().iconst(types::I32, 0)
            };
            let func = extern_funcs.get("js_buffer_write")
                .ok_or_else(|| anyhow!("js_buffer_write not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[buf_ptr, str_ptr, off, enc]);
            let result_i32 = builder.inst_results(call)[0];
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::BufferEquals { buffer, other } => {
            let buf1_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, buffer, this_ctx)?;
            let buf1_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf1_val);
            let buf2_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, other, this_ctx)?;
            let buf2_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf2_val);
            let func = extern_funcs.get("js_buffer_equals")
                .ok_or_else(|| anyhow!("js_buffer_equals not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[buf1_ptr, buf2_ptr]);
            let result_i32 = builder.inst_results(call)[0];
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::BufferIndexGet { buffer, index } => {
            let buf_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, buffer, this_ctx)?;
            let buf_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf_val);
            let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
            let idx_f64 = ensure_f64(builder, idx_val);
            let idx_i32 = builder.ins().fcvt_to_sint(types::I32, idx_f64);
            let func = extern_funcs.get("js_buffer_get")
                .ok_or_else(|| anyhow!("js_buffer_get not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[buf_ptr, idx_i32]);
            let result_i32 = builder.inst_results(call)[0];
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::BufferIndexSet { buffer, index, value } => {
            let buf_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, buffer, this_ctx)?;
            let buf_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf_val);
            let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
            let idx_f64 = ensure_f64(builder, idx_val);
            let idx_i32 = builder.ins().fcvt_to_sint(types::I32, idx_f64);
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
            let val_f64 = ensure_f64(builder, val);
            let val_i32 = builder.ins().fcvt_to_sint(types::I32, val_f64);
            let func = extern_funcs.get("js_buffer_set")
                .ok_or_else(|| anyhow!("js_buffer_set not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            builder.ins().call(func_ref, &[buf_ptr, idx_i32, val_i32]);
            // Return undefined (the value is stored, expression evaluates to nothing)
            Ok(builder.ins().f64const(f64::NAN))
        }
        // Uint8Array operations
        Expr::Uint8ArrayNew(arg) => {
            // new Uint8Array() or new Uint8Array(length) or new Uint8Array(array)
            // For now, we'll reuse buffer operations as Uint8Array is conceptually similar
            if let Some(a) = arg {
                let arg_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, a, this_ctx)?;
                // Check if arg is a number (allocate that size) or an array (convert from array)
                // For now, treat it as an array and use buffer_from_array
                let arg_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_val);
                let func = extern_funcs.get("js_buffer_from_array")
                    .ok_or_else(|| anyhow!("js_buffer_from_array not declared"))?;
                let func_ref = module.declare_func_in_func(*func, builder.func);
                let call = builder.ins().call(func_ref, &[arg_ptr]);
                let result_ptr = builder.inst_results(call)[0];
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
            } else {
                // Empty Uint8Array - allocate 0 bytes
                let size = builder.ins().iconst(types::I32, 0);
                let fill = builder.ins().iconst(types::I32, 0);
                let func = extern_funcs.get("js_buffer_alloc")
                    .ok_or_else(|| anyhow!("js_buffer_alloc not declared"))?;
                let func_ref = module.declare_func_in_func(*func, builder.func);
                let call = builder.ins().call(func_ref, &[size, fill]);
                let result_ptr = builder.inst_results(call)[0];
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
            }
        }
        Expr::Uint8ArrayFrom(data) => {
            // Uint8Array.from(arrayLike) - same as buffer_from_array
            let data_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, data, this_ctx)?;
            let data_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), data_val);
            let func = extern_funcs.get("js_buffer_from_array")
                .ok_or_else(|| anyhow!("js_buffer_from_array not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[data_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::Uint8ArrayLength(array) => {
            // Reuse buffer length
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;
            let arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arr_val);
            let func = extern_funcs.get("js_buffer_length")
                .ok_or_else(|| anyhow!("js_buffer_length not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr]);
            let result_i32 = builder.inst_results(call)[0];
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::Uint8ArrayGet { array, index } => {
            // Reuse buffer get
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;
            let arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arr_val);
            let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
            let idx_f64 = ensure_f64(builder, idx_val);
            let idx_i32 = builder.ins().fcvt_to_sint(types::I32, idx_f64);
            let func = extern_funcs.get("js_buffer_get")
                .ok_or_else(|| anyhow!("js_buffer_get not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, idx_i32]);
            let result_i32 = builder.inst_results(call)[0];
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::Uint8ArraySet { array, index, value } => {
            // Reuse buffer set
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;
            let arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arr_val);
            let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
            let idx_f64 = ensure_f64(builder, idx_val);
            let idx_i32 = builder.ins().fcvt_to_sint(types::I32, idx_f64);
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
            let val_f64 = ensure_f64(builder, val);
            let val_i32 = builder.ins().fcvt_to_sint(types::I32, val_f64);
            let func = extern_funcs.get("js_buffer_set")
                .ok_or_else(|| anyhow!("js_buffer_set not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            builder.ins().call(func_ref, &[arr_ptr, idx_i32, val_i32]);
            Ok(builder.ins().f64const(f64::NAN))
        }
        // Child Process operations
        Expr::ChildProcessExecSync { command, options } => {
            let cmd_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, command, this_ctx)?;
            let cmd_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), cmd_val);
            let opts_ptr = if let Some(opts) = options {
                let ov = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, opts, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), ov)
            } else {
                builder.ins().iconst(types::I64, 0)
            };
            let func = extern_funcs.get("js_child_process_exec_sync")
                .ok_or_else(|| anyhow!("js_child_process_exec_sync not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[cmd_ptr, opts_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::ChildProcessSpawnSync { command, args, options } => {
            let cmd_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, command, this_ctx)?;
            let cmd_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), cmd_val);
            let args_ptr = if let Some(a) = args {
                let av = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, a, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), av)
            } else {
                builder.ins().iconst(types::I64, 0)
            };
            let opts_ptr = if let Some(opts) = options {
                let ov = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, opts, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), ov)
            } else {
                builder.ins().iconst(types::I64, 0)
            };
            let func = extern_funcs.get("js_child_process_spawn_sync")
                .ok_or_else(|| anyhow!("js_child_process_spawn_sync not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[cmd_ptr, args_ptr, opts_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::ChildProcessSpawn { .. } | Expr::ChildProcessExec { .. } => {
            // Async child processes are not fully supported yet
            // Return null/undefined for now
            Ok(builder.ins().f64const(f64::NAN))
        }
        // Fetch operations
        Expr::FetchWithOptions { url, method, body, headers } => {
            // Get string pointer extraction function
            let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
            let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);

            // Compile URL string and extract pointer from NaN-boxed value
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url, this_ctx)?;
            let url_f64 = ensure_f64(builder, url_val);
            let url_call = builder.ins().call(get_str_ref, &[url_f64]);
            let url_ptr = builder.inst_results(url_call)[0];

            // Compile method string and extract pointer
            let method_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, method, this_ctx)?;
            let method_f64 = ensure_f64(builder, method_val);
            let method_call = builder.ins().call(get_str_ref, &[method_f64]);
            let method_ptr = builder.inst_results(method_call)[0];

            // Compile body (can be Undefined or a string)
            let body_ptr = if matches!(body.as_ref(), Expr::Undefined) {
                builder.ins().iconst(types::I64, 0)
            } else {
                let body_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, body, this_ctx)?;
                let body_f64 = ensure_f64(builder, body_val);
                let body_call = builder.ins().call(get_str_ref, &[body_f64]);
                builder.inst_results(body_call)[0]
            };

            // Build headers JSON string at runtime to support dynamic values
            // Helper to create a literal string
            let create_literal_string = |builder: &mut FunctionBuilder, s: &str| -> Value {
                let bytes = s.as_bytes();
                let len = bytes.len();
                let slot = builder.create_sized_stack_slot(StackSlotData::new(
                    StackSlotKind::ExplicitSlot,
                    len as u32,
                    0,
                ));
                let mut offset = 0usize;
                while offset + 8 <= len {
                    let chunk = &bytes[offset..offset + 8];
                    let val = u64::from_le_bytes(chunk.try_into().unwrap());
                    let val_i64 = builder.ins().iconst(types::I64, val as i64);
                    builder.ins().stack_store(val_i64, slot, offset as i32);
                    offset += 8;
                }
                while offset < len {
                    let byte_val = builder.ins().iconst(types::I8, bytes[offset] as i64);
                    builder.ins().stack_store(byte_val, slot, offset as i32);
                    offset += 1;
                }
                builder.ins().stack_addr(types::I64, slot, 0)
            };

            // Get string concat and alloc functions
            let string_concat_func = extern_funcs.get("js_string_concat")
                .ok_or_else(|| anyhow!("js_string_concat not declared"))?;
            let string_concat_ref = module.declare_func_in_func(*string_concat_func, builder.func);
            let string_alloc_func = extern_funcs.get("js_string_from_bytes")
                .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
            let string_alloc_ref = module.declare_func_in_func(*string_alloc_func, builder.func);

            // Start with "{"
            let open_brace = create_literal_string(builder, "{");
            let open_brace_len = builder.ins().iconst(types::I32, 1);
            let call = builder.ins().call(string_alloc_ref, &[open_brace, open_brace_len]);
            let mut result = builder.inst_results(call)[0];

            for (i, (key, val)) in headers.iter().enumerate() {
                // Add comma separator if not first
                if i > 0 {
                    let comma = create_literal_string(builder, ",");
                    let comma_len = builder.ins().iconst(types::I32, 1);
                    let call = builder.ins().call(string_alloc_ref, &[comma, comma_len]);
                    let comma_str = builder.inst_results(call)[0];
                    let call = builder.ins().call(string_concat_ref, &[result, comma_str]);
                    result = builder.inst_results(call)[0];
                }

                // Add "key":
                let mut key_part = String::from("\"");
                for c in key.chars() {
                    match c {
                        '"' => key_part.push_str("\\\""),
                        '\\' => key_part.push_str("\\\\"),
                        _ => key_part.push(c),
                    }
                }
                key_part.push_str("\":\"");
                let key_addr = create_literal_string(builder, &key_part);
                let key_len = builder.ins().iconst(types::I32, key_part.len() as i64);
                let call = builder.ins().call(string_alloc_ref, &[key_addr, key_len]);
                let key_str = builder.inst_results(call)[0];
                let call = builder.ins().call(string_concat_ref, &[result, key_str]);
                result = builder.inst_results(call)[0];

                // Compile and add the value - use js_ensure_string_ptr to handle all string types
                let val_compiled = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, val, this_ctx)?;
                let val_f64 = ensure_f64(builder, val_compiled);
                // Convert to native string pointer - handles raw pointers, NaN-boxed strings, and JS handles
                let ensure_str_func = extern_funcs.get("js_ensure_string_ptr")
                    .ok_or_else(|| anyhow!("js_ensure_string_ptr not declared"))?;
                let ensure_str_ref = module.declare_func_in_func(*ensure_str_func, builder.func);
                let call = builder.ins().call(ensure_str_ref, &[val_f64]);
                let val_ptr = builder.inst_results(call)[0];
                let call = builder.ins().call(string_concat_ref, &[result, val_ptr]);
                result = builder.inst_results(call)[0];

                // Add closing quote
                let quote = create_literal_string(builder, "\"");
                let quote_len = builder.ins().iconst(types::I32, 1);
                let call = builder.ins().call(string_alloc_ref, &[quote, quote_len]);
                let quote_str = builder.inst_results(call)[0];
                let call = builder.ins().call(string_concat_ref, &[result, quote_str]);
                result = builder.inst_results(call)[0];
            }

            // Add closing "}"
            let close_brace = create_literal_string(builder, "}");
            let close_brace_len = builder.ins().iconst(types::I32, 1);
            let call = builder.ins().call(string_alloc_ref, &[close_brace, close_brace_len]);
            let close_str = builder.inst_results(call)[0];
            let call = builder.ins().call(string_concat_ref, &[result, close_str]);
            let headers_json = builder.inst_results(call)[0];

            // Call js_fetch_with_options(url, method, body, headers_json)
            let func = extern_funcs.get("js_fetch_with_options")
                .ok_or_else(|| anyhow!("js_fetch_with_options not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr, method_ptr, body_ptr, headers_json]);
            let result_ptr = builder.inst_results(call)[0];
            // Return Promise pointer as f64
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        // Net operations
        Expr::NetCreateServer { options, connection_listener } => {
            let opts_ptr = if let Some(opts) = options {
                let ov = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, opts, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), ov)
            } else {
                builder.ins().iconst(types::I64, 0)
            };
            let listener_ptr = if let Some(l) = connection_listener {
                let lv = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, l, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), lv)
            } else {
                builder.ins().iconst(types::I64, 0)
            };
            let func = extern_funcs.get("js_net_create_server")
                .ok_or_else(|| anyhow!("js_net_create_server not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[opts_ptr, listener_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::NetCreateConnection { port, host, connect_listener } | Expr::NetConnect { port, host, connect_listener } => {
            let port_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, port, this_ctx)?;
            let port_f64 = ensure_f64(builder, port_val);
            let port_i32 = builder.ins().fcvt_to_sint(types::I32, port_f64);
            let host_ptr = if let Some(h) = host {
                let hv = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, h, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), hv)
            } else {
                builder.ins().iconst(types::I64, 0)
            };
            let listener_ptr = if let Some(l) = connect_listener {
                let lv = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, l, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), lv)
            } else {
                builder.ins().iconst(types::I64, 0)
            };
            let func = extern_funcs.get("js_net_create_connection")
                .ok_or_else(|| anyhow!("js_net_create_connection not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[port_i32, host_ptr, listener_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        // Date operations
        Expr::DateNow => {
            // Call js_date_now runtime function
            let func = extern_funcs.get("js_date_now")
                .ok_or_else(|| anyhow!("js_date_now not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::DateNew(timestamp_opt) => {
            match timestamp_opt {
                None => {
                    // new Date() - current time
                    let func = extern_funcs.get("js_date_new")
                        .ok_or_else(|| anyhow!("js_date_new not declared"))?;
                    let func_ref = module.declare_func_in_func(*func, builder.func);
                    let call = builder.ins().call(func_ref, &[]);
                    Ok(builder.inst_results(call)[0])
                }
                Some(ts_expr) => {
                    // new Date(timestamp)
                    let ts_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, ts_expr, this_ctx)?;
                    let func = extern_funcs.get("js_date_new_from_timestamp")
                        .ok_or_else(|| anyhow!("js_date_new_from_timestamp not declared"))?;
                    let func_ref = module.declare_func_in_func(*func, builder.func);
                    let call = builder.ins().call(func_ref, &[ts_val]);
                    Ok(builder.inst_results(call)[0])
                }
            }
        }
        Expr::DateGetTime(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_get_time")
                .ok_or_else(|| anyhow!("js_date_get_time not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::DateToISOString(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_to_iso_string")
                .ok_or_else(|| anyhow!("js_date_to_iso_string not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            let result_ptr = builder.inst_results(call)[0];
            // Convert i64 pointer to f64 (NaN-boxed)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::DateGetFullYear(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_get_full_year")
                .ok_or_else(|| anyhow!("js_date_get_full_year not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::DateGetMonth(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_get_month")
                .ok_or_else(|| anyhow!("js_date_get_month not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::DateGetDate(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_get_date")
                .ok_or_else(|| anyhow!("js_date_get_date not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::DateGetHours(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_get_hours")
                .ok_or_else(|| anyhow!("js_date_get_hours not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::DateGetMinutes(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_get_minutes")
                .ok_or_else(|| anyhow!("js_date_get_minutes not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::DateGetSeconds(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_get_seconds")
                .ok_or_else(|| anyhow!("js_date_get_seconds not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::DateGetMilliseconds(date_expr) => {
            let date_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, date_expr, this_ctx)?;
            let func = extern_funcs.get("js_date_get_milliseconds")
                .ok_or_else(|| anyhow!("js_date_get_milliseconds not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[date_val]);
            Ok(builder.inst_results(call)[0])
        }
        // Error operations
        Expr::ErrorNew(message_opt) => {
            match message_opt {
                None => {
                    // new Error() - empty message
                    let func = extern_funcs.get("js_error_new")
                        .ok_or_else(|| anyhow!("js_error_new not declared"))?;
                    let func_ref = module.declare_func_in_func(*func, builder.func);
                    let call = builder.ins().call(func_ref, &[]);
                    let error_ptr = builder.inst_results(call)[0];
                    // NaN-box the error pointer so typeof recognizes it as an object
                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[error_ptr]);
                    Ok(builder.inst_results(call)[0])
                }
                Some(msg_expr) => {
                    // new Error(message)
                    let msg_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, msg_expr, this_ctx)?;
                    // Extract string pointer from NaN-boxed value using unified extractor
                    let msg_f64 = ensure_f64(builder, msg_val);
                    let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                        .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                    let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                    let str_call = builder.ins().call(get_str_ptr_ref, &[msg_f64]);
                    let msg_ptr = builder.inst_results(str_call)[0];
                    let func = extern_funcs.get("js_error_new_with_message")
                        .ok_or_else(|| anyhow!("js_error_new_with_message not declared"))?;
                    let func_ref = module.declare_func_in_func(*func, builder.func);
                    let call = builder.ins().call(func_ref, &[msg_ptr]);
                    let error_ptr = builder.inst_results(call)[0];
                    // NaN-box the error pointer so typeof recognizes it as an object
                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[error_ptr]);
                    Ok(builder.inst_results(call)[0])
                }
            }
        }
        Expr::ErrorMessage(error_expr) => {
            let error_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, error_expr, this_ctx)?;
            // Error is now NaN-boxed, so extract the pointer properly
            let error_f64 = ensure_f64(builder, error_val);
            let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
            let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
            let call = builder.ins().call(get_ptr_ref, &[error_f64]);
            let error_ptr = builder.inst_results(call)[0];
            let func = extern_funcs.get("js_error_get_message")
                .ok_or_else(|| anyhow!("js_error_get_message not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[error_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            // NaN-box the result string
            let nanbox_func = extern_funcs.get("js_nanbox_string")
                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let call = builder.ins().call(nanbox_ref, &[result_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        // URL operations
        Expr::UrlNew { url, base } => {
            // Compile the URL string argument
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);

            match base {
                None => {
                    // new URL(url)
                    let func = extern_funcs.get("js_url_new")
                        .ok_or_else(|| anyhow!("js_url_new not declared"))?;
                    let func_ref = module.declare_func_in_func(*func, builder.func);
                    let call = builder.ins().call(func_ref, &[url_ptr]);
                    let result_ptr = builder.inst_results(call)[0];
                    Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
                }
                Some(base_expr) => {
                    // new URL(url, base)
                    let base_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, base_expr, this_ctx)?;
                    let base_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), base_val);
                    let func = extern_funcs.get("js_url_new_with_base")
                        .ok_or_else(|| anyhow!("js_url_new_with_base not declared"))?;
                    let func_ref = module.declare_func_in_func(*func, builder.func);
                    let call = builder.ins().call(func_ref, &[url_ptr, base_ptr]);
                    let result_ptr = builder.inst_results(call)[0];
                    Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
                }
            }
        }
        Expr::UrlGetHref(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_href")
                .ok_or_else(|| anyhow!("js_url_get_href not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetPathname(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_pathname")
                .ok_or_else(|| anyhow!("js_url_get_pathname not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetProtocol(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_protocol")
                .ok_or_else(|| anyhow!("js_url_get_protocol not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetHost(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_host")
                .ok_or_else(|| anyhow!("js_url_get_host not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetHostname(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_hostname")
                .ok_or_else(|| anyhow!("js_url_get_hostname not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetPort(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_port")
                .ok_or_else(|| anyhow!("js_url_get_port not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetSearch(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_search")
                .ok_or_else(|| anyhow!("js_url_get_search not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetHash(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_hash")
                .ok_or_else(|| anyhow!("js_url_get_hash not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetOrigin(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_origin")
                .ok_or_else(|| anyhow!("js_url_get_origin not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::UrlGetSearchParams(url_expr) => {
            let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, url_expr, this_ctx)?;
            let url_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);
            let func = extern_funcs.get("js_url_get_search_params")
                .ok_or_else(|| anyhow!("js_url_get_search_params not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[url_ptr]);
            let result_ptr = builder.inst_results(call)[0];
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        // Delete operator
        Expr::Delete(operand) => {
            // The delete operator removes a property from an object
            // Returns true if deleted, false otherwise
            match operand.as_ref() {
                Expr::PropertyGet { object, property } => {
                    // delete obj.prop
                    let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                    let obj_ptr = ensure_i64(builder, obj_val);

                    // Create string for property name
                    let prop_bytes = property.as_bytes();
                    let prop_len = prop_bytes.len();
                    let slot = builder.create_sized_stack_slot(StackSlotData::new(
                        StackSlotKind::ExplicitSlot,
                        prop_len as u32,
                        0,
                    ));
                    for (i, &byte) in prop_bytes.iter().enumerate() {
                        let byte_val = builder.ins().iconst(types::I8, byte as i64);
                        builder.ins().stack_store(byte_val, slot, i as i32);
                    }
                    let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
                    let alloc_func = extern_funcs.get("js_string_from_bytes")
                        .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
                    let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                    let len_val = builder.ins().iconst(types::I32, prop_len as i64);
                    let call = builder.ins().call(alloc_ref, &[slot_addr, len_val]);
                    let prop_str_ptr = builder.inst_results(call)[0];

                    // Call js_object_delete_field
                    let delete_func = extern_funcs.get("js_object_delete_field")
                        .ok_or_else(|| anyhow!("js_object_delete_field not declared"))?;
                    let delete_ref = module.declare_func_in_func(*delete_func, builder.func);
                    let call = builder.ins().call(delete_ref, &[obj_ptr, prop_str_ptr]);
                    let result = builder.inst_results(call)[0];
                    // Convert i32 (0 or 1) to f64 boolean
                    Ok(builder.ins().fcvt_from_sint(types::F64, result))
                }
                Expr::IndexGet { object, index } => {
                    // delete obj["prop"] or delete arr[index]
                    let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                    let obj_ptr = ensure_i64(builder, obj_val);
                    let index_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;

                    // Call js_object_delete_dynamic
                    let delete_func = extern_funcs.get("js_object_delete_dynamic")
                        .ok_or_else(|| anyhow!("js_object_delete_dynamic not declared"))?;
                    let delete_ref = module.declare_func_in_func(*delete_func, builder.func);
                    let call = builder.ins().call(delete_ref, &[obj_ptr, index_val]);
                    let result = builder.inst_results(call)[0];
                    // Convert i32 (0 or 1) to f64 boolean
                    Ok(builder.ins().fcvt_from_sint(types::F64, result))
                }
                _ => {
                    // delete on non-member/index always returns true in non-strict mode
                    Ok(builder.ins().f64const(1.0))
                }
            }
        }
        // URLSearchParams operations
        Expr::UrlSearchParamsNew(init) => {
            match init {
                None => {
                    // new URLSearchParams() - empty
                    let new_func = extern_funcs.get("js_url_search_params_new_empty")
                        .ok_or_else(|| anyhow!("js_url_search_params_new_empty not declared"))?;
                    let func_ref = module.declare_func_in_func(*new_func, builder.func);
                    let call = builder.ins().call(func_ref, &[]);
                    let handle = builder.inst_results(call)[0];
                    Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle))
                }
                Some(init_expr) => {
                    // new URLSearchParams(init)
                    let init_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, init_expr, this_ctx)?;
                    let init_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), init_val);

                    let new_func = extern_funcs.get("js_url_search_params_new")
                        .ok_or_else(|| anyhow!("js_url_search_params_new not declared"))?;
                    let func_ref = module.declare_func_in_func(*new_func, builder.func);
                    let call = builder.ins().call(func_ref, &[init_i64]);
                    let handle = builder.inst_results(call)[0];
                    Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle))
                }
            }
        }
        Expr::UrlSearchParamsGet { params, name } => {
            let params_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, params, this_ctx)?;
            let params_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), params_val);
            let name_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, name, this_ctx)?;
            let name_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), name_val);

            let func = extern_funcs.get("js_url_search_params_get")
                .ok_or_else(|| anyhow!("js_url_search_params_get not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[params_ptr, name_ptr]);
            let str_ptr = builder.inst_results(call)[0]; // i64 string pointer (or null)
            // Bitcast to f64 for storage
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), str_ptr))
        }
        Expr::UrlSearchParamsHas { params, name } => {
            let params_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, params, this_ctx)?;
            let params_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), params_val);
            let name_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, name, this_ctx)?;
            let name_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), name_val);

            let func = extern_funcs.get("js_url_search_params_has")
                .ok_or_else(|| anyhow!("js_url_search_params_has not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[params_ptr, name_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::UrlSearchParamsSet { params, name, value } => {
            let params_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, params, this_ctx)?;
            let params_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), params_val);
            let name_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, name, this_ctx)?;
            let name_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), name_val);
            let value_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
            let value_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), value_val);

            let func = extern_funcs.get("js_url_search_params_set")
                .ok_or_else(|| anyhow!("js_url_search_params_set not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            builder.ins().call(func_ref, &[params_ptr, name_ptr, value_ptr]);
            // Return undefined
            Ok(builder.ins().f64const(f64::NAN))
        }
        Expr::UrlSearchParamsAppend { params, name, value } => {
            let params_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, params, this_ctx)?;
            let params_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), params_val);
            let name_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, name, this_ctx)?;
            let name_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), name_val);
            let value_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
            let value_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), value_val);

            let func = extern_funcs.get("js_url_search_params_append")
                .ok_or_else(|| anyhow!("js_url_search_params_append not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            builder.ins().call(func_ref, &[params_ptr, name_ptr, value_ptr]);
            // Return undefined
            Ok(builder.ins().f64const(f64::NAN))
        }
        Expr::UrlSearchParamsDelete { params, name } => {
            let params_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, params, this_ctx)?;
            let params_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), params_val);
            let name_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, name, this_ctx)?;
            let name_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), name_val);

            let func = extern_funcs.get("js_url_search_params_delete")
                .ok_or_else(|| anyhow!("js_url_search_params_delete not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            builder.ins().call(func_ref, &[params_ptr, name_ptr]);
            // Return undefined
            Ok(builder.ins().f64const(f64::NAN))
        }
        Expr::UrlSearchParamsToString(params) => {
            let params_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, params, this_ctx)?;
            let params_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), params_val);

            let func = extern_funcs.get("js_url_search_params_to_string")
                .ok_or_else(|| anyhow!("js_url_search_params_to_string not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[params_ptr]);
            let str_ptr = builder.inst_results(call)[0]; // i64 string pointer
            // Bitcast to f64 for storage (as other string functions do)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), str_ptr))
        }
        Expr::UrlSearchParamsGetAll { params, name } => {
            let params_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, params, this_ctx)?;
            let params_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), params_val);
            let name_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, name, this_ctx)?;
            let name_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), name_val);

            let func = extern_funcs.get("js_url_search_params_get_all")
                .ok_or_else(|| anyhow!("js_url_search_params_get_all not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[params_ptr, name_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        // RegExp literal: /pattern/flags
        Expr::RegExp { pattern, flags } => {
            // Use unique ID for each regex data to avoid name collisions
            let regex_id = next_regex_data_id();

            // Create string data for pattern
            let pattern_data_id = {
                let mut data_desc = DataDescription::new();
                data_desc.define(pattern.as_bytes().to_vec().into_boxed_slice());
                let name = format!("__regex_pattern_{}", regex_id);
                let data_id = module.declare_data(&name, Linkage::Local, false, false)?;
                module.define_data(data_id, &data_desc)?;
                data_id
            };

            // Create string data for flags
            let flags_data_id = {
                let mut data_desc = DataDescription::new();
                data_desc.define(flags.as_bytes().to_vec().into_boxed_slice());
                let name = format!("__regex_flags_{}", regex_id);
                let data_id = module.declare_data(&name, Linkage::Local, false, false)?;
                module.define_data(data_id, &data_desc)?;
                data_id
            };

            // Get pointers to the string data
            let pattern_gv = module.declare_data_in_func(pattern_data_id, builder.func);
            let pattern_ptr = builder.ins().symbol_value(types::I64, pattern_gv);
            let pattern_len = builder.ins().iconst(types::I32, pattern.len() as i64);

            let flags_gv = module.declare_data_in_func(flags_data_id, builder.func);
            let flags_ptr = builder.ins().symbol_value(types::I64, flags_gv);
            let flags_len = builder.ins().iconst(types::I32, flags.len() as i64);

            // Call js_string_from_bytes for both strings
            let str_func = extern_funcs.get("js_string_from_bytes")
                .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
            let str_func_ref = module.declare_func_in_func(*str_func, builder.func);

            let pattern_call = builder.ins().call(str_func_ref, &[pattern_ptr, pattern_len]);
            let pattern_str = builder.inst_results(pattern_call)[0];

            let flags_call = builder.ins().call(str_func_ref, &[flags_ptr, flags_len]);
            let flags_str = builder.inst_results(flags_call)[0];

            // Call js_regexp_new to create the RegExp
            let regexp_func = extern_funcs.get("js_regexp_new")
                .ok_or_else(|| anyhow!("js_regexp_new not declared"))?;
            let regexp_func_ref = module.declare_func_in_func(*regexp_func, builder.func);
            let call = builder.ins().call(regexp_func_ref, &[pattern_str, flags_str]);
            let regexp_ptr = builder.inst_results(call)[0];

            // Return as f64 (bitcast the pointer)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), regexp_ptr))
        }
        // regex.test(string) -> boolean
        Expr::RegExpTest { regex, string } => {
            // Compile regex and string expressions
            let regex_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, regex, this_ctx)?;
            let string_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, string, this_ctx)?;

            // Extract string pointer from NaN-boxed value
            let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
            let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
            let regex_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), regex_val);
            let string_f64 = ensure_f64(builder, string_val);
            let string_call = builder.ins().call(get_str_ref, &[string_f64]);
            let string_ptr = builder.inst_results(string_call)[0];

            // Call js_regexp_test
            let func = extern_funcs.get("js_regexp_test")
                .ok_or_else(|| anyhow!("js_regexp_test not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[regex_ptr, string_ptr]);
            let result_i32 = builder.inst_results(call)[0];

            // Convert bool (i32) to f64 (0.0 or 1.0)
            Ok(builder.ins().fcvt_from_uint(types::F64, result_i32))
        }
        // string.match(regex) -> string[] | null
        Expr::StringMatch { string, regex } => {
            // Compile string and regex expressions
            let string_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, string, this_ctx)?;
            let regex_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, regex, this_ctx)?;

            // Extract string pointer from NaN-boxed value
            let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
            let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
            let string_f64 = ensure_f64(builder, string_val);
            let string_call = builder.ins().call(get_str_ref, &[string_f64]);
            let string_ptr = builder.inst_results(string_call)[0];
            let regex_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), regex_val);

            // Call js_string_match
            let func = extern_funcs.get("js_string_match")
                .ok_or_else(|| anyhow!("js_string_match not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[string_ptr, regex_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            // Return as f64 (bitcast the pointer, null becomes 0.0)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        // string.replace(pattern, replacement) -> string
        Expr::StringReplace { string, pattern, replacement } => {
            // Compile all expressions
            let string_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, string, this_ctx)?;
            let pattern_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, pattern, this_ctx)?;
            let replacement_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, replacement, this_ctx)?;

            // Extract string pointers from NaN-boxed values
            let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
            let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
            let string_f64 = ensure_f64(builder, string_val);
            let string_call = builder.ins().call(get_str_ref, &[string_f64]);
            let string_ptr = builder.inst_results(string_call)[0];
            let replacement_f64 = ensure_f64(builder, replacement_val);
            let replacement_call = builder.ins().call(get_str_ref, &[replacement_f64]);
            let replacement_ptr = builder.inst_results(replacement_call)[0];
            let pattern_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), pattern_val);

            // Call js_string_replace_regex (treats pattern as regex pointer)
            let func = extern_funcs.get("js_string_replace_regex")
                .ok_or_else(|| anyhow!("js_string_replace_regex not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[string_ptr, pattern_ptr, replacement_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            // Return as f64 (bitcast the pointer)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::ArrayPush { array_id, value } => {
            // Get the array pointer
            let info = locals.get(array_id)
                .ok_or_else(|| anyhow!("Undefined array variable: {}", array_id))?;
            let arr_val = builder.use_var(info.var);
            let arr_ptr = ensure_i64(builder, arr_val);

            // Compile the value
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Determine if value is a pointer type (object, array, string, etc.)
            // In that case we need to use js_array_push_jsvalue (i64) instead of js_array_push_f64
            let val_type = builder.func.dfg.value_type(val);
            let (func_name, push_val) = if val_type == types::I64 {
                // Value is a pointer (i64) - use js_array_push_jsvalue
                ("js_array_push_jsvalue", val)
            } else {
                // Check if the value expression produces a pointer type (Object, New, etc.)
                let is_pointer_expr = matches!(value.as_ref(),
                    Expr::Object(_) | Expr::Array(_) | Expr::ArraySpread(_) |
                    Expr::New { .. } | Expr::MapNew | Expr::SetNew |
                    Expr::JsonParse(_) | Expr::Closure { .. });
                if is_pointer_expr {
                    // It's a pointer stored as f64 - bitcast to i64 and use jsvalue push
                    let val_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                    ("js_array_push_jsvalue", val_i64)
                } else {
                    // Regular f64 value
                    ("js_array_push_f64", val)
                }
            };

            let func = extern_funcs.get(func_name)
                .ok_or_else(|| anyhow!("{} not declared", func_name))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, push_val]);
            let new_arr_ptr = builder.inst_results(call)[0];

            // Update the local variable with the new pointer (in case of reallocation)
            // Convert back to variable's storage type (i64 if is_pointer && !is_union, f64 otherwise)
            let store_val = if info.is_pointer && !info.is_union {
                new_arr_ptr
            } else {
                builder.ins().bitcast(types::F64, MemFlags::new(), new_arr_ptr)
            };
            builder.def_var(info.var, store_val);

            // Get and return the new length
            let len_func = extern_funcs.get("js_array_length")
                .ok_or_else(|| anyhow!("js_array_length not declared"))?;
            let len_ref = module.declare_func_in_func(*len_func, builder.func);
            let len_call = builder.ins().call(len_ref, &[new_arr_ptr]);
            let length = builder.inst_results(len_call)[0];

            // Convert length to f64
            Ok(builder.ins().fcvt_from_uint(types::F64, length))
        }
        Expr::ArrayPop(array_id) => {
            let info = locals.get(array_id)
                .ok_or_else(|| anyhow!("Undefined array variable: {}", array_id))?;
            let arr_val = builder.use_var(info.var);
            let arr_ptr = ensure_i64(builder, arr_val);

            let func = extern_funcs.get("js_array_pop_f64")
                .ok_or_else(|| anyhow!("js_array_pop_f64 not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::ArrayShift(array_id) => {
            let info = locals.get(array_id)
                .ok_or_else(|| anyhow!("Undefined array variable: {}", array_id))?;
            let arr_val = builder.use_var(info.var);
            let arr_ptr = ensure_i64(builder, arr_val);

            let func = extern_funcs.get("js_array_shift_f64")
                .ok_or_else(|| anyhow!("js_array_shift_f64 not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::ArrayUnshift { array_id, value } => {
            let info = locals.get(array_id)
                .ok_or_else(|| anyhow!("Undefined array variable: {}", array_id))?;
            let arr_val = builder.use_var(info.var);
            let arr_ptr = ensure_i64(builder, arr_val);

            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            let func = extern_funcs.get("js_array_unshift_f64")
                .ok_or_else(|| anyhow!("js_array_unshift_f64 not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, val]);
            let new_arr_ptr = builder.inst_results(call)[0];

            // Update the local variable with the new pointer
            // Convert back to variable's storage type (i64 if is_pointer && !is_union, f64 otherwise)
            let store_val = if info.is_pointer && !info.is_union {
                new_arr_ptr
            } else {
                builder.ins().bitcast(types::F64, MemFlags::new(), new_arr_ptr)
            };
            builder.def_var(info.var, store_val);

            // Get and return the new length
            let len_func = extern_funcs.get("js_array_length")
                .ok_or_else(|| anyhow!("js_array_length not declared"))?;
            let len_ref = module.declare_func_in_func(*len_func, builder.func);
            let len_call = builder.ins().call(len_ref, &[new_arr_ptr]);
            let length = builder.inst_results(len_call)[0];

            Ok(builder.ins().fcvt_from_uint(types::F64, length))
        }
        Expr::ArrayIndexOf { array, value } => {
            // Check if "array" is actually a string (string.indexOf vs array.indexOf)
            let is_string_indexof = match array.as_ref() {
                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                Expr::String(_) => true,
                _ => false,
            };

            if is_string_indexof {
                // String indexOf
                let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

                // Extract string pointer from NaN-boxed value
                let str_f64 = ensure_f64(builder, str_val);
                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                let str_call = builder.ins().call(get_str_ptr_ref, &[str_f64]);
                let str_ptr = builder.inst_results(str_call)[0];

                // Compile needle value and extract string pointer
                let needle_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
                let needle_f64 = ensure_f64(builder, needle_val);
                let needle_call = builder.ins().call(get_str_ptr_ref, &[needle_f64]);
                let needle_ptr = builder.inst_results(needle_call)[0];

                let index_of_func = extern_funcs.get("js_string_index_of")
                    .ok_or_else(|| anyhow!("js_string_index_of not declared"))?;
                let func_ref = module.declare_func_in_func(*index_of_func, builder.func);
                let call = builder.ins().call(func_ref, &[str_ptr, needle_ptr]);
                let index = builder.inst_results(call)[0];

                // Convert i32 to f64
                Ok(builder.ins().fcvt_from_sint(types::F64, index))
            } else {
                // Array indexOf
                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;
                let arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arr_val);
                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

                let func = extern_funcs.get("js_array_indexOf_f64")
                    .ok_or_else(|| anyhow!("js_array_indexOf_f64 not declared"))?;
                let func_ref = module.declare_func_in_func(*func, builder.func);
                let call = builder.ins().call(func_ref, &[arr_ptr, val]);
                let index = builder.inst_results(call)[0];

                // Convert i32 to f64
                Ok(builder.ins().fcvt_from_sint(types::F64, index))
            }
        }
        Expr::ArrayIncludes { array, value } => {
            // Check if "array" is actually a string (string.includes vs array.includes)
            let is_string_includes = match array.as_ref() {
                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                Expr::String(_) => true,
                _ => false,
            };

            if is_string_includes {
                // String includes (use indexOf and check if >= 0)
                let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

                // Extract string pointer from NaN-boxed value
                let str_f64 = ensure_f64(builder, str_val);
                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                let str_call = builder.ins().call(get_str_ptr_ref, &[str_f64]);
                let str_ptr = builder.inst_results(str_call)[0];

                // Compile needle value and extract string pointer
                let needle_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
                let needle_f64 = ensure_f64(builder, needle_val);
                let needle_call = builder.ins().call(get_str_ptr_ref, &[needle_f64]);
                let needle_ptr = builder.inst_results(needle_call)[0];

                let index_of_func = extern_funcs.get("js_string_index_of")
                    .ok_or_else(|| anyhow!("js_string_index_of not declared"))?;
                let func_ref = module.declare_func_in_func(*index_of_func, builder.func);
                let call = builder.ins().call(func_ref, &[str_ptr, needle_ptr]);
                let index_i32 = builder.inst_results(call)[0];

                // includes returns true if index >= 0
                let zero = builder.ins().iconst(types::I32, 0);
                let is_found = builder.ins().icmp(IntCC::SignedGreaterThanOrEqual, index_i32, zero);
                // Return NaN-boxed boolean (TAG_TRUE or TAG_FALSE)
                const TAG_TRUE: u64 = 0x7FFC_0000_0000_0004;
                const TAG_FALSE: u64 = 0x7FFC_0000_0000_0003;
                let true_val = builder.ins().f64const(f64::from_bits(TAG_TRUE));
                let false_val = builder.ins().f64const(f64::from_bits(TAG_FALSE));
                Ok(builder.ins().select(is_found, true_val, false_val))
            } else {
                // Array includes
                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;
                let arr_ptr = ensure_i64(builder, arr_val);
                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

                // Check if value is a string (from string literal or string variable)
                // If so, NaN-box it and use jsvalue comparison for proper string content matching
                let is_string_value = match value.as_ref() {
                    Expr::String(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    _ => false,
                };

                let (func_name, val_f64) = if is_string_value {
                    // String value - NaN-box it and use jsvalue comparison
                    let ptr = ensure_i64(builder, val);
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[ptr]);
                    ("js_array_includes_jsvalue", builder.inst_results(call)[0])
                } else {
                    // Non-string value - ensure f64 and use f64 comparison
                    ("js_array_includes_f64", ensure_f64(builder, val))
                };

                let func = extern_funcs.get(func_name)
                    .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                let func_ref = module.declare_func_in_func(*func, builder.func);
                let call = builder.ins().call(func_ref, &[arr_ptr, val_f64]);
                let result = builder.inst_results(call)[0];

                // Return NaN-boxed boolean (TAG_TRUE or TAG_FALSE)
                const TAG_TRUE: u64 = 0x7FFC_0000_0000_0004;
                const TAG_FALSE: u64 = 0x7FFC_0000_0000_0003;
                let true_val = builder.ins().f64const(f64::from_bits(TAG_TRUE));
                let false_val = builder.ins().f64const(f64::from_bits(TAG_FALSE));
                let zero = builder.ins().iconst(types::I32, 0);
                let is_found = builder.ins().icmp(IntCC::NotEqual, result, zero);
                Ok(builder.ins().select(is_found, true_val, false_val))
            }
        }
        Expr::ArraySlice { array, start, end } => {
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;
            // The array might be NaN-boxed (from split() result, etc.) or a raw i64 pointer
            // Use js_nanbox_get_pointer to extract the actual pointer, which handles both cases
            let arr_ptr = if builder.func.dfg.value_type(arr_val) == types::F64 {
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[arr_val]);
                builder.inst_results(call)[0]
            } else {
                // Already an i64 pointer
                arr_val
            };

            // Compile start index and convert to i32
            let start_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, start, this_ctx)?;
            let start_f64 = ensure_f64(builder, start_val);
            let start_i32 = builder.ins().fcvt_to_sint(types::I32, start_f64);

            // Compile end index or use i32::MAX as sentinel for "no end"
            let end_i32 = if let Some(end_expr) = end {
                let end_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, end_expr, this_ctx)?;
                let end_f64 = ensure_f64(builder, end_val);
                builder.ins().fcvt_to_sint(types::I32, end_f64)
            } else {
                builder.ins().iconst(types::I32, i32::MAX as i64)
            };

            let func = extern_funcs.get("js_array_slice")
                .ok_or_else(|| anyhow!("js_array_slice not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, start_i32, end_i32]);
            let result_ptr = builder.inst_results(call)[0];

            // Convert i64 pointer back to f64
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr))
        }
        Expr::ArraySplice { array_id, start, delete_count, items } => {
            // Get the array from local
            let info = locals.get(array_id)
                .ok_or_else(|| anyhow!("ArraySplice: local not found"))?;
            let arr_val = builder.use_var(info.var);
            // Variable is i64 only if is_pointer && !is_union (see variable declaration logic)
            let arr_ptr = if info.is_pointer && !info.is_union {
                arr_val // Already i64
            } else {
                builder.ins().bitcast(types::I64, MemFlags::new(), arr_val)
            };

            // Compile start index
            let start_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, start, this_ctx)?;
            let start_f64 = ensure_f64(builder, start_val);
            let start_i32 = builder.ins().fcvt_to_sint(types::I32, start_f64);

            // Compile delete count (default to i32::MAX if not provided, meaning delete to end)
            let delete_i32 = if let Some(dc_expr) = delete_count {
                let dc_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, dc_expr, this_ctx)?;
                let dc_f64 = ensure_f64(builder, dc_val);
                builder.ins().fcvt_to_sint(types::I32, dc_f64)
            } else {
                builder.ins().iconst(types::I32, i32::MAX as i64)
            };

            // Build items array on stack if any
            let (items_ptr, items_count) = if items.is_empty() {
                (builder.ins().iconst(types::I64, 0), builder.ins().iconst(types::I32, 0))
            } else {
                // Allocate stack space for items (8 bytes per f64)
                let items_slot = builder.create_sized_stack_slot(StackSlotData::new(
                    StackSlotKind::ExplicitSlot,
                    items.len() as u32 * 8,
                    8
                ));
                let items_addr = builder.ins().stack_addr(types::I64, items_slot, 0);

                // Compile and store each item
                for (i, item) in items.iter().enumerate() {
                    let item_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, item, this_ctx)?;
                    let offset = (i * 8) as i32;
                    builder.ins().store(MemFlags::new(), item_val, items_addr, offset);
                }

                (items_addr, builder.ins().iconst(types::I32, items.len() as i64))
            };

            // Allocate stack space for out_arr pointer (8 bytes for i64)
            let out_arr_slot = builder.create_sized_stack_slot(StackSlotData::new(
                StackSlotKind::ExplicitSlot,
                8,
                8
            ));
            let out_arr_addr = builder.ins().stack_addr(types::I64, out_arr_slot, 0);

            // Call js_array_splice
            let func = extern_funcs.get("js_array_splice")
                .ok_or_else(|| anyhow!("js_array_splice not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, start_i32, delete_i32, items_ptr, items_count, out_arr_addr]);
            let deleted_ptr = builder.inst_results(call)[0];

            // Load the updated array pointer from out_arr and update local
            let new_arr_ptr = builder.ins().load(types::I64, MemFlags::new(), out_arr_addr, 0);
            // Variable is i64 only if is_pointer && !is_union (see variable declaration logic)
            if info.is_pointer && !info.is_union {
                builder.def_var(info.var, new_arr_ptr);
            } else {
                let new_arr_f64 = builder.ins().bitcast(types::F64, MemFlags::new(), new_arr_ptr);
                builder.def_var(info.var, new_arr_f64);
            }

            // Return deleted elements array as f64
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), deleted_ptr))
        }
        Expr::ArrayForEach { array, callback } => {
            // Compile array and callback
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

            // Check if array is from a union-typed variable or imported (ExternFuncRef) - both are NaN-boxed
            let is_nanboxed_array = if let Expr::LocalGet(id) = array.as_ref() {
                locals.get(id).map(|i| i.is_union).unwrap_or(false)
            } else {
                // ExternFuncRef (imported variables) are always NaN-boxed
                matches!(array.as_ref(), Expr::ExternFuncRef { .. })
            };

            // Extract pointer from NaN-boxed value if needed
            let arr_ptr = if is_nanboxed_array {
                let arr_f64 = ensure_f64(builder, arr_val);
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[arr_f64]);
                builder.inst_results(call)[0]
            } else {
                ensure_i64(builder, arr_val)
            };

            let cb_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callback, this_ctx)?;
            // Ensure callback is i64 (closure pointer)
            let cb_ptr = ensure_i64(builder, cb_val);

            let func = extern_funcs.get("js_array_forEach")
                .ok_or_else(|| anyhow!("js_array_forEach not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            builder.ins().call(func_ref, &[arr_ptr, cb_ptr]);

            // forEach returns undefined, represent as 0.0
            Ok(builder.ins().f64const(0.0))
        }
        Expr::ArrayMap { array, callback } => {
            // Compile array and callback
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

            // Check if array is from a union-typed variable or imported (ExternFuncRef) - both are NaN-boxed
            let is_nanboxed_array = if let Expr::LocalGet(id) = array.as_ref() {
                locals.get(id).map(|i| i.is_union).unwrap_or(false)
            } else {
                // ExternFuncRef (imported variables) are always NaN-boxed
                matches!(array.as_ref(), Expr::ExternFuncRef { .. })
            };

            // Extract pointer from NaN-boxed value if needed
            let arr_ptr = if is_nanboxed_array {
                let arr_f64 = ensure_f64(builder, arr_val);
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[arr_f64]);
                builder.inst_results(call)[0]
            } else {
                ensure_i64(builder, arr_val)
            };

            let cb_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callback, this_ctx)?;
            // Ensure callback is i64 (closure pointer)
            let cb_ptr = ensure_i64(builder, cb_val);

            let func = extern_funcs.get("js_array_map")
                .ok_or_else(|| anyhow!("js_array_map not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, cb_ptr]);
            let result = builder.inst_results(call)[0];

            // Result is an array pointer (i64), bitcast to f64 for consistency
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result))
        }
        Expr::ArrayFilter { array, callback } => {
            // Compile array and callback
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

            // Check if array is from a union-typed variable or imported (ExternFuncRef) - both are NaN-boxed
            let is_nanboxed_array = if let Expr::LocalGet(id) = array.as_ref() {
                locals.get(id).map(|i| i.is_union).unwrap_or(false)
            } else {
                // ExternFuncRef (imported variables) are always NaN-boxed
                matches!(array.as_ref(), Expr::ExternFuncRef { .. })
            };

            // Extract pointer from NaN-boxed value if needed
            let arr_ptr = if is_nanboxed_array {
                let arr_f64 = ensure_f64(builder, arr_val);
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[arr_f64]);
                builder.inst_results(call)[0]
            } else {
                ensure_i64(builder, arr_val)
            };

            let cb_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callback, this_ctx)?;
            // Ensure callback is i64 (closure pointer)
            let cb_ptr = ensure_i64(builder, cb_val);

            let func = extern_funcs.get("js_array_filter")
                .ok_or_else(|| anyhow!("js_array_filter not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, cb_ptr]);
            let result = builder.inst_results(call)[0];

            // Result is an array pointer (i64), bitcast to f64 for consistency
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result))
        }
        Expr::ArrayFind { array, callback } => {
            // Compile array and callback
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

            // Always use dynamic version which handles both JS handle arrays (from JSON)
            // and native arrays. The array is passed as f64 (may be NaN-boxed or JS handle).
            let arr_f64 = ensure_f64(builder, arr_val);

            let cb_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callback, this_ctx)?;
            // Ensure callback is i64 (closure pointer)
            let cb_ptr = ensure_i64(builder, cb_val);

            let func = extern_funcs.get("js_dynamic_array_find")
                .ok_or_else(|| anyhow!("js_dynamic_array_find not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_f64, cb_ptr]);
            let result = builder.inst_results(call)[0];

            // Result is f64 (element or NaN for undefined)
            Ok(result)
        }
        Expr::ArrayFindIndex { array, callback } => {
            // Compile array and callback
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

            // Always use dynamic version which handles both JS handle arrays (from JSON)
            // and native arrays. The array is passed as f64 (may be NaN-boxed or JS handle).
            let arr_f64 = ensure_f64(builder, arr_val);

            let cb_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callback, this_ctx)?;
            // Ensure callback is i64 (closure pointer)
            let cb_ptr = ensure_i64(builder, cb_val);

            let func = extern_funcs.get("js_dynamic_array_findIndex")
                .ok_or_else(|| anyhow!("js_dynamic_array_findIndex not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_f64, cb_ptr]);
            // Result is already f64 from the dynamic version
            Ok(builder.inst_results(call)[0])
        }
        Expr::ArrayReduce { array, callback, initial } => {
            // Compile array and callback
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

            // Check if array is from a union-typed variable or imported (ExternFuncRef) - both are NaN-boxed
            let is_nanboxed_array = if let Expr::LocalGet(id) = array.as_ref() {
                locals.get(id).map(|i| i.is_union).unwrap_or(false)
            } else {
                // ExternFuncRef (imported variables) are always NaN-boxed
                matches!(array.as_ref(), Expr::ExternFuncRef { .. })
            };

            // Extract pointer from NaN-boxed value if needed
            let arr_ptr = if is_nanboxed_array {
                let arr_f64 = ensure_f64(builder, arr_val);
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[arr_f64]);
                builder.inst_results(call)[0]
            } else {
                ensure_i64(builder, arr_val)
            };
            let cb_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callback, this_ctx)?;
            // Ensure callback is i64 (closure pointer)
            let cb_ptr = ensure_i64(builder, cb_val);

            // Handle optional initial value
            let (has_initial, initial_val) = if let Some(init_expr) = initial {
                let init_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, init_expr, this_ctx)?;
                (builder.ins().iconst(types::I32, 1), init_val)
            } else {
                (builder.ins().iconst(types::I32, 0), builder.ins().f64const(0.0))
            };

            let func = extern_funcs.get("js_array_reduce")
                .ok_or_else(|| anyhow!("js_array_reduce not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, cb_ptr, has_initial, initial_val]);
            let result = builder.inst_results(call)[0];

            // Result is f64
            Ok(result)
        }
        Expr::ArrayJoin { array, separator } => {
            // Compile array
            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, array, this_ctx)?;

            // Check if array is from a union-typed variable or imported (ExternFuncRef) - both are NaN-boxed
            let is_nanboxed_array = if let Expr::LocalGet(id) = array.as_ref() {
                locals.get(id).map(|i| i.is_union).unwrap_or(false)
            } else {
                // ExternFuncRef (imported variables) are always NaN-boxed
                matches!(array.as_ref(), Expr::ExternFuncRef { .. })
            };

            // Extract pointer from NaN-boxed value if needed
            let arr_ptr = if is_nanboxed_array {
                let arr_f64 = ensure_f64(builder, arr_val);
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[arr_f64]);
                builder.inst_results(call)[0]
            } else {
                builder.ins().bitcast(types::I64, MemFlags::new(), arr_val)
            };

            // Compile separator (or use null for default comma)
            let sep_ptr = if let Some(sep_expr) = separator {
                let sep_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, sep_expr, this_ctx)?;
                // Extract string pointer from potentially NaN-boxed value
                let sep_f64 = ensure_f64(builder, sep_val);
                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                let sep_call = builder.ins().call(get_str_ptr_ref, &[sep_f64]);
                builder.inst_results(sep_call)[0]
            } else {
                builder.ins().iconst(types::I64, 0) // null pointer for default comma separator
            };

            let func = extern_funcs.get("js_array_join")
                .ok_or_else(|| anyhow!("js_array_join not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[arr_ptr, sep_ptr]);
            let result = builder.inst_results(call)[0];

            // Result is a string pointer (i64), NaN-box with STRING_TAG
            let nanbox_func = extern_funcs.get("js_nanbox_string")
                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let nanbox_call = builder.ins().call(nanbox_ref, &[result]);
            Ok(builder.inst_results(nanbox_call)[0])
        }
        // Map operations
        Expr::MapNew => {
            // Allocate a new empty map
            let alloc_func = extern_funcs.get("js_map_alloc")
                .ok_or_else(|| anyhow!("js_map_alloc not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
            let capacity = builder.ins().iconst(types::I32, 4); // Initial capacity of 4
            let call = builder.ins().call(alloc_ref, &[capacity]);
            let map_ptr = builder.inst_results(call)[0];
            // Return as f64 (NaN-boxed pointer)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), map_ptr))
        }
        Expr::MapSet { map, key, value } => {
            // Compile the map expression - similar to MapGet handling
            let map_ptr = if let Expr::LocalGet(id) = map.as_ref() {
                if let Some(info) = locals.get(id) {
                    // Variable is i64 only if (is_map || is_pointer) && !is_union
                    if (info.is_map || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                        ensure_i64(builder, map_val)
                    }
                } else {
                    let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                    ensure_i64(builder, map_val)
                }
            } else {
                let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                ensure_i64(builder, map_val)
            };

            let key_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, key, this_ctx)?;
            let value_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // js_map_set expects f64 for key and value, bitcast if needed
            let key_f64 = ensure_f64(builder, key_val);
            let value_f64 = ensure_f64(builder, value_val);

            let set_func = extern_funcs.get("js_map_set")
                .ok_or_else(|| anyhow!("js_map_set not declared"))?;
            let set_ref = module.declare_func_in_func(*set_func, builder.func);
            let call = builder.ins().call(set_ref, &[map_ptr, key_f64, value_f64]);
            let new_map_ptr = builder.inst_results(call)[0];

            // Return as f64 (NaN-boxed pointer) - for chaining
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), new_map_ptr))
        }
        Expr::MapGet { map, key } => {
            // Get map pointer - if it's a local map variable, use directly as i64
            let map_ptr = if let Expr::LocalGet(id) = map.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_map || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                    }
                } else {
                    let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                }
            } else {
                let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
            };
            let key_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, key, this_ctx)?;
            let key_f64 = ensure_f64(builder, key_val);

            let get_func = extern_funcs.get("js_map_get")
                .ok_or_else(|| anyhow!("js_map_get not declared"))?;
            let get_ref = module.declare_func_in_func(*get_func, builder.func);
            let call = builder.ins().call(get_ref, &[map_ptr, key_f64]);
            let result = builder.inst_results(call)[0];
            Ok(result) // Already f64
        }
        Expr::MapHas { map, key } => {
            // Get map pointer - if it's a local map variable, use directly as i64
            let map_ptr = if let Expr::LocalGet(id) = map.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_map || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                    }
                } else {
                    let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                }
            } else {
                let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
            };
            let key_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, key, this_ctx)?;
            let key_f64 = ensure_f64(builder, key_val);

            let has_func = extern_funcs.get("js_map_has")
                .ok_or_else(|| anyhow!("js_map_has not declared"))?;
            let has_ref = module.declare_func_in_func(*has_func, builder.func);
            let call = builder.ins().call(has_ref, &[map_ptr, key_f64]);
            let result_i32 = builder.inst_results(call)[0];
            // Convert i32 (0 or 1) to f64
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::MapDelete { map, key } => {
            // Get map pointer - if it's a local map variable, use directly as i64
            let map_ptr = if let Expr::LocalGet(id) = map.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_map || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                    }
                } else {
                    let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                }
            } else {
                let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
            };
            let key_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, key, this_ctx)?;
            let key_f64 = ensure_f64(builder, key_val);

            let delete_func = extern_funcs.get("js_map_delete")
                .ok_or_else(|| anyhow!("js_map_delete not declared"))?;
            let delete_ref = module.declare_func_in_func(*delete_func, builder.func);
            let call = builder.ins().call(delete_ref, &[map_ptr, key_f64]);
            let result_i32 = builder.inst_results(call)[0];
            // Convert i32 (0 or 1) to f64
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::MapSize(map) => {
            // Get map pointer - if it's a local map variable, use directly as i64
            let map_ptr = if let Expr::LocalGet(id) = map.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_map || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                    }
                } else {
                    let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                }
            } else {
                let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
            };

            let size_func = extern_funcs.get("js_map_size")
                .ok_or_else(|| anyhow!("js_map_size not declared"))?;
            let size_ref = module.declare_func_in_func(*size_func, builder.func);
            let call = builder.ins().call(size_ref, &[map_ptr]);
            let size_i32 = builder.inst_results(call)[0];
            // Convert i32 to f64
            Ok(builder.ins().fcvt_from_sint(types::F64, size_i32))
        }
        Expr::MapClear(map) => {
            // Get map pointer - if it's a local map variable, use directly as i64
            let map_ptr = if let Expr::LocalGet(id) = map.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_map || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                    }
                } else {
                    let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
                }
            } else {
                let map_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, map, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), map_val)
            };

            let clear_func = extern_funcs.get("js_map_clear")
                .ok_or_else(|| anyhow!("js_map_clear not declared"))?;
            let clear_ref = module.declare_func_in_func(*clear_func, builder.func);
            builder.ins().call(clear_ref, &[map_ptr]);
            // clear() returns undefined (0.0)
            Ok(builder.ins().f64const(0.0))
        }
        // Set operations
        Expr::SetNew => {
            // Allocate a new empty set
            let alloc_func = extern_funcs.get("js_set_alloc")
                .ok_or_else(|| anyhow!("js_set_alloc not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
            let capacity = builder.ins().iconst(types::I32, 4); // Initial capacity of 4
            let call = builder.ins().call(alloc_ref, &[capacity]);
            let set_ptr = builder.inst_results(call)[0];
            // Return as f64 (NaN-boxed pointer)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), set_ptr))
        }
        Expr::SetAdd { set_id, value } => {
            // Get the set pointer from the local variable
            let info = locals.get(set_id)
                .ok_or_else(|| anyhow!("Undefined set variable: {}", set_id))?;
            let set_val = builder.use_var(info.var);
            let set_ptr = ensure_i64(builder, set_val);

            let value_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Check if value is a string - if so, NaN-box it for proper string content comparison
            let is_string_value = match value.as_ref() {
                Expr::String(_) => true,
                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                _ => false,
            };

            let value_f64 = if is_string_value {
                // String value - NaN-box it for proper storage
                let ptr = ensure_i64(builder, value_val);
                let nanbox_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[ptr]);
                builder.inst_results(call)[0]
            } else {
                // Non-string value - ensure f64
                ensure_f64(builder, value_val)
            };

            let add_func = extern_funcs.get("js_set_add")
                .ok_or_else(|| anyhow!("js_set_add not declared"))?;
            let add_ref = module.declare_func_in_func(*add_func, builder.func);
            let call = builder.ins().call(add_ref, &[set_ptr, value_f64]);
            let new_set_ptr = builder.inst_results(call)[0];

            // Update the local variable with the new pointer (in case of reallocation)
            // Convert back to the variable's storage type
            let store_val = if info.is_pointer && !info.is_union {
                new_set_ptr
            } else {
                builder.ins().bitcast(types::F64, MemFlags::new(), new_set_ptr)
            };
            builder.def_var(info.var, store_val);

            // Return as f64 (NaN-boxed pointer) - for chaining
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), new_set_ptr))
        }
        Expr::SetHas { set, value } => {
            // Get set pointer - if it's a local set variable, use directly as i64
            let set_ptr = if let Expr::LocalGet(id) = set.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_set || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
                    }
                } else {
                    let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
                }
            } else {
                let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
            };
            let value_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Check if value is a string - if so, NaN-box it for proper string content comparison
            let is_string_value = match value.as_ref() {
                Expr::String(_) => true,
                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                _ => false,
            };

            let value_f64 = if is_string_value {
                // String value - NaN-box it for proper comparison
                let ptr = ensure_i64(builder, value_val);
                let nanbox_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[ptr]);
                builder.inst_results(call)[0]
            } else {
                // Non-string value - ensure f64
                ensure_f64(builder, value_val)
            };

            let has_func = extern_funcs.get("js_set_has")
                .ok_or_else(|| anyhow!("js_set_has not declared"))?;
            let has_ref = module.declare_func_in_func(*has_func, builder.func);
            let call = builder.ins().call(has_ref, &[set_ptr, value_f64]);
            let result_i32 = builder.inst_results(call)[0];
            // Convert i32 (0 or 1) to f64
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::SetDelete { set, value } => {
            // Get set pointer - if it's a local set variable, use directly as i64
            let set_ptr = if let Expr::LocalGet(id) = set.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_set || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
                    }
                } else {
                    let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
                }
            } else {
                let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
            };
            let value_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Check if value is a string - if so, NaN-box it for proper string content comparison
            let is_string_value = match value.as_ref() {
                Expr::String(_) => true,
                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                _ => false,
            };

            let value_f64 = if is_string_value {
                // String value - NaN-box it for proper comparison
                let ptr = ensure_i64(builder, value_val);
                let nanbox_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[ptr]);
                builder.inst_results(call)[0]
            } else {
                // Non-string value - ensure f64
                ensure_f64(builder, value_val)
            };

            let delete_func = extern_funcs.get("js_set_delete")
                .ok_or_else(|| anyhow!("js_set_delete not declared"))?;
            let delete_ref = module.declare_func_in_func(*delete_func, builder.func);
            let call = builder.ins().call(delete_ref, &[set_ptr, value_f64]);
            let result_i32 = builder.inst_results(call)[0];
            // Convert i32 (0 or 1) to f64
            Ok(builder.ins().fcvt_from_sint(types::F64, result_i32))
        }
        Expr::SetSize(set) => {
            // Get set pointer - if it's a local set variable, use directly as i64
            let set_ptr = if let Expr::LocalGet(id) = set.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_set || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
                    }
                } else {
                    let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
                }
            } else {
                let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
            };

            let size_func = extern_funcs.get("js_set_size")
                .ok_or_else(|| anyhow!("js_set_size not declared"))?;
            let size_ref = module.declare_func_in_func(*size_func, builder.func);
            let call = builder.ins().call(size_ref, &[set_ptr]);
            let size_i32 = builder.inst_results(call)[0];
            // Convert i32 to f64
            Ok(builder.ins().fcvt_from_sint(types::F64, size_i32))
        }
        Expr::SetClear(set) => {
            // Get set pointer - if it's a local set variable, use directly as i64
            let set_ptr = if let Expr::LocalGet(id) = set.as_ref() {
                if let Some(info) = locals.get(id) {
                    if (info.is_set || info.is_pointer) && !info.is_union {
                        builder.use_var(info.var)
                    } else {
                        let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                        builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
                    }
                } else {
                    let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
                }
            } else {
                let set_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, set, this_ctx)?;
                builder.ins().bitcast(types::I64, MemFlags::new(), set_val)
            };

            let clear_func = extern_funcs.get("js_set_clear")
                .ok_or_else(|| anyhow!("js_set_clear not declared"))?;
            let clear_ref = module.declare_func_in_func(*clear_func, builder.func);
            builder.ins().call(clear_ref, &[set_ptr]);
            // clear() returns undefined (0.0)
            Ok(builder.ins().f64const(0.0))
        }
        Expr::LocalGet(id) => {
            let info = locals.get(id)
                .ok_or_else(|| anyhow!("Undefined local variable: {}. Available locals: {:?}", id, locals.keys().collect::<Vec<_>>()))?;

            if info.is_boxed {
                // For boxed variables (mutable captures), call js_box_get to read the current value
                let box_ptr = builder.use_var(info.var);
                let box_get_func = extern_funcs.get("js_box_get")
                    .ok_or_else(|| anyhow!("js_box_get not declared"))?;
                let box_get_ref = module.declare_func_in_func(*box_get_func, builder.func);
                let call = builder.ins().call(box_get_ref, &[box_ptr]);
                Ok(builder.inst_results(call)[0])
            } else if info.is_i32 {
                // For i32 loop counters, convert to f64 for use in expressions
                let i32_val = builder.use_var(info.var);
                Ok(builder.ins().fcvt_from_sint(types::F64, i32_val))
            } else {
                // Return the value directly - typed functions now handle different types
                Ok(builder.use_var(info.var))
            }
        }
        Expr::GlobalGet(_) => {
            // GlobalGet represents special global objects like console, process, Promise, Math, etc.
            // These are handled specially in property access (e.g., console.log, process.exit)
            // Return a sentinel value - the actual dispatch happens in PropertyGet via pattern matching
            Ok(builder.ins().f64const(0.0))
        }
        Expr::GlobalSet(_, value) => {
            // GlobalSet is rarely used - compile the value but don't store it anywhere yet
            // This allows expressions like `globalVar = value` to compile without error
            compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)
        }
        Expr::LocalSet(id, value) => {
            // Helper to detect if an expression produces a string
            fn is_string_expr_for_union(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                    Expr::FsReadFileSync(_) => true,
                    Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                    Expr::PathExtname(_) | Expr::PathResolve(_) | Expr::JsonStringify(_) => true,
                    // OS operations that return strings
                    Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                    Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    _ => false,
                }
            }

            // Check for string append pattern: x = x + y where x is a string
            // This allows us to use in-place append for O(1) amortized concatenation
            let info = locals.get(id)
                .ok_or_else(|| anyhow!("Undefined local variable: {}", id))?;

            // OPTIMIZATION: Native i32 arithmetic for integer accumulators
            // Pattern: x = x + constant where x is i32
            if info.is_i32 {
                if let Expr::Binary { op, left, right } = value.as_ref() {
                    if let Expr::LocalGet(left_id) = left.as_ref() {
                        if left_id == id {
                            // Pattern detected: x = x OP constant
                            let delta = match (op, right.as_ref()) {
                                (BinaryOp::Add, Expr::Integer(n)) => Some(*n),
                                (BinaryOp::Add, Expr::Number(f)) if f.fract() == 0.0 => Some(*f as i64),
                                (BinaryOp::Sub, Expr::Integer(n)) => Some(-*n),
                                (BinaryOp::Sub, Expr::Number(f)) if f.fract() == 0.0 => Some(-(*f as i64)),
                                // Pattern: x = x + y where y is also i32
                                (BinaryOp::Add, Expr::LocalGet(right_id)) => {
                                    if let Some(right_info) = locals.get(right_id) {
                                        if right_info.is_i32 {
                                            // Both are i32: use iadd directly
                                            let current = builder.use_var(info.var);
                                            let rhs = builder.use_var(right_info.var);
                                            let new_val = builder.ins().iadd(current, rhs);
                                            builder.def_var(info.var, new_val);
                                            return Ok(builder.ins().fcvt_from_sint(types::F64, new_val));
                                        } else if !right_info.is_boxed && !right_info.is_string && !right_info.is_bigint {
                                            // y is f64: convert to i32 and use iadd (faster than f64 arithmetic)
                                            let current = builder.use_var(info.var);
                                            let rhs_val = builder.use_var(right_info.var);
                                            let rhs_f64 = ensure_f64(builder, rhs_val);
                                            let rhs_i32 = builder.ins().fcvt_to_sint(types::I32, rhs_f64);
                                            let new_val = builder.ins().iadd(current, rhs_i32);
                                            builder.def_var(info.var, new_val);
                                            return Ok(builder.ins().fcvt_from_sint(types::F64, new_val));
                                        }
                                    }
                                    None
                                }
                                _ => None,
                            };

                            if let Some(delta) = delta {
                                // Use iadd_imm for x = x + constant
                                let current = builder.use_var(info.var);
                                let new_val = builder.ins().iadd_imm(current, delta);
                                builder.def_var(info.var, new_val);
                                // Return f64 for expression value
                                return Ok(builder.ins().fcvt_from_sint(types::F64, new_val));
                            }
                        }
                    }
                }
                // Fallback: compile expression and convert to i32
                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
                let val_f64 = ensure_f64(builder, val);
                let i32_val = builder.ins().fcvt_to_sint(types::I32, val_f64);
                builder.def_var(info.var, i32_val);
                return Ok(val);
            }

            if info.is_string {
                if let Expr::Binary { op: BinaryOp::Add, left, right } = value.as_ref() {
                    if let Expr::LocalGet(left_id) = left.as_ref() {
                        if left_id == id {
                            // Pattern detected: x = x + y where x is a string
                            // Use js_string_append for in-place appending

                            // Helper to check if expression is a string
                            fn is_string_operand(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                match expr {
                                    Expr::String(_) => true,
                                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                    Expr::Binary { op: BinaryOp::Add, left, right } => {
                                        is_string_operand(left, locals) || is_string_operand(right, locals)
                                    }
                                    _ => false,
                                }
                            }

                            // Get the current string pointer (stored as f64, need to bitcast to I64)
                            let dest_f64 = builder.use_var(info.var);
                            let dest_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), dest_f64);

                            // Compile the right side
                            let rhs_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;

                            // Convert to string pointer if needed
                            let rhs_ptr = if is_string_operand(right, locals) {
                                builder.ins().bitcast(types::I64, MemFlags::new(), rhs_val)
                            } else {
                                // Number to string
                                let num_to_str_func = extern_funcs.get("js_number_to_string")
                                    .ok_or_else(|| anyhow!("js_number_to_string not declared"))?;
                                let func_ref = module.declare_func_in_func(*num_to_str_func, builder.func);
                                let call = builder.ins().call(func_ref, &[rhs_val]);
                                builder.inst_results(call)[0]
                            };

                            // Call js_string_append for in-place append
                            let append_func = extern_funcs.get("js_string_append")
                                .ok_or_else(|| anyhow!("js_string_append not declared"))?;
                            let func_ref = module.declare_func_in_func(*append_func, builder.func);
                            let call = builder.ins().call(func_ref, &[dest_ptr, rhs_ptr]);
                            let new_ptr = builder.inst_results(call)[0];

                            // Convert back to f64 for storage (strings are stored as f64-bitcast pointers)
                            let new_f64 = builder.ins().bitcast(types::F64, MemFlags::new(), new_ptr);

                            // Update the variable with the (possibly new) pointer
                            builder.def_var(info.var, new_f64);

                            // Return as f64 for consistency
                            return Ok(new_f64);
                        }
                    }
                }
            }

            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            if info.is_boxed {
                // For boxed variables (mutable captures), call js_box_set to update the value
                let box_ptr = builder.use_var(info.var);
                let box_set_func = extern_funcs.get("js_box_set")
                    .ok_or_else(|| anyhow!("js_box_set not declared"))?;
                let box_set_ref = module.declare_func_in_func(*box_set_func, builder.func);
                builder.ins().call(box_set_ref, &[box_ptr, val]);
                Ok(val)
            } else if info.is_union && is_string_expr_for_union(value, locals) {
                // For union types with string values, NaN-box the pointer using STRING_TAG
                let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                let nanbox_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[ptr]);
                let boxed_val = builder.inst_results(call)[0];
                builder.def_var(info.var, boxed_val);
                Ok(boxed_val)
            } else if info.is_pointer && !info.is_union {
                // Variable is stored as i64 (pointer type without union)
                let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                builder.def_var(info.var, ptr);
                Ok(val)
            } else {
                // Ensure type matches the variable's declared type
                // Get declared type by checking the variable's current value type
                let current_val = builder.use_var(info.var);
                let var_type = builder.func.dfg.value_type(current_val);
                let val_type = builder.func.dfg.value_type(val);

                let converted_val = if var_type != val_type {
                    // Types don't match - convert using bitcast
                    if var_type == types::F64 && val_type == types::I64 {
                        builder.ins().bitcast(types::F64, MemFlags::new(), val)
                    } else if var_type == types::I64 && val_type == types::F64 {
                        builder.ins().bitcast(types::I64, MemFlags::new(), val)
                    } else {
                        val
                    }
                } else {
                    val
                };
                builder.def_var(info.var, converted_val);
                // OPTIMIZATION: Update i32 shadow for integer variables
                if let Some(shadow_var) = info.i32_shadow {
                    let val_f64 = ensure_f64(builder, val);
                    let i32_val = builder.ins().fcvt_to_sint(types::I32, val_f64);
                    builder.def_var(shadow_var, i32_val);
                }
                Ok(val)
            }
        }
        Expr::Update { id, op, prefix } => {
            // Handle ++x, x++, --x, x--
            let info = locals.get(id)
                .ok_or_else(|| anyhow!("Undefined local variable in update: {}", id))?;

            if info.is_i32 {
                // Native i32 loop counter - use integer arithmetic
                let current_i32 = builder.use_var(info.var);
                let new_i32 = match op {
                    UpdateOp::Increment => builder.ins().iadd_imm(current_i32, 1),
                    UpdateOp::Decrement => builder.ins().iadd_imm(current_i32, -1),
                };
                builder.def_var(info.var, new_i32);

                // Return f64 for expression value
                let return_i32 = if *prefix { new_i32 } else { current_i32 };
                Ok(builder.ins().fcvt_from_sint(types::F64, return_i32))
            } else {
                // Get current value and ensure it's f64 for floating-point arithmetic
                let current_val_raw = builder.use_var(info.var);
                let current_val = ensure_f64(builder, current_val_raw);

                // Calculate the delta (1.0 for increment, -1.0 for decrement)
                let one = builder.ins().f64const(1.0);
                let new_val = match op {
                    UpdateOp::Increment => builder.ins().fadd(current_val, one),
                    UpdateOp::Decrement => builder.ins().fsub(current_val, one),
                };

                // Store the new value - convert back to i64 if variable is stored as i64
                let store_val = if info.is_pointer && !info.is_union {
                    builder.ins().bitcast(types::I64, MemFlags::new(), new_val)
                } else {
                    new_val
                };
                builder.def_var(info.var, store_val);

                // OPTIMIZATION: Update i32 shadow for integer variables (common for loop counters)
                if let Some(shadow_var) = info.i32_shadow {
                    // For integers, we can use i32 add/sub directly instead of converting the f64
                    let current_i32 = builder.use_var(shadow_var);
                    let one_i32 = builder.ins().iconst(types::I32, 1);
                    let new_i32 = match op {
                        UpdateOp::Increment => builder.ins().iadd(current_i32, one_i32),
                        UpdateOp::Decrement => builder.ins().isub(current_i32, one_i32),
                    };
                    builder.def_var(shadow_var, new_i32);
                }

                // Return value depends on prefix/postfix
                if *prefix {
                    // ++x or --x: return the new value
                    Ok(new_val)
                } else {
                    // x++ or x--: return the old value
                    Ok(current_val)
                }
            }
        }
        Expr::Binary { op, left, right } => {
            // CONSTANT FOLDING: Evaluate constant expressions at compile time
            fn get_constant_value(expr: &Expr) -> Option<f64> {
                match expr {
                    Expr::Integer(n) => Some(*n as f64),
                    Expr::Number(f) => Some(*f),
                    _ => None,
                }
            }
            if let (Some(lhs_const), Some(rhs_const)) = (get_constant_value(left), get_constant_value(right)) {
                let result = match op {
                    BinaryOp::Add => Some(lhs_const + rhs_const),
                    BinaryOp::Sub => Some(lhs_const - rhs_const),
                    BinaryOp::Mul => Some(lhs_const * rhs_const),
                    BinaryOp::Div => Some(lhs_const / rhs_const),
                    BinaryOp::Mod => Some(lhs_const % rhs_const),
                    BinaryOp::Pow => Some(lhs_const.powf(rhs_const)),
                    BinaryOp::BitAnd => Some(((lhs_const as i32) & (rhs_const as i32)) as f64),
                    BinaryOp::BitOr => Some(((lhs_const as i32) | (rhs_const as i32)) as f64),
                    BinaryOp::BitXor => Some(((lhs_const as i32) ^ (rhs_const as i32)) as f64),
                    BinaryOp::Shl => Some(((lhs_const as i32) << ((rhs_const as i32) & 0x1f)) as f64),
                    BinaryOp::Shr => Some(((lhs_const as i32) >> ((rhs_const as i32) & 0x1f)) as f64),
                    BinaryOp::UShr => Some((((lhs_const as i32) as u32) >> ((rhs_const as i32) & 0x1f)) as f64),
                };
                if let Some(val) = result {
                    return Ok(builder.ins().f64const(val));
                }
            }

            // Check if this is string concatenation (recursively for nested binary expressions)
            // Note: EnvGet is NOT included because it can return undefined (handled as union type)
            fn is_string_operand(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string && !i.is_union).unwrap_or(false),
                    Expr::FsReadFileSync(_) |
                    Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                    Expr::PathExtname(_) | Expr::PathResolve(_) | Expr::JsonStringify(_) => true,
                    Expr::Binary { op: BinaryOp::Add, left, right } => {
                        is_string_operand(left, locals) || is_string_operand(right, locals)
                    }
                    // Conditional expressions with string branches (from template literals)
                    Expr::Conditional { then_expr, else_expr, .. } => {
                        is_string_operand(then_expr, locals) && is_string_operand(else_expr, locals)
                    }
                    // String method calls (substring, slice, trim, etc.)
                    Expr::Call { callee, .. } => {
                        if let Expr::PropertyGet { object, property } = callee.as_ref() {
                            if property == "slice" || property == "substring" || property == "trim"
                               || property == "toLowerCase" || property == "toUpperCase" || property == "replace"
                               || property == "padStart" || property == "padEnd" || property == "repeat" || property == "charAt" {
                                // Check if the object is a string
                                if let Expr::LocalGet(id) = object.as_ref() {
                                    return locals.get(id).map(|i| i.is_string).unwrap_or(true);
                                }
                                // For non-LocalGet (like property chains), assume it's a string method
                                return true;
                            }
                        }
                        false
                    }
                    _ => false,
                }
            }

            // Check if an expression produces a NaN-boxed string (from Conditional)
            fn is_nanboxed_string_operand(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::Conditional { then_expr, else_expr, .. } => {
                        is_string_operand(then_expr, locals) && is_string_operand(else_expr, locals)
                    }
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_union && i.is_string).unwrap_or(false),
                    _ => false,
                }
            }

            // Check if an expression is a union type (NaN-boxed, could be any value)
            // These need js_jsvalue_to_string to handle both strings and numbers
            fn is_union_operand(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_union).unwrap_or(false),
                    // EnvGet returns NaN-boxed string or undefined - treat as union
                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                    Expr::PropertyGet { object, property } if property != "length" => {
                        // PropertyGet on non-class objects returns NaN-boxed values
                        if let Expr::LocalGet(id) = object.as_ref() {
                            locals.get(id).map(|i| !i.is_array && !i.is_string && !i.is_map && !i.is_set && i.class_name.is_none()).unwrap_or(true)
                        } else {
                            false
                        }
                    }
                    _ => false,
                }
            }

            let is_string_left = is_string_operand(left, locals);
            let is_string_right = is_string_operand(right, locals);
            let is_nanboxed_left = is_nanboxed_string_operand(left, locals);
            let is_nanboxed_right = is_nanboxed_string_operand(right, locals);
            let is_union_left = is_union_operand(left, locals);
            let is_union_right = is_union_operand(right, locals);

            if matches!(op, BinaryOp::Add) && (is_string_left || is_string_right) {
                // String concatenation
                let lhs_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                let rhs_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;

                // Convert non-string values to strings
                let lhs_ptr = if is_nanboxed_left {
                    // NaN-boxed string (from Conditional) - extract the raw pointer
                    let get_ptr_func = extern_funcs.get("js_nanbox_get_string_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_get_string_pointer not declared"))?;
                    let func_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                    let val_f64 = ensure_f64(builder, lhs_val);
                    let call = builder.ins().call(func_ref, &[val_f64]);
                    builder.inst_results(call)[0]
                } else if is_union_left {
                    // Union type (could be string, number, etc.) - use js_jsvalue_to_string
                    let jsvalue_to_str_func = extern_funcs.get("js_jsvalue_to_string")
                        .ok_or_else(|| anyhow!("js_jsvalue_to_string not declared"))?;
                    let func_ref = module.declare_func_in_func(*jsvalue_to_str_func, builder.func);
                    let val_f64 = ensure_f64(builder, lhs_val);
                    let call = builder.ins().call(func_ref, &[val_f64]);
                    builder.inst_results(call)[0]
                } else if is_string_left {
                    // String value - could be raw i64 pointer or NaN-boxed f64
                    // Use js_get_string_pointer_unified to handle both cases
                    let lhs_type = builder.func.dfg.value_type(lhs_val);
                    if lhs_type == types::I64 {
                        // Already a raw pointer
                        lhs_val
                    } else {
                        // f64 - could be NaN-boxed or raw pointer bitcast
                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                        let val_f64 = ensure_f64(builder, lhs_val);
                        let call = builder.ins().call(get_str_ptr_ref, &[val_f64]);
                        builder.inst_results(call)[0]
                    }
                } else {
                    // Check if the value is already i64 (a string pointer from function call)
                    let lhs_type = builder.func.dfg.value_type(lhs_val);
                    if lhs_type == types::I64 {
                        // Already a string pointer
                        lhs_val
                    } else {
                        // Check if the left operand is a LocalGet referencing a variable that
                        // might be a string pointer (not marked as union, not a number)
                        let might_be_string_ptr = match left.as_ref() {
                            Expr::LocalGet(id) => {
                                // If the variable is stored as f64 but not marked as union or integer,
                                // it might be a string pointer bitcast to f64
                                locals.get(id).map(|i| !i.is_union && !i.is_pointer && !i.is_integer && !i.is_array && !i.is_bigint).unwrap_or(false)
                            }
                            _ => false,
                        };
                        if might_be_string_ptr {
                            // Assume it's a string pointer stored as f64 - just bitcast back to i64
                            ensure_i64(builder, lhs_val)
                        } else {
                            // Unknown f64 - could be NaN-boxed string or number
                            // Use js_jsvalue_to_string which handles both cases
                            let jsvalue_to_str_func = extern_funcs.get("js_jsvalue_to_string")
                                .ok_or_else(|| anyhow!("js_jsvalue_to_string not declared"))?;
                            let func_ref = module.declare_func_in_func(*jsvalue_to_str_func, builder.func);
                            let call = builder.ins().call(func_ref, &[lhs_val]);
                            builder.inst_results(call)[0]
                        }
                    }
                };

                let rhs_ptr = if is_nanboxed_right {
                    // NaN-boxed string (from Conditional) - extract the raw pointer
                    let get_ptr_func = extern_funcs.get("js_nanbox_get_string_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_get_string_pointer not declared"))?;
                    let func_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                    let val_f64 = ensure_f64(builder, rhs_val);
                    let call = builder.ins().call(func_ref, &[val_f64]);
                    builder.inst_results(call)[0]
                } else if is_union_right {
                    // Union type (could be string, number, etc.) - use js_jsvalue_to_string
                    let jsvalue_to_str_func = extern_funcs.get("js_jsvalue_to_string")
                        .ok_or_else(|| anyhow!("js_jsvalue_to_string not declared"))?;
                    let func_ref = module.declare_func_in_func(*jsvalue_to_str_func, builder.func);
                    let val_f64 = ensure_f64(builder, rhs_val);
                    let call = builder.ins().call(func_ref, &[val_f64]);
                    builder.inst_results(call)[0]
                } else if is_string_right {
                    // String value - could be raw i64 pointer or NaN-boxed f64
                    // Use js_get_string_pointer_unified to handle both cases
                    let rhs_type = builder.func.dfg.value_type(rhs_val);
                    if rhs_type == types::I64 {
                        // Already a raw pointer
                        rhs_val
                    } else {
                        // f64 - could be NaN-boxed or raw pointer bitcast
                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                        let val_f64 = ensure_f64(builder, rhs_val);
                        let call = builder.ins().call(get_str_ptr_ref, &[val_f64]);
                        builder.inst_results(call)[0]
                    }
                } else {
                    // Check if the value is already i64 (a string pointer from function call)
                    let rhs_type = builder.func.dfg.value_type(rhs_val);
                    if rhs_type == types::I64 {
                        // Already a string pointer
                        rhs_val
                    } else {
                        // Check if the right operand is a LocalGet referencing a variable that
                        // might be a string pointer (not marked as union, not a number)
                        let might_be_string_ptr = match right.as_ref() {
                            Expr::LocalGet(id) => {
                                // If the variable is stored as f64 but not marked as union or integer,
                                // it might be a string pointer bitcast to f64
                                locals.get(id).map(|i| !i.is_union && !i.is_pointer && !i.is_integer && !i.is_array && !i.is_bigint).unwrap_or(false)
                            }
                            _ => false,
                        };
                        if might_be_string_ptr {
                            // Assume it's a string pointer stored as f64 - just bitcast back to i64
                            ensure_i64(builder, rhs_val)
                        } else {
                            // Unknown f64 - could be NaN-boxed string or number
                            // Use js_jsvalue_to_string which handles both cases
                            let jsvalue_to_str_func = extern_funcs.get("js_jsvalue_to_string")
                                .ok_or_else(|| anyhow!("js_jsvalue_to_string not declared"))?;
                            let func_ref = module.declare_func_in_func(*jsvalue_to_str_func, builder.func);
                            let call = builder.ins().call(func_ref, &[rhs_val]);
                            builder.inst_results(call)[0]
                        }
                    }
                };

                let concat_func = extern_funcs.get("js_string_concat")
                    .ok_or_else(|| anyhow!("js_string_concat not declared"))?;
                let func_ref = module.declare_func_in_func(*concat_func, builder.func);

                let call = builder.ins().call(func_ref, &[lhs_ptr, rhs_ptr]);
                let result_ptr = builder.inst_results(call)[0];

                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr));
            }

            // Check if this is BigInt arithmetic
            let is_bigint_left = match left.as_ref() {
                Expr::BigInt(_) => true,
                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_bigint).unwrap_or(false),
                _ => false,
            };
            let is_bigint_right = match right.as_ref() {
                Expr::BigInt(_) => true,
                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_bigint).unwrap_or(false),
                _ => false,
            };

            if is_bigint_left || is_bigint_right {
                // BigInt arithmetic
                let lhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                let rhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;

                let func_name = match op {
                    BinaryOp::Add => "js_bigint_add",
                    BinaryOp::Sub => "js_bigint_sub",
                    BinaryOp::Mul => "js_bigint_mul",
                    BinaryOp::Div => "js_bigint_div",
                    BinaryOp::Mod => "js_bigint_mod",
                    BinaryOp::Pow => "js_bigint_pow",
                    BinaryOp::Shl => "js_bigint_shl",
                    BinaryOp::Shr => "js_bigint_shr",
                    BinaryOp::BitAnd => "js_bigint_and",
                    BinaryOp::BitOr => "js_bigint_or",
                    BinaryOp::BitXor => "js_bigint_xor",
                    _ => return Err(anyhow!("Unsupported BigInt binary op: {:?}", op)),
                };

                let bigint_func = extern_funcs.get(func_name)
                    .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                let func_ref = module.declare_func_in_func(*bigint_func, builder.func);

                // Extract BigInt pointers from NaN-boxed values
                let get_bigint_func = extern_funcs.get("js_nanbox_get_bigint")
                    .ok_or_else(|| anyhow!("js_nanbox_get_bigint not declared"))?;
                let get_bigint_ref = module.declare_func_in_func(*get_bigint_func, builder.func);

                let lhs_f64 = ensure_f64(builder, lhs);
                let lhs_call = builder.ins().call(get_bigint_ref, &[lhs_f64]);
                let lhs_ptr = builder.inst_results(lhs_call)[0];

                let rhs_f64 = ensure_f64(builder, rhs);
                let rhs_call = builder.ins().call(get_bigint_ref, &[rhs_f64]);
                let rhs_ptr = builder.inst_results(rhs_call)[0];

                let call = builder.ins().call(func_ref, &[lhs_ptr, rhs_ptr]);
                let result_ptr = builder.inst_results(call)[0];

                // NaN-box the result BigInt pointer
                let nanbox_func = extern_funcs.get("js_nanbox_bigint")
                    .ok_or_else(|| anyhow!("js_nanbox_bigint not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                return Ok(builder.inst_results(nanbox_call)[0]);
            }

            // Check if both operands are integers for native i64 arithmetic optimization
            fn is_int_operand(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::Integer(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_integer).unwrap_or(false),
                    // Bitwise operations always produce integers
                    Expr::Binary { op: BinaryOp::BitAnd | BinaryOp::BitOr | BinaryOp::BitXor |
                                       BinaryOp::Shl | BinaryOp::Shr | BinaryOp::UShr, .. } => true,
                    // Arithmetic on integers produces integers
                    Expr::Binary { op: BinaryOp::Add | BinaryOp::Sub | BinaryOp::Mul | BinaryOp::Mod, left, right } => {
                        is_int_operand(left, locals) && is_int_operand(right, locals)
                    }
                    Expr::Unary { op: UnaryOp::Neg, operand } => is_int_operand(operand, locals),
                    Expr::Unary { op: UnaryOp::BitNot, .. } => true,
                    // Array/string .length is always an integer
                    Expr::PropertyGet { property, object } if property == "length" => {
                        if let Expr::LocalGet(id) = object.as_ref() {
                            locals.get(id).map(|i| i.is_array || i.is_string).unwrap_or(false)
                        } else {
                            false
                        }
                    }
                    _ => false,
                }
            }

            // NOTE: Integer type tracking (is_int_operand) is preserved for future optimization.
            // For now, we don't apply special integer arithmetic optimizations because:
            // - Variables are stored as f64, so f64->i64->f64 conversion adds overhead
            // - Simple fadd/fsub/fmul are just as fast as iadd/isub/imul on modern CPUs
            // - Bitwise ops still convert to i32 which is required by JavaScript semantics
            //
            // Future optimization: Store integer variables as i64 directly to avoid conversions.
            let _is_int_left = is_int_operand(left, locals);
            let _is_int_right = is_int_operand(right, locals);

            // CSE: Common Subexpression Elimination
            // If left and right are identical expressions, compile once and reuse
            fn exprs_equal(a: &Expr, b: &Expr) -> bool {
                match (a, b) {
                    (Expr::Integer(x), Expr::Integer(y)) => x == y,
                    (Expr::Number(x), Expr::Number(y)) => x.to_bits() == y.to_bits(),
                    (Expr::Bool(x), Expr::Bool(y)) => x == y,
                    (Expr::String(x), Expr::String(y)) => x == y,
                    (Expr::LocalGet(x), Expr::LocalGet(y)) => x == y,
                    (Expr::Binary { op: op1, left: l1, right: r1 },
                     Expr::Binary { op: op2, left: l2, right: r2 }) => {
                        op1 == op2 && exprs_equal(l1, l2) && exprs_equal(r1, r2)
                    }
                    (Expr::Unary { op: op1, operand: o1 },
                     Expr::Unary { op: op2, operand: o2 }) => {
                        op1 == op2 && exprs_equal(o1, o2)
                    }
                    (Expr::PropertyGet { object: o1, property: p1 },
                     Expr::PropertyGet { object: o2, property: p2 }) => {
                        p1 == p2 && exprs_equal(o1, o2)
                    }
                    _ => false,
                }
            }

            // CSE OPTIMIZATION: Check for cached squared value (var * var) or product (var * other_var)
            if *op == BinaryOp::Mul {
                if let (Expr::LocalGet(l_id), Expr::LocalGet(r_id)) = (left.as_ref(), right.as_ref()) {
                    if l_id == r_id {
                        // Squared: var * var
                        if let Some(info) = locals.get(l_id) {
                            if let Some(cache_var) = info.squared_cache {
                                return Ok(builder.use_var(cache_var));
                            }
                        }
                    } else {
                        // Product: var * other_var - check if we have a cached product
                        if let Some(info) = locals.get(l_id) {
                            if let Some(ref product_cache) = info.product_cache {
                                if let Some(cache_var) = product_cache.get(r_id) {
                                    return Ok(builder.use_var(*cache_var));
                                }
                            }
                        }
                    }
                }
            }

            // FMA OPTIMIZATION: Fused Multiply-Add for a * b + c patterns
            // Uses single FMA instruction which is faster and more accurate
            if *op == BinaryOp::Add {
                // Pattern: (a * b) + c
                if let Expr::Binary { op: BinaryOp::Mul, left: mul_left, right: mul_right } = left.as_ref() {
                    // Check for (const * x) * y pattern with cached xy
                    // Transforms: fma((const*x), y, c) -> fma(const, cached_xy, c)
                    if let Expr::Binary { op: BinaryOp::Mul, left: inner_left, right: inner_right } = mul_left.as_ref() {
                        // Pattern: ((const * x) * y) + c
                        if let (Expr::Number(_) | Expr::Integer(_), Expr::LocalGet(x_id)) = (inner_left.as_ref(), inner_right.as_ref()) {
                            if let Expr::LocalGet(y_id) = mul_right.as_ref() {
                                if x_id != y_id {
                                    let canonical_pair = if x_id < y_id { (*x_id, *y_id) } else { (*y_id, *x_id) };
                                    if let Some(info) = locals.get(&canonical_pair.0) {
                                        if let Some(ref product_cache) = info.product_cache {
                                            if let Some(cache_var) = product_cache.get(&canonical_pair.1) {
                                                let konst = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, inner_left, this_ctx)?;
                                                let cached_xy = builder.use_var(*cache_var);
                                                let c = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;
                                                let konst_f64 = ensure_f64(builder, konst);
                                                let cached_xy_f64 = ensure_f64(builder, cached_xy);
                                                let c_f64 = ensure_f64(builder, c);
                                                return Ok(builder.ins().fma(konst_f64, cached_xy_f64, c_f64));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        // Pattern: ((x * const) * y) + c
                        if let (Expr::LocalGet(x_id), Expr::Number(_) | Expr::Integer(_)) = (inner_left.as_ref(), inner_right.as_ref()) {
                            if let Expr::LocalGet(y_id) = mul_right.as_ref() {
                                if x_id != y_id {
                                    let canonical_pair = if x_id < y_id { (*x_id, *y_id) } else { (*y_id, *x_id) };
                                    if let Some(info) = locals.get(&canonical_pair.0) {
                                        if let Some(ref product_cache) = info.product_cache {
                                            if let Some(cache_var) = product_cache.get(&canonical_pair.1) {
                                                let konst = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, inner_right, this_ctx)?;
                                                let cached_xy = builder.use_var(*cache_var);
                                                let c = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;
                                                let konst_f64 = ensure_f64(builder, konst);
                                                let cached_xy_f64 = ensure_f64(builder, cached_xy);
                                                let c_f64 = ensure_f64(builder, c);
                                                return Ok(builder.ins().fma(konst_f64, cached_xy_f64, c_f64));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    let a = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, mul_left, this_ctx)?;
                    let a_f64 = ensure_f64(builder, a);
                    let b = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, mul_right, this_ctx)?;
                    let b_f64 = ensure_f64(builder, b);
                    let c = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;
                    let c_f64 = ensure_f64(builder, c);
                    return Ok(builder.ins().fma(a_f64, b_f64, c_f64));
                }
                // Pattern: c + (a * b)
                if let Expr::Binary { op: BinaryOp::Mul, left: mul_left, right: mul_right } = right.as_ref() {
                    let c = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                    let c_f64 = ensure_f64(builder, c);
                    let a = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, mul_left, this_ctx)?;
                    let a_f64 = ensure_f64(builder, a);
                    let b = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, mul_right, this_ctx)?;
                    let b_f64 = ensure_f64(builder, b);
                    return Ok(builder.ins().fma(a_f64, b_f64, c_f64));
                }
            }

            // FMS OPTIMIZATION: Fused Multiply-Subtract for a * b - c patterns
            // fma(a, b, -c) = a * b - c
            if *op == BinaryOp::Sub {
                // Pattern: (a * b) - c  =>  fma(a, b, -c)
                if let Expr::Binary { op: BinaryOp::Mul, left: mul_left, right: mul_right } = left.as_ref() {
                    let a_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, mul_left, this_ctx)?;
                    let a = ensure_f64(builder, a_raw);
                    let b_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, mul_right, this_ctx)?;
                    let b = ensure_f64(builder, b_raw);
                    let c_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;
                    let c = ensure_f64(builder, c_raw);
                    let neg_c = builder.ins().fneg(c);
                    return Ok(builder.ins().fma(a, b, neg_c));
                }
            }

            let (lhs, rhs) = if exprs_equal(left, right) {
                // Same expression - compile once and reuse
                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                // Ensure f64 for arithmetic operations (values may be i64 for Any-typed parameters)
                let val = ensure_f64(builder, val);
                (val, val)
            } else {
                let l = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                let r = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;
                // Ensure f64 for arithmetic operations (values may be i64 for Any-typed parameters)
                (ensure_f64(builder, l), ensure_f64(builder, r))
            };
            let result = match op {
                BinaryOp::Add => builder.ins().fadd(lhs, rhs),
                BinaryOp::Sub => builder.ins().fsub(lhs, rhs),
                BinaryOp::Mul => builder.ins().fmul(lhs, rhs),
                BinaryOp::Div => builder.ins().fdiv(lhs, rhs),
                BinaryOp::Mod => {
                    // OPTIMIZATION: Use native integer modulo when possible
                    // Check if left operand is an i32 variable and right is a constant
                    let i32_mod_info: Option<(Variable, i32)> = if let Expr::LocalGet(id) = left.as_ref() {
                        if let Some(info) = locals.get(id) {
                            if info.is_i32 {
                                // Left is i32, check if right is a constant
                                match right.as_ref() {
                                    Expr::Integer(n) if *n > 0 && *n <= i32::MAX as i64 => Some((info.var, *n as i32)),
                                    Expr::Number(f) if *f > 0.0 && *f <= i32::MAX as f64 && f.fract() == 0.0 => Some((info.var, *f as i32)),
                                    _ => None,
                                }
                            } else { None }
                        } else { None }
                    } else { None };

                    if let Some((i32_var, divisor)) = i32_mod_info {
                        // Native i32 modulo - use i32 variable directly, no f64 conversion!
                        let lhs_i32 = builder.use_var(i32_var);
                        let divisor_val = builder.ins().iconst(types::I32, divisor as i64);
                        let result_i32 = builder.ins().srem(lhs_i32, divisor_val);
                        builder.ins().fcvt_from_sint(types::F64, result_i32)
                    } else {
                        // f64 % f64 using fmod pattern: a - (a/b).trunc() * b
                        let div = builder.ins().fdiv(lhs, rhs);
                        let trunc = builder.ins().trunc(div);
                        let prod = builder.ins().fmul(trunc, rhs);
                        builder.ins().fsub(lhs, prod)
                    }
                }
                BinaryOp::Pow => {
                    // Call js_math_pow runtime function for exponentiation
                    let func = extern_funcs.get("js_math_pow")
                        .ok_or_else(|| anyhow!("js_math_pow not declared"))?;
                    let func_ref = module.declare_func_in_func(*func, builder.func);
                    let call = builder.ins().call(func_ref, &[lhs, rhs]);
                    builder.inst_results(call)[0]
                }
                // Bitwise operations - JavaScript works on 32-bit integers
                // Convert f64 to i32, perform op, convert back to f64
                BinaryOp::BitAnd => {
                    let lhs_i32 = builder.ins().fcvt_to_sint(types::I32, lhs);
                    let rhs_i32 = builder.ins().fcvt_to_sint(types::I32, rhs);
                    let result = builder.ins().band(lhs_i32, rhs_i32);
                    builder.ins().fcvt_from_sint(types::F64, result)
                }
                BinaryOp::BitOr => {
                    let lhs_i32 = builder.ins().fcvt_to_sint(types::I32, lhs);
                    let rhs_i32 = builder.ins().fcvt_to_sint(types::I32, rhs);
                    let result = builder.ins().bor(lhs_i32, rhs_i32);
                    builder.ins().fcvt_from_sint(types::F64, result)
                }
                BinaryOp::BitXor => {
                    let lhs_i32 = builder.ins().fcvt_to_sint(types::I32, lhs);
                    let rhs_i32 = builder.ins().fcvt_to_sint(types::I32, rhs);
                    let result = builder.ins().bxor(lhs_i32, rhs_i32);
                    builder.ins().fcvt_from_sint(types::F64, result)
                }
                BinaryOp::Shl => {
                    let lhs_i32 = builder.ins().fcvt_to_sint(types::I32, lhs);
                    let rhs_i32 = builder.ins().fcvt_to_sint(types::I32, rhs);
                    // JavaScript only uses the low 5 bits of the shift amount
                    let shift_mask = builder.ins().iconst(types::I32, 0x1f);
                    let shift_amt = builder.ins().band(rhs_i32, shift_mask);
                    let result = builder.ins().ishl(lhs_i32, shift_amt);
                    builder.ins().fcvt_from_sint(types::F64, result)
                }
                BinaryOp::Shr => {
                    // Signed right shift
                    let lhs_i32 = builder.ins().fcvt_to_sint(types::I32, lhs);
                    let rhs_i32 = builder.ins().fcvt_to_sint(types::I32, rhs);
                    // JavaScript only uses the low 5 bits of the shift amount
                    let shift_mask = builder.ins().iconst(types::I32, 0x1f);
                    let shift_amt = builder.ins().band(rhs_i32, shift_mask);
                    let result = builder.ins().sshr(lhs_i32, shift_amt);
                    builder.ins().fcvt_from_sint(types::F64, result)
                }
                BinaryOp::UShr => {
                    // Unsigned right shift - returns unsigned result
                    let lhs_i32 = builder.ins().fcvt_to_sint(types::I32, lhs);
                    let rhs_i32 = builder.ins().fcvt_to_sint(types::I32, rhs);
                    // JavaScript only uses the low 5 bits of the shift amount
                    let shift_mask = builder.ins().iconst(types::I32, 0x1f);
                    let shift_amt = builder.ins().band(rhs_i32, shift_mask);
                    let result = builder.ins().ushr(lhs_i32, shift_amt);
                    // Convert unsigned i32 to f64 (need to use unsigned conversion)
                    builder.ins().fcvt_from_uint(types::F64, result)
                }
            };
            Ok(result)
        }
        Expr::Unary { op, operand } => {
            let val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, operand, this_ctx)?;
            let val = ensure_f64(builder, val_raw);
            match op {
                UnaryOp::Neg => Ok(builder.ins().fneg(val)),
                UnaryOp::Not => {
                    // Logical not: 0 -> 1, non-zero -> 0
                    let zero = builder.ins().f64const(0.0);
                    let one = builder.ins().f64const(1.0);
                    let is_zero = builder.ins().fcmp(FloatCC::Equal, val, zero);
                    Ok(builder.ins().select(is_zero, one, zero))
                }
                UnaryOp::BitNot => {
                    // Bitwise NOT: ~x
                    // Convert f64 to i32, apply bnot, convert back to f64
                    let val_i32 = builder.ins().fcvt_to_sint(types::I32, val);
                    let result = builder.ins().bnot(val_i32);
                    Ok(builder.ins().fcvt_from_sint(types::F64, result))
                }
                UnaryOp::Pos => {
                    // Unary plus: +x (just returns the value, already a number)
                    Ok(val)
                }
            }
        }
        Expr::Compare { op, left, right } => {
            // Check if comparing with null/undefined (for optional chaining)
            let is_null_compare = matches!(left.as_ref(), Expr::Null | Expr::Undefined)
                || matches!(right.as_ref(), Expr::Null | Expr::Undefined);

            // Check if this is a string comparison
            // String comparison is needed when:
            // - One side is a TypeOf expression (always returns string)
            // - One side is a string literal
            // - One side is a string local variable
            // - One side is a PropertyGet (might return a NaN-boxed string)
            fn is_known_string_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::TypeOf(_) => true,
                    Expr::String(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    _ => false,
                }
            }
            fn may_be_string_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::PropertyGet { .. } => true,
                    Expr::IndexGet { .. } => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_union || i.is_string).unwrap_or(false),
                    _ => is_known_string_expr(expr, locals),
                }
            }

            // Static string comparison: both sides are known strings (no NaN-boxing involved)
            let is_static_string_compare = is_known_string_expr(left, locals) && is_known_string_expr(right, locals);
            // Dynamic string comparison: one side is a string literal/known string, other might be NaN-boxed
            let is_dynamic_string_compare = !is_static_string_compare &&
                (is_known_string_expr(left, locals) && may_be_string_expr(right, locals)) ||
                (may_be_string_expr(left, locals) && is_known_string_expr(right, locals));

            let lhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
            let rhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;

            // If comparing with null, check if other operand is i64 (object pointer)
            // In that case, use icmp instead of fcmp
            let lhs_type = builder.func.dfg.value_type(lhs);
            let rhs_type = builder.func.dfg.value_type(rhs);

            let one = builder.ins().f64const(1.0);
            let zero = builder.ins().f64const(0.0);

            if is_static_string_compare && (*op == CompareOp::Eq || *op == CompareOp::Ne) {
                // Static string comparison: use js_string_equals
                // Strings are NaN-boxed, extract raw pointers using js_get_string_pointer_unified
                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);

                let lhs_f64 = ensure_f64(builder, lhs);
                let lhs_call = builder.ins().call(get_str_ptr_ref, &[lhs_f64]);
                let lhs_ptr = builder.inst_results(lhs_call)[0];

                let rhs_f64 = ensure_f64(builder, rhs);
                let rhs_call = builder.ins().call(get_str_ptr_ref, &[rhs_f64]);
                let rhs_ptr = builder.inst_results(rhs_call)[0];

                let equals_func = extern_funcs.get("js_string_equals")
                    .ok_or_else(|| anyhow!("js_string_equals not declared"))?;
                let equals_ref = module.declare_func_in_func(*equals_func, builder.func);
                let call = builder.ins().call(equals_ref, &[lhs_ptr, rhs_ptr]);
                let result = builder.inst_results(call)[0]; // i32 bool

                // Convert to f64 result
                if *op == CompareOp::Eq {
                    let cmp = builder.ins().icmp_imm(IntCC::NotEqual, result, 0);
                    Ok(builder.ins().select(cmp, one, zero))
                } else {
                    // Ne
                    let cmp = builder.ins().icmp_imm(IntCC::Equal, result, 0);
                    Ok(builder.ins().select(cmp, one, zero))
                }
            } else if is_dynamic_string_compare && (*op == CompareOp::Eq || *op == CompareOp::Ne) {
                // Dynamic string comparison: one side may be NaN-boxed
                // Use js_dynamic_string_equals which handles both representations
                let lhs_f64 = ensure_f64(builder, lhs);
                let rhs_f64 = ensure_f64(builder, rhs);

                let equals_func = extern_funcs.get("js_dynamic_string_equals")
                    .ok_or_else(|| anyhow!("js_dynamic_string_equals not declared"))?;
                let equals_ref = module.declare_func_in_func(*equals_func, builder.func);
                let call = builder.ins().call(equals_ref, &[lhs_f64, rhs_f64]);
                let result = builder.inst_results(call)[0]; // i32 bool

                // Convert to f64 result
                if *op == CompareOp::Eq {
                    let cmp = builder.ins().icmp_imm(IntCC::NotEqual, result, 0);
                    Ok(builder.ins().select(cmp, one, zero))
                } else {
                    // Ne
                    let cmp = builder.ins().icmp_imm(IntCC::Equal, result, 0);
                    Ok(builder.ins().select(cmp, one, zero))
                }
            } else if is_null_compare && (lhs_type == types::I64 || rhs_type == types::I64) {
                // For null comparisons with objects, use integer comparison
                // Convert both to i64 for comparison
                let lhs_i64 = if lhs_type == types::I64 { lhs } else {
                    builder.ins().iconst(types::I64, 0)  // null = 0
                };
                let rhs_i64 = if rhs_type == types::I64 { rhs } else {
                    builder.ins().iconst(types::I64, 0)  // null = 0
                };
                let icc = match op {
                    CompareOp::Eq => IntCC::Equal,
                    CompareOp::Ne => IntCC::NotEqual,
                    _ => return Err(anyhow!("Invalid null comparison operator")),
                };
                let cmp = builder.ins().icmp(icc, lhs_i64, rhs_i64);
                Ok(builder.ins().select(cmp, one, zero))
            } else {
                // Check if this is a BigInt comparison
                fn is_bigint_compare_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                    match expr {
                        Expr::BigInt(_) => true,
                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_bigint).unwrap_or(false),
                        Expr::Binary { left, right, .. } => {
                            is_bigint_compare_expr(left, locals) || is_bigint_compare_expr(right, locals)
                        }
                        _ => false,
                    }
                }

                let is_bigint_compare = is_bigint_compare_expr(left, locals) || is_bigint_compare_expr(right, locals);

                if is_bigint_compare {
                    // BigInt comparison - use js_bigint_cmp
                    let get_bigint_func = extern_funcs.get("js_nanbox_get_bigint")
                        .ok_or_else(|| anyhow!("js_nanbox_get_bigint not declared"))?;
                    let get_bigint_ref = module.declare_func_in_func(*get_bigint_func, builder.func);

                    let lhs_f64 = ensure_f64(builder, lhs);
                    let lhs_call = builder.ins().call(get_bigint_ref, &[lhs_f64]);
                    let lhs_ptr = builder.inst_results(lhs_call)[0];

                    let rhs_f64 = ensure_f64(builder, rhs);
                    let rhs_call = builder.ins().call(get_bigint_ref, &[rhs_f64]);
                    let rhs_ptr = builder.inst_results(rhs_call)[0];

                    let cmp_func = extern_funcs.get("js_bigint_cmp")
                        .ok_or_else(|| anyhow!("js_bigint_cmp not declared"))?;
                    let cmp_ref = module.declare_func_in_func(*cmp_func, builder.func);
                    let cmp_call = builder.ins().call(cmp_ref, &[lhs_ptr, rhs_ptr]);
                    let cmp_result = builder.inst_results(cmp_call)[0]; // -1, 0, or 1

                    // Convert cmp result to boolean based on operation
                    let result_bool = match op {
                        CompareOp::Eq => builder.ins().icmp_imm(IntCC::Equal, cmp_result, 0),
                        CompareOp::Ne => builder.ins().icmp_imm(IntCC::NotEqual, cmp_result, 0),
                        CompareOp::Lt => builder.ins().icmp_imm(IntCC::SignedLessThan, cmp_result, 0),
                        CompareOp::Le => builder.ins().icmp_imm(IntCC::SignedLessThanOrEqual, cmp_result, 0),
                        CompareOp::Gt => builder.ins().icmp_imm(IntCC::SignedGreaterThan, cmp_result, 0),
                        CompareOp::Ge => builder.ins().icmp_imm(IntCC::SignedGreaterThanOrEqual, cmp_result, 0),
                    };
                    Ok(builder.ins().select(result_bool, one, zero))
                } else {
                    // Check if this is a boolean comparison (NaN-boxed booleans can't use fcmp)
                    fn is_bool_expr(expr: &Expr) -> bool {
                        matches!(expr, Expr::Bool(_))
                    }
                    let is_bool_compare = is_bool_expr(left) || is_bool_expr(right);

                    if is_bool_compare && (*op == CompareOp::Eq || *op == CompareOp::Ne) {
                        // Boolean comparison: NaN-boxed booleans must be compared by bit pattern
                        // Bitcast f64 to i64 and do integer comparison
                        let lhs_f64 = ensure_f64(builder, lhs);
                        let rhs_f64 = ensure_f64(builder, rhs);
                        let lhs_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), lhs_f64);
                        let rhs_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), rhs_f64);
                        let icc = match op {
                            CompareOp::Eq => IntCC::Equal,
                            CompareOp::Ne => IntCC::NotEqual,
                            _ => unreachable!(),
                        };
                        let cmp = builder.ins().icmp(icc, lhs_i64, rhs_i64);
                        Ok(builder.ins().select(cmp, one, zero))
                    } else {
                        // Regular float comparison - ensure both operands are f64
                        let lhs_f64 = ensure_f64(builder, lhs);
                        let rhs_f64 = ensure_f64(builder, rhs);
                        let cc = match op {
                            CompareOp::Eq => FloatCC::Equal,
                            CompareOp::Ne => FloatCC::NotEqual,
                            CompareOp::Lt => FloatCC::LessThan,
                            CompareOp::Le => FloatCC::LessThanOrEqual,
                            CompareOp::Gt => FloatCC::GreaterThan,
                            CompareOp::Ge => FloatCC::GreaterThanOrEqual,
                        };
                        let cmp = builder.ins().fcmp(cc, lhs_f64, rhs_f64);
                        Ok(builder.ins().select(cmp, one, zero))
                    }
                }
            }
        }
        Expr::Logical { op, left, right } => {
            match op {
                LogicalOp::And => {
                    // Short-circuit AND
                    let lhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                    let lhs_type = builder.func.dfg.value_type(lhs);

                    // Check if lhs is truthy - handle both f64 and i64 types
                    // Use js_is_truthy for f64 to handle undefined/null/NaN/empty string
                    let (lhs_bool, falsy_val) = if lhs_type == types::I64 {
                        // For i64 (pointers), null is 0 and non-null objects are truthy
                        let zero_i64 = builder.ins().iconst(types::I64, 0);
                        (builder.ins().icmp(IntCC::NotEqual, lhs, zero_i64), zero_i64)
                    } else {
                        let lhs_f64 = ensure_f64(builder, lhs);
                        let truthy_func = extern_funcs.get("js_is_truthy")
                            .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                        let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                        let truthy_call = builder.ins().call(truthy_ref, &[lhs_f64]);
                        let truthy_result = builder.inst_results(truthy_call)[0];
                        let zero_i32 = builder.ins().iconst(types::I32, 0);
                        let zero_f64 = builder.ins().f64const(0.0);
                        (builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32), zero_f64)
                    };

                    let rhs_block = builder.create_block();
                    let merge_block = builder.create_block();
                    // Always use F64 for merge block since we need to preserve NaN-boxed values
                    let merge_type = if lhs_type == types::I64 { types::I64 } else { types::F64 };
                    builder.append_block_param(merge_block, merge_type);

                    // For falsy case, pass the original lhs value (not just zero)
                    let lhs_for_merge = if lhs_type == types::I64 {
                        lhs
                    } else {
                        ensure_f64(builder, lhs)
                    };
                    builder.ins().brif(lhs_bool, rhs_block, &[], merge_block, &[lhs_for_merge]);

                    builder.switch_to_block(rhs_block);
                    builder.seal_block(rhs_block);
                    let rhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;
                    // Convert rhs to match merge_type if needed
                    // For i64->f64 conversion, we need to NaN-box the pointer to preserve type info
                    let rhs_converted = if merge_type == types::I64 && builder.func.dfg.value_type(rhs) == types::F64 {
                        builder.ins().bitcast(types::I64, MemFlags::new(), rhs)
                    } else if merge_type == types::F64 && builder.func.dfg.value_type(rhs) == types::I64 {
                        // NaN-box the pointer (could be string, object, array, etc.)
                        // Use js_nanbox_string for strings (most common case from literals)
                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                        let call = builder.ins().call(nanbox_ref, &[rhs]);
                        builder.inst_results(call)[0]
                    } else {
                        rhs
                    };
                    builder.ins().jump(merge_block, &[rhs_converted]);

                    builder.switch_to_block(merge_block);
                    builder.seal_block(merge_block);
                    Ok(builder.block_params(merge_block)[0])
                }
                LogicalOp::Or => {
                    // Short-circuit OR
                    let lhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                    let lhs_type = builder.func.dfg.value_type(lhs);

                    // Check if lhs is truthy - handle both f64 and i64 types
                    // Use js_is_truthy for f64 to handle undefined/null/NaN/empty string
                    let lhs_bool = if lhs_type == types::I64 {
                        // For i64 (pointers), null is 0 and non-null objects are truthy
                        let zero_i64 = builder.ins().iconst(types::I64, 0);
                        builder.ins().icmp(IntCC::NotEqual, lhs, zero_i64)
                    } else {
                        let lhs_f64 = ensure_f64(builder, lhs);
                        let truthy_func = extern_funcs.get("js_is_truthy")
                            .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
                        let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
                        let truthy_call = builder.ins().call(truthy_ref, &[lhs_f64]);
                        let truthy_result = builder.inst_results(truthy_call)[0];
                        let zero_i32 = builder.ins().iconst(types::I32, 0);
                        builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32)
                    };

                    let rhs_block = builder.create_block();
                    let merge_block = builder.create_block();
                    builder.append_block_param(merge_block, lhs_type);

                    builder.ins().brif(lhs_bool, merge_block, &[lhs], rhs_block, &[]);

                    builder.switch_to_block(rhs_block);
                    builder.seal_block(rhs_block);
                    let rhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;
                    // Convert rhs to match lhs_type if needed
                    // For i64->f64 conversion, we need to NaN-box the pointer to preserve type info
                    let rhs_converted = if lhs_type == types::I64 && builder.func.dfg.value_type(rhs) == types::F64 {
                        builder.ins().bitcast(types::I64, MemFlags::new(), rhs)
                    } else if lhs_type == types::F64 && builder.func.dfg.value_type(rhs) == types::I64 {
                        // NaN-box the pointer (could be string, object, array, etc.)
                        // Use js_nanbox_string for strings (most common case from literals)
                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                        let call = builder.ins().call(nanbox_ref, &[rhs]);
                        builder.inst_results(call)[0]
                    } else {
                        rhs
                    };
                    builder.ins().jump(merge_block, &[rhs_converted]);

                    builder.switch_to_block(merge_block);
                    builder.seal_block(merge_block);
                    Ok(builder.block_params(merge_block)[0])
                }
                LogicalOp::Coalesce => {
                    // Nullish coalescing: return left if not null/undefined, else right
                    let lhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, left, this_ctx)?;
                    let lhs_type = builder.func.dfg.value_type(lhs);

                    // Check if lhs is null/undefined (0 for both i64 and f64)
                    let is_null = if lhs_type == types::I64 {
                        let zero_i64 = builder.ins().iconst(types::I64, 0);
                        builder.ins().icmp(IntCC::Equal, lhs, zero_i64)
                    } else {
                        let zero = builder.ins().f64const(0.0);
                        builder.ins().fcmp(FloatCC::Equal, lhs, zero)
                    };

                    // Short-circuit: if lhs is null, evaluate rhs
                    let rhs_block = builder.create_block();
                    let merge_block = builder.create_block();
                    builder.append_block_param(merge_block, lhs_type);

                    builder.ins().brif(is_null, rhs_block, &[], merge_block, &[lhs]);

                    builder.switch_to_block(rhs_block);
                    builder.seal_block(rhs_block);
                    let rhs = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, right, this_ctx)?;
                    // Convert rhs to lhs_type if needed
                    let rhs_converted = if lhs_type == types::I64 && builder.func.dfg.value_type(rhs) == types::F64 {
                        builder.ins().bitcast(types::I64, MemFlags::new(), rhs)
                    } else if lhs_type == types::F64 && builder.func.dfg.value_type(rhs) == types::I64 {
                        builder.ins().bitcast(types::F64, MemFlags::new(), rhs)
                    } else {
                        rhs
                    };
                    builder.ins().jump(merge_block, &[rhs_converted]);

                    builder.switch_to_block(merge_block);
                    builder.seal_block(merge_block);
                    Ok(builder.block_params(merge_block)[0])
                }
            }
        }
        Expr::Call { callee, args, .. } => {
            // Compile arguments
            let arg_vals: Vec<Value> = args.iter()
                .map(|a| compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, a, this_ctx))
                .collect::<Result<_>>()?;

            match callee.as_ref() {
                Expr::FuncRef(func_id) => {
                    let clif_func_id = func_ids.get(func_id)
                        .ok_or_else(|| anyhow!("Unknown function ID: {}", func_id))?;
                    let func_ref = module.declare_func_in_func(*clif_func_id, builder.func);

                    // Handle rest parameters: if the function has a rest parameter,
                    // collect all arguments from rest_idx onwards into an array
                    let final_args: Vec<Value> = if let Some(&rest_idx) = func_rest_param_index.get(func_id) {
                        // Split arguments: regular args before rest_idx, rest args from rest_idx onwards
                        let regular_args = &arg_vals[..rest_idx.min(arg_vals.len())];
                        let rest_args = if rest_idx < arg_vals.len() {
                            &arg_vals[rest_idx..]
                        } else {
                            &[]
                        };

                        // Create an array from rest arguments
                        let rest_array = if rest_args.is_empty() {
                            // Empty array
                            let alloc_func = extern_funcs.get("js_array_from_f64")
                                .ok_or_else(|| anyhow!("js_array_from_f64 not declared"))?;
                            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                            let null_ptr = builder.ins().iconst(types::I64, 0);
                            let zero_count = builder.ins().iconst(types::I32, 0);
                            let call = builder.ins().call(alloc_ref, &[null_ptr, zero_count]);
                            builder.inst_results(call)[0]
                        } else {
                            // Create stack slot and store elements
                            let count = rest_args.len();
                            let slot = builder.create_sized_stack_slot(StackSlotData::new(
                                StackSlotKind::ExplicitSlot,
                                (count * 8) as u32,
                                0,
                            ));
                            for (i, &val) in rest_args.iter().enumerate() {
                                builder.ins().stack_store(val, slot, (i * 8) as i32);
                            }
                            let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
                            let alloc_func = extern_funcs.get("js_array_from_f64")
                                .ok_or_else(|| anyhow!("js_array_from_f64 not declared"))?;
                            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                            let count_val = builder.ins().iconst(types::I32, count as i64);
                            let call = builder.ins().call(alloc_ref, &[slot_addr, count_val]);
                            builder.inst_results(call)[0]
                        };

                        // Combine regular args with rest array
                        let mut result = regular_args.to_vec();
                        result.push(rest_array);
                        result
                    } else {
                        arg_vals.clone()
                    };

                    // Helper to check if argument expression is a string
                    fn is_string_arg_expr(arg: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                        match arg {
                            Expr::String(_) => true,
                            Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                            _ => false,
                        }
                    }

                    // Convert arguments to match expected parameter types
                    // For union-typed parameters, NaN-box strings with STRING_TAG
                    let union_params = func_union_params.get(func_id);
                    let converted_args: Vec<Value> = if let Some(param_types) = func_param_types.get(func_id) {
                        final_args.iter().enumerate().map(|(i, &val)| {
                            // Check if this parameter is a union type
                            let is_union_param = union_params.and_then(|p| p.get(i).copied()).unwrap_or(false);

                            if is_union_param && i < args.len() && is_string_arg_expr(&args[i], locals) {
                                // String being passed to union-typed parameter: NaN-box with STRING_TAG
                                let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                                let nanbox_func = extern_funcs.get("js_nanbox_string")
                                    .expect("js_nanbox_string not declared");
                                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                let call = builder.ins().call(nanbox_ref, &[ptr]);
                                builder.inst_results(call)[0]
                            } else if i < param_types.len() && param_types[i] == types::I64 {
                                // Parameter expects i64 (string/array/object), but we have f64
                                // The f64 may be NaN-boxed (e.g., from array access like rows[0])
                                // We need to extract the raw pointer using js_nanbox_get_pointer
                                if builder.func.dfg.value_type(val) == types::I64 {
                                    val
                                } else {
                                    // Extract pointer from NaN-boxed value
                                    let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                                        .expect("js_nanbox_get_pointer not declared");
                                    let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                                    let call = builder.ins().call(get_ptr_ref, &[val]);
                                    builder.inst_results(call)[0]
                                }
                            } else if i < param_types.len() && param_types[i] == types::F64 {
                                // Parameter expects f64 - ensure we have f64
                                ensure_f64(builder, val)
                            } else {
                                // Default to f64 for user-defined functions
                                ensure_f64(builder, val)
                            }
                        }).collect()
                    } else {
                        // No param type info available - default to f64 for all args
                        // since user-defined functions are declared with f64 params
                        final_args.iter().map(|&val| ensure_f64(builder, val)).collect()
                    };

                    // Get the expected parameter count from the actual function declaration
                    // This is important because the function might have been declared with a different
                    // signature due to optional parameters and module compilation order
                    let actual_sig = module.declarations().get_function_decl(*clif_func_id);
                    let expected_param_count = actual_sig.signature.params.len();

                    // First, ensure all existing arguments match the actual function signature types
                    // This is necessary because func_param_types might not match the actual signature
                    let mut final_call_args: Vec<Value> = converted_args.iter().enumerate()
                        .map(|(i, &val)| {
                            if i < actual_sig.signature.params.len() {
                                let expected_type = actual_sig.signature.params[i].value_type;
                                let actual_type = builder.func.dfg.value_type(val);
                                if expected_type == types::I64 && actual_type == types::F64 {
                                    builder.ins().bitcast(types::I64, MemFlags::new(), val)
                                } else if expected_type == types::F64 && actual_type == types::I64 {
                                    builder.ins().bitcast(types::F64, MemFlags::new(), val)
                                } else if expected_type == types::F64 && actual_type == types::I32 {
                                    // i32 (from loop optimization) -> f64
                                    builder.ins().fcvt_from_sint(types::F64, val)
                                } else if expected_type == types::I64 && actual_type == types::I32 {
                                    // i32 (from loop optimization) -> i64
                                    builder.ins().sextend(types::I64, val)
                                } else {
                                    val
                                }
                            } else {
                                val
                            }
                        })
                        .collect();

                    // Pad with the correct type for missing optional arguments
                    while final_call_args.len() < expected_param_count {
                        let expected_type = actual_sig.signature.params[final_call_args.len()].value_type;
                        if expected_type == types::I64 {
                            final_call_args.push(builder.ins().iconst(types::I64, 0));
                        } else {
                            final_call_args.push(builder.ins().f64const(f64::NAN));
                        }
                    }
                    // Truncate if we have too many (handles variadic-like patterns)
                    final_call_args.truncate(expected_param_count);

                    let call = builder.ins().call(func_ref, &final_call_args);
                    let result = builder.inst_results(call)[0];

                    // If calling an async function, the result is i64 (Promise ptr)
                    // Bitcast to f64 for uniform value storage
                    if async_func_ids.contains(func_id) {
                        Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result))
                    } else {
                        Ok(result)
                    }
                }
                Expr::PropertyGet { object, property } => {
                    // Handle process.argv.includes() specially
                    if matches!(object.as_ref(), Expr::ProcessArgv) && property == "includes" && args.len() >= 1 {
                        // Compile ProcessArgv to get the array pointer
                        let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                        let arr_ptr = ensure_i64(builder, arr_val);

                        // Compile the value to search for
                        let search_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;

                        // NaN-box the search value if it's a string
                        let search_f64 = if matches!(&args[0], Expr::String(_)) {
                            let ptr = ensure_i64(builder, search_val);
                            let nanbox_func = extern_funcs.get("js_nanbox_string")
                                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                            let call = builder.ins().call(nanbox_ref, &[ptr]);
                            builder.inst_results(call)[0]
                        } else {
                            ensure_f64(builder, search_val)
                        };

                        // Use js_array_includes_jsvalue which compares string contents
                        let func = extern_funcs.get("js_array_includes_jsvalue")
                            .ok_or_else(|| anyhow!("js_array_includes_jsvalue not declared"))?;
                        let func_ref = module.declare_func_in_func(*func, builder.func);
                        let call = builder.ins().call(func_ref, &[arr_ptr, search_f64]);
                        let result = builder.inst_results(call)[0];

                        // Convert i32 (0 or 1) to f64
                        return Ok(builder.ins().fcvt_from_sint(types::F64, result));
                    }

                    // Handle console.log
                    if property == "log" {
                        // Handle multiple arguments by building an array and using spread
                        if args.len() > 1 {
                            if let Some(spread_func) = extern_funcs.get("js_console_log_spread") {
                                // Helper to check if an expression produces a string
                                fn is_string_expr_for_multi(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                    match expr {
                                        Expr::String(_) => true,
                                        Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) => true,
                                        Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                        Expr::PathExtname(_) | Expr::PathResolve(_) | Expr::JsonStringify(_) => true,
                                        Expr::CryptoRandomBytes(_) | Expr::CryptoRandomUUID |
                                        Expr::CryptoSha256(_) | Expr::CryptoMd5(_) => true,
                                        Expr::DateToISOString(_) => true,
                                        Expr::TypeOf(_) => true,
                                        Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                                        Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                                        // Prioritize is_string over is_union (is_union can be set for Any-typed vars)
                                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                        Expr::Binary { op: BinaryOp::Add, left, right } => {
                                            is_string_expr_for_multi(left, locals) || is_string_expr_for_multi(right, locals)
                                        }
                                        // String method calls on string variables
                                        Expr::Call { callee, .. } => {
                                            if let Expr::PropertyGet { object, property } = callee.as_ref() {
                                                if property == "slice" || property == "substring" || property == "trim"
                                                    || property == "toLowerCase" || property == "toUpperCase"
                                                    || property == "charAt" || property == "padStart" || property == "padEnd"
                                                    || property == "repeat" || property == "replace" {
                                                    // Check if object is a string
                                                    if let Expr::LocalGet(id) = object.as_ref() {
                                                        return locals.get(id).map(|i| i.is_string).unwrap_or(false);
                                                    }
                                                }
                                            }
                                            false
                                        }
                                        _ => false,
                                    }
                                }

                                // Helper to check if an expression needs dynamic printing (union types)
                                fn is_union_expr_for_multi(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                    match expr {
                                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_union).unwrap_or(false),
                                        Expr::Conditional { .. } => true,
                                        Expr::PropertyGet { object, .. } => {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id).map(|i| {
                                                    if let Some(ref _class_name) = i.class_name {
                                                        false // Class instances have known field types
                                                    } else {
                                                        !i.is_array && !i.is_string && !i.is_map && !i.is_set
                                                    }
                                                }).unwrap_or(true)
                                            } else {
                                                true
                                            }
                                        }
                                        _ => false,
                                    }
                                }

                                // Helper to check if an expression is an array
                                fn is_array_expr_for_multi(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                    match expr {
                                        Expr::Array(_) | Expr::ArraySpread(_) | Expr::ProcessArgv => true,
                                        Expr::ArrayMap { .. } | Expr::ArrayFilter { .. } | Expr::ArraySlice { .. } | Expr::ArraySplice { .. } => true,
                                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_array).unwrap_or(false),
                                        // Check for chained array method calls (e.g., arr.filter().map())
                                        Expr::Call { callee, .. } => {
                                            if let Expr::PropertyGet { object, property } = callee.as_ref() {
                                                if property == "slice" {
                                                    // slice could be array or string method - check the object
                                                    if let Expr::LocalGet(id) = object.as_ref() {
                                                        return locals.get(id).map(|i| i.is_array).unwrap_or(false);
                                                    }
                                                    return false; // Unknown object, don't assume array
                                                }
                                                property == "map" || property == "filter" ||
                                                property == "concat" || property == "flat" || property == "flatMap" ||
                                                property == "reverse" || property == "sort" || property == "toSorted" ||
                                                property == "toReversed" || property == "with"
                                            } else {
                                                false
                                            }
                                        }
                                        _ => false,
                                    }
                                }

                                // Allocate a runtime array
                                let alloc_func = extern_funcs.get("js_array_alloc")
                                    .ok_or_else(|| anyhow!("js_array_alloc not declared"))?;
                                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                                let capacity = builder.ins().iconst(types::I32, (args.len() + 4) as i64);
                                let alloc_call = builder.ins().call(alloc_ref, &[capacity]);
                                let initial_arr_ptr = builder.inst_results(alloc_call)[0];

                                let arr_var = Variable::new(next_temp_var_id());
                                builder.declare_var(arr_var, types::I64);
                                builder.def_var(arr_var, initial_arr_ptr);

                                let push_func = extern_funcs.get("js_array_push_f64")
                                    .ok_or_else(|| anyhow!("js_array_push_f64 not declared"))?;
                                let push_ref = module.declare_func_in_func(*push_func, builder.func);

                                let nanbox_string_func = extern_funcs.get("js_nanbox_string")
                                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                let nanbox_string_ref = module.declare_func_in_func(*nanbox_string_func, builder.func);

                                let nanbox_pointer_func = extern_funcs.get("js_nanbox_pointer")
                                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                let nanbox_pointer_ref = module.declare_func_in_func(*nanbox_pointer_func, builder.func);

                                // Process each argument
                                for (i, arg) in args.iter().enumerate() {
                                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;

                                    // Determine how to encode this value for the spread array
                                    let val_f64 = if is_string_expr_for_multi(arg, locals) {
                                        // Raw string - needs NaN-boxing
                                        // The value might be i64 (from closure params) or f64 (from string literals)
                                        let ptr = ensure_i64(builder, val);
                                        let call = builder.ins().call(nanbox_string_ref, &[ptr]);
                                        builder.inst_results(call)[0]
                                    } else if is_array_expr_for_multi(arg, locals) {
                                        // Array - needs NaN-boxing as pointer
                                        let ptr = ensure_i64(builder, val);
                                        let call = builder.ins().call(nanbox_pointer_ref, &[ptr]);
                                        builder.inst_results(call)[0]
                                    } else if is_union_expr_for_multi(arg, locals) {
                                        // Union type - already NaN-boxed (for conditionals) or needs dynamic handling
                                        ensure_f64(builder, val)
                                    } else {
                                        // Numbers and other values
                                        ensure_f64(builder, val)
                                    };

                                    let arr_ptr = builder.use_var(arr_var);
                                    let push_call = builder.ins().call(push_ref, &[arr_ptr, val_f64]);
                                    let new_arr_ptr = builder.inst_results(push_call)[0];
                                    builder.def_var(arr_var, new_arr_ptr);
                                }

                                // Call js_console_log_spread with the built array
                                let spread_ref = module.declare_func_in_func(*spread_func, builder.func);
                                let final_arr_ptr = builder.use_var(arr_var);
                                builder.ins().call(spread_ref, &[final_arr_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        }

                        // Handle console.log() with no arguments - just output a newline
                        if args.is_empty() {
                            // Use js_console_log_newline if available, otherwise do nothing
                            if let Some(func_id) = extern_funcs.get("js_console_log_newline") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                builder.ins().call(func_ref, &[]);
                            }
                            return Ok(builder.ins().f64const(0.0));
                        }

                        // Check if the argument is a string
                        let is_string_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::String(_) => true,
                                Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                                Expr::FsReadFileSync(_) => true,
                                Expr::JsonStringify(_) => true,
                                Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                                // All crypto operations return strings (hex or UUID format)
                                Expr::CryptoRandomBytes(_) | Expr::CryptoRandomUUID |
                                Expr::CryptoSha256(_) | Expr::CryptoMd5(_) => true,
                                // Date.toISOString() returns a string
                                Expr::DateToISOString(_) => true,
                                // OS operations that return strings
                                Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                                Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                                // typeof always returns a string
                                Expr::TypeOf(_) => true,
                                // URLSearchParams methods that return strings
                                Expr::UrlSearchParamsToString(_) => true,
                                Expr::UrlSearchParamsGet { .. } => true,
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                // String-returning native methods
                                Expr::NativeMethodCall { module, method, .. } => {
                                    (module == "uuid" && (method == "v4" || method == "v1" || method == "v7"))
                                    || (module == "bcrypt" && method == "hashSync")
                                    || (module == "crypto" && (method == "sha256" || method == "md5" || method == "randomBytes" || method == "randomUUID" || method == "hmacSha256"))
                                    || (module == "zlib" && (method == "gzipSync" || method == "gunzipSync" || method == "deflateSync" || method == "inflateSync"))
                                    || (module == "ws" && method == "receive")
                                    || (module == "node-fetch" && method == "statusText")
                                    || (module == "ethers" && (method == "formatUnits" || method == "getAddress" || method == "formatEther"))
                                }
                                // Binary Add with string operands (from template literals)
                                Expr::Binary { op: BinaryOp::Add, left, right } => {
                                    fn is_string_in_binary(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                        match expr {
                                            Expr::String(_) => true,
                                            Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                            Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) | Expr::JsonStringify(_) |
                                            Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                            Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                                            Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                                            Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                                            Expr::Binary { op: BinaryOp::Add, left, right } => {
                                                is_string_in_binary(left, locals) || is_string_in_binary(right, locals)
                                            }
                                            _ => false,
                                        }
                                    }
                                    is_string_in_binary(left, locals) || is_string_in_binary(right, locals)
                                }
                                // String method calls (slice, substring, trim, toLowerCase, toUpperCase, etc.)
                                // Also check class method return types for generic classes
                                Expr::Call { callee, .. } => {
                                    if let Expr::PropertyGet { object, property: method_name } = callee.as_ref() {
                                        // Check for string methods first - these always return strings
                                        if method_name == "slice" || method_name == "substring" || method_name == "trim"
                                            || method_name == "toLowerCase" || method_name == "toUpperCase" || method_name == "replace"
                                            || method_name == "padStart" || method_name == "padEnd" || method_name == "repeat" || method_name == "charAt" {
                                            // String methods always return strings, regardless of what the object is
                                            // This handles cases like query.queryText.substring(0, 20)
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id).map(|i| i.is_string).unwrap_or(true)
                                            } else {
                                                // Non-LocalGet objects (like PropertyGet chains) - assume it's a string method
                                                true
                                            }
                                        // Check for buffer.toString() which returns a string
                                        } else if method_name == "toString" {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id).map(|i| i.is_buffer).unwrap_or(false)
                                            } else {
                                                false
                                            }
                                        } else {
                                            // Check if this is a method call on a class instance that returns String
                                            // For generic classes, we need to substitute type parameters with actual type arguments
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                if let Some(info) = locals.get(id) {
                                                    if let Some(class_name) = &info.class_name {
                                                        if let Some(class_meta) = classes.get(class_name) {
                                                            if let Some(return_type) = class_meta.method_return_types.get(method_name.as_str()) {
                                                                // Check if return_type is a type parameter that resolves to String
                                                                let actual_type = match return_type {
                                                                    perry_types::Type::TypeVar(name) => {
                                                                        // Find the index of this type parameter in the class
                                                                        class_meta.type_params.iter().position(|p| p == name)
                                                                            .and_then(|idx| info.type_args.get(idx))
                                                                            .cloned()
                                                                            .unwrap_or_else(|| return_type.clone())
                                                                    }
                                                                    _ => return_type.clone()
                                                                };
                                                                matches!(actual_type, perry_types::Type::String)
                                                            } else { false }
                                                        } else { false }
                                                    } else { false }
                                                } else { false }
                                            } else {
                                                false
                                            }
                                        }
                                    } else {
                                        false
                                    }
                                }
                                // Property access on class instances - check if field type is String
                                Expr::PropertyGet { object, property } => {
                                    if let Expr::LocalGet(id) = object.as_ref() {
                                        if let Some(info) = locals.get(id) {
                                            if let Some(class_name) = &info.class_name {
                                                if let Some(class_meta) = classes.get(class_name) {
                                                    if let Some(field_type) = class_meta.field_types.get(property.as_str()) {
                                                        matches!(field_type, perry_types::Type::String)
                                                    } else { false }
                                                } else { false }
                                            } else { false }
                                        } else { false }
                                    } else {
                                        false
                                    }
                                }
                                _ => false,
                            }
                        } else {
                            false
                        };

                        // Check if the argument is a BigInt
                        let is_bigint_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::BigInt(_) => true,
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_bigint).unwrap_or(false),
                                _ => false,
                            }
                        } else {
                            false
                        };

                        // Check if the argument is an array
                        let is_array_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::Array(_) | Expr::ArraySpread(_) | Expr::ProcessArgv => true,
                                Expr::ArrayMap { .. } | Expr::ArrayFilter { .. } | Expr::ArraySlice { .. } | Expr::ArraySplice { .. } => true,
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_array).unwrap_or(false),
                                _ => false,
                            }
                        } else {
                            false
                        };

                        // Check if the argument is a union type (requires dynamic printing)
                        // This includes: union-typed variables, mixed-type array element access, and
                        // property access on generic objects (not class instances with known types)
                        let is_union_arg = if let Some(arg) = args.first() {
                            match arg {
                                // Boolean literals need dynamic printing (NaN-boxed)
                                Expr::Bool(_) => true,
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_union).unwrap_or(false),
                                // Mixed-type array element access returns a union-like value
                                Expr::IndexGet { object, .. } => {
                                    if let Expr::LocalGet(arr_id) = object.as_ref() {
                                        locals.get(arr_id).map(|i| i.is_mixed_array).unwrap_or(false)
                                    } else {
                                        false
                                    }
                                }
                                // PropertyGet on generic objects (non-class) returns dynamic values
                                Expr::PropertyGet { object, .. } => {
                                    if let Expr::LocalGet(id) = object.as_ref() {
                                        // If the class name exists AND we have a class definition, field types are known
                                        // Otherwise (no class name, or interface type without class definition) needs dynamic printing
                                        locals.get(id).map(|i| {
                                            if let Some(ref class_name) = i.class_name {
                                                // Check if we have an actual class definition
                                                !classes.contains_key(class_name)
                                            } else {
                                                // No class name - generic object
                                                !i.is_array && !i.is_string && !i.is_map && !i.is_set
                                            }
                                        }).unwrap_or(true)
                                    } else {
                                        // Unknown object - use dynamic printing
                                        true
                                    }
                                }
                                // Conditional (ternary) expressions can return different types
                                Expr::Conditional { .. } => true,
                                _ => false,
                            }
                        } else {
                            false
                        };

                        // Prioritize string path when explicitly detected as string
                        // (is_union_arg can be set for Any-typed variables, but if is_string is true in LocalInfo, use string path)
                        if is_union_arg && !is_string_arg {
                            // Use js_console_log_dynamic for union type arguments
                            if let Some(func_id) = extern_funcs.get("js_console_log_dynamic") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Ensure arg is f64 (might be i64 pointer)
                                let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                builder.ins().call(func_ref, &[arg_f64]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else if is_string_arg {
                            // Use js_string_print for string arguments
                            if let Some(func_id) = extern_funcs.get("js_string_print") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Extract string pointer - handles both NaN-boxed and raw pointer strings
                                let str_ptr = if builder.func.dfg.value_type(arg_vals[0]) == types::I64 {
                                    arg_vals[0]
                                } else {
                                    // Use js_get_string_pointer_unified to handle both NaN-boxed and raw pointer strings
                                    let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                        .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                    let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                    let val_f64 = ensure_f64(builder, arg_vals[0]);
                                    let call = builder.ins().call(get_str_ptr_ref, &[val_f64]);
                                    builder.inst_results(call)[0]
                                };
                                builder.ins().call(func_ref, &[str_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else if is_bigint_arg {
                            // Use js_bigint_print for BigInt arguments
                            if let Some(func_id) = extern_funcs.get("js_bigint_print") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Convert f64-bitcasted pointer back to i64 (only if not already i64)
                                let bigint_ptr = if builder.func.dfg.value_type(arg_vals[0]) == types::I64 {
                                    arg_vals[0]
                                } else {
                                    builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0])
                                };
                                builder.ins().call(func_ref, &[bigint_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else if is_array_arg {
                            // Use js_array_print for array arguments
                            if let Some(func_id) = extern_funcs.get("js_array_print") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Convert f64-bitcasted pointer back to i64 (only if not already i64)
                                let arr_ptr = if builder.func.dfg.value_type(arg_vals[0]) == types::I64 {
                                    arg_vals[0]
                                } else {
                                    builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0])
                                };
                                builder.ins().call(func_ref, &[arr_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else {
                            // Check if the value is i64 - could be a string/pointer from function call
                            // In that case, use js_string_print instead of js_console_log_number
                            let val_type = builder.func.dfg.value_type(arg_vals[0]);
                            if val_type == types::I64 {
                                // Value is i64 (pointer type), use js_string_print
                                if let Some(func_id) = extern_funcs.get("js_string_print") {
                                    let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                    builder.ins().call(func_ref, &[arg_vals[0]]);
                                    return Ok(builder.ins().f64const(0.0));
                                }
                            } else {
                                // Use js_console_log_number for numeric arguments
                                // Note: js_console_log_number takes a single f64, so log each value separately
                                if let Some(func_id) = extern_funcs.get("js_console_log_number") {
                                    let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                    for val in &arg_vals {
                                        let val_f64 = ensure_f64(builder, *val);
                                        builder.ins().call(func_ref, &[val_f64]);
                                    }
                                    return Ok(builder.ins().f64const(0.0));
                                }
                            }
                        }
                        return Err(anyhow!("console.log not available"));
                    }

                    // Handle console.error (same logic as console.log but writes to stderr)
                    if property == "error" {
                        // Handle multiple arguments by building an array and using spread
                        if args.len() > 1 {
                            if let Some(spread_func) = extern_funcs.get("js_console_error_spread") {
                                // Reuse the same helper functions from console.log
                                fn is_string_expr_for_error(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                    match expr {
                                        Expr::String(_) => true,
                                        Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) => true,
                                        Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                        Expr::PathExtname(_) | Expr::PathResolve(_) | Expr::JsonStringify(_) => true,
                                        Expr::CryptoRandomBytes(_) | Expr::CryptoRandomUUID |
                                        Expr::CryptoSha256(_) | Expr::CryptoMd5(_) => true,
                                        Expr::DateToISOString(_) => true,
                                        Expr::TypeOf(_) => true,
                                        Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                                        Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                        Expr::Binary { op: BinaryOp::Add, left, right } => {
                                            is_string_expr_for_error(left, locals) || is_string_expr_for_error(right, locals)
                                        }
                                        Expr::Call { callee, .. } => {
                                            if let Expr::PropertyGet { object, property } = callee.as_ref() {
                                                if property == "slice" || property == "substring" || property == "trim"
                                                    || property == "toLowerCase" || property == "toUpperCase"
                                                    || property == "charAt" || property == "padStart" || property == "padEnd"
                                                    || property == "repeat" || property == "replace" {
                                                    if let Expr::LocalGet(id) = object.as_ref() {
                                                        return locals.get(id).map(|i| i.is_string).unwrap_or(false);
                                                    }
                                                }
                                            }
                                            false
                                        }
                                        _ => false,
                                    }
                                }

                                fn is_union_expr_for_error(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                    match expr {
                                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_union).unwrap_or(false),
                                        Expr::Conditional { .. } => true,
                                        Expr::PropertyGet { object, .. } => {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id).map(|i| {
                                                    if let Some(ref _class_name) = i.class_name {
                                                        false
                                                    } else {
                                                        !i.is_array && !i.is_string && !i.is_map && !i.is_set
                                                    }
                                                }).unwrap_or(true)
                                            } else {
                                                true
                                            }
                                        }
                                        _ => false,
                                    }
                                }

                                fn is_array_expr_for_error(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                    match expr {
                                        Expr::Array(_) | Expr::ArraySpread(_) | Expr::ProcessArgv => true,
                                        Expr::ArrayMap { .. } | Expr::ArrayFilter { .. } | Expr::ArraySlice { .. } | Expr::ArraySplice { .. } => true,
                                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_array).unwrap_or(false),
                                        Expr::Call { callee, .. } => {
                                            if let Expr::PropertyGet { object, property } = callee.as_ref() {
                                                if property == "slice" {
                                                    if let Expr::LocalGet(id) = object.as_ref() {
                                                        return locals.get(id).map(|i| i.is_array).unwrap_or(false);
                                                    }
                                                    return false;
                                                }
                                                property == "map" || property == "filter" ||
                                                property == "concat" || property == "flat" || property == "flatMap" ||
                                                property == "reverse" || property == "sort" || property == "toSorted" ||
                                                property == "toReversed" || property == "with"
                                            } else {
                                                false
                                            }
                                        }
                                        _ => false,
                                    }
                                }

                                // Allocate a runtime array
                                let alloc_func = extern_funcs.get("js_array_alloc")
                                    .ok_or_else(|| anyhow!("js_array_alloc not declared"))?;
                                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                                let capacity = builder.ins().iconst(types::I32, (args.len() + 4) as i64);
                                let alloc_call = builder.ins().call(alloc_ref, &[capacity]);
                                let initial_arr_ptr = builder.inst_results(alloc_call)[0];

                                let arr_var = Variable::new(next_temp_var_id());
                                builder.declare_var(arr_var, types::I64);
                                builder.def_var(arr_var, initial_arr_ptr);

                                let push_func = extern_funcs.get("js_array_push_f64")
                                    .ok_or_else(|| anyhow!("js_array_push_f64 not declared"))?;
                                let push_ref = module.declare_func_in_func(*push_func, builder.func);

                                let nanbox_string_func = extern_funcs.get("js_nanbox_string")
                                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                let nanbox_string_ref = module.declare_func_in_func(*nanbox_string_func, builder.func);

                                let nanbox_pointer_func = extern_funcs.get("js_nanbox_pointer")
                                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                let nanbox_pointer_ref = module.declare_func_in_func(*nanbox_pointer_func, builder.func);

                                // Process each argument
                                for (i, arg) in args.iter().enumerate() {
                                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;

                                    let val_f64 = if is_string_expr_for_error(arg, locals) {
                                        let ptr = ensure_i64(builder, val);
                                        let call = builder.ins().call(nanbox_string_ref, &[ptr]);
                                        builder.inst_results(call)[0]
                                    } else if is_array_expr_for_error(arg, locals) {
                                        let ptr = ensure_i64(builder, val);
                                        let call = builder.ins().call(nanbox_pointer_ref, &[ptr]);
                                        builder.inst_results(call)[0]
                                    } else if is_union_expr_for_error(arg, locals) {
                                        ensure_f64(builder, val)
                                    } else {
                                        ensure_f64(builder, val)
                                    };

                                    let arr_ptr = builder.use_var(arr_var);
                                    let push_call = builder.ins().call(push_ref, &[arr_ptr, val_f64]);
                                    let new_arr_ptr = builder.inst_results(push_call)[0];
                                    builder.def_var(arr_var, new_arr_ptr);
                                }

                                // Call js_console_error_spread with the built array
                                let spread_ref = module.declare_func_in_func(*spread_func, builder.func);
                                let final_arr_ptr = builder.use_var(arr_var);
                                builder.ins().call(spread_ref, &[final_arr_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        }

                        // Check if the argument is a string
                        let is_string_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::String(_) => true,
                                Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                                Expr::FsReadFileSync(_) => true,
                                Expr::JsonStringify(_) => true,
                                Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                                Expr::CryptoRandomBytes(_) | Expr::CryptoRandomUUID |
                                Expr::CryptoSha256(_) | Expr::CryptoMd5(_) => true,
                                Expr::DateToISOString(_) => true,
                                Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                                Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                                Expr::TypeOf(_) => true,
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                Expr::NativeMethodCall { module, method, .. } => {
                                    (module == "uuid" && (method == "v4" || method == "v1" || method == "v7"))
                                    || (module == "bcrypt" && method == "hashSync")
                                    || (module == "crypto" && (method == "sha256" || method == "md5" || method == "randomBytes" || method == "randomUUID" || method == "hmacSha256"))
                                    || (module == "zlib" && (method == "gzipSync" || method == "gunzipSync" || method == "deflateSync" || method == "inflateSync"))
                                    || (module == "ws" && method == "receive")
                                    || (module == "node-fetch" && method == "statusText")
                                    || (module == "ethers" && (method == "formatUnits" || method == "getAddress" || method == "formatEther"))
                                }
                                Expr::Binary { op: BinaryOp::Add, left, right } => {
                                    fn is_string_in_binary(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                        match expr {
                                            Expr::String(_) => true,
                                            Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                            Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) | Expr::JsonStringify(_) |
                                            Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                            Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                                            Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                                            Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                                            Expr::Binary { op: BinaryOp::Add, left, right } => {
                                                is_string_in_binary(left, locals) || is_string_in_binary(right, locals)
                                            }
                                            _ => false,
                                        }
                                    }
                                    is_string_in_binary(left, locals) || is_string_in_binary(right, locals)
                                }
                                Expr::Call { callee, .. } => {
                                    if let Expr::PropertyGet { object, property: method_name } = callee.as_ref() {
                                        if method_name == "slice" || method_name == "substring" || method_name == "trim"
                                            || method_name == "toLowerCase" || method_name == "toUpperCase" || method_name == "replace" {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id).map(|i| i.is_string).unwrap_or(false)
                                            } else {
                                                false
                                            }
                                        } else if method_name == "toString" {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id).map(|i| i.is_buffer).unwrap_or(false)
                                            } else {
                                                false
                                            }
                                        } else {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id)
                                                    .and_then(|info| info.class_name.as_ref())
                                                    .and_then(|class_name| classes.get(class_name))
                                                    .and_then(|class_meta| class_meta.method_return_types.get(method_name.as_str()))
                                                    .map(|return_type| matches!(return_type, perry_types::Type::String))
                                                    .unwrap_or(false)
                                            } else {
                                                false
                                            }
                                        }
                                    } else {
                                        false
                                    }
                                }
                                _ => false,
                            }
                        } else {
                            false
                        };

                        let is_bigint_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::BigInt(_) => true,
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_bigint).unwrap_or(false),
                                _ => false,
                            }
                        } else {
                            false
                        };

                        let is_union_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_union).unwrap_or(false),
                                Expr::IndexGet { object, .. } => {
                                    if let Expr::LocalGet(arr_id) = object.as_ref() {
                                        locals.get(arr_id).map(|i| i.is_mixed_array).unwrap_or(false)
                                    } else {
                                        false
                                    }
                                }
                                Expr::PropertyGet { object, .. } => {
                                    if let Expr::LocalGet(id) = object.as_ref() {
                                        locals.get(id).map(|i| i.class_name.is_none() && !i.is_array && !i.is_string && !i.is_map && !i.is_set).unwrap_or(true)
                                    } else {
                                        true
                                    }
                                }
                                Expr::Conditional { .. } => true,
                                _ => false,
                            }
                        } else {
                            false
                        };

                        if is_union_arg {
                            if let Some(func_id) = extern_funcs.get("js_console_error_dynamic") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Ensure arg is f64 (might be i64 pointer)
                                let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                builder.ins().call(func_ref, &[arg_f64]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else if is_string_arg {
                            if let Some(func_id) = extern_funcs.get("js_string_error") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Extract string pointer - handles both NaN-boxed and raw pointer strings
                                let str_ptr = if builder.func.dfg.value_type(arg_vals[0]) == types::I64 {
                                    arg_vals[0]
                                } else {
                                    // Use js_get_string_pointer_unified to handle both NaN-boxed and raw pointer strings
                                    let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                        .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                    let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                    let val_f64 = ensure_f64(builder, arg_vals[0]);
                                    let call = builder.ins().call(get_str_ptr_ref, &[val_f64]);
                                    builder.inst_results(call)[0]
                                };
                                builder.ins().call(func_ref, &[str_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else if is_bigint_arg {
                            if let Some(func_id) = extern_funcs.get("js_bigint_error") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                let bigint_ptr = if builder.func.dfg.value_type(arg_vals[0]) == types::I64 {
                                    arg_vals[0]
                                } else {
                                    builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0])
                                };
                                builder.ins().call(func_ref, &[bigint_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else {
                            // Check if the value is i64 - could be a string/pointer from function call
                            let val_type = builder.func.dfg.value_type(arg_vals[0]);
                            if val_type == types::I64 {
                                // Value is i64 (pointer type), use js_string_print_stderr
                                if let Some(func_id) = extern_funcs.get("js_string_print_stderr") {
                                    let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                    builder.ins().call(func_ref, &[arg_vals[0]]);
                                    return Ok(builder.ins().f64const(0.0));
                                }
                            } else {
                                // Note: js_console_error_number takes a single f64, so log each value separately
                                if let Some(func_id) = extern_funcs.get("js_console_error_number") {
                                    let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                    for val in &arg_vals {
                                        let val_f64 = ensure_f64(builder, *val);
                                        builder.ins().call(func_ref, &[val_f64]);
                                    }
                                    return Ok(builder.ins().f64const(0.0));
                                }
                            }
                        }
                        return Err(anyhow!("console.error not available"));
                    }

                    // Handle console.warn (same logic as console.log but writes to stderr)
                    if property == "warn" {
                        // Check if the argument is a string
                        let is_string_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::String(_) => true,
                                Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                                Expr::FsReadFileSync(_) => true,
                                Expr::JsonStringify(_) => true,
                                Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                                Expr::CryptoRandomBytes(_) | Expr::CryptoRandomUUID |
                                Expr::CryptoSha256(_) | Expr::CryptoMd5(_) => true,
                                Expr::DateToISOString(_) => true,
                                Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                                Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                                Expr::TypeOf(_) => true,
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                Expr::NativeMethodCall { module, method, .. } => {
                                    (module == "uuid" && (method == "v4" || method == "v1" || method == "v7"))
                                    || (module == "bcrypt" && method == "hashSync")
                                    || (module == "crypto" && (method == "sha256" || method == "md5" || method == "randomBytes" || method == "randomUUID" || method == "hmacSha256"))
                                    || (module == "zlib" && (method == "gzipSync" || method == "gunzipSync" || method == "deflateSync" || method == "inflateSync"))
                                    || (module == "ws" && method == "receive")
                                    || (module == "node-fetch" && method == "statusText")
                                    || (module == "ethers" && (method == "formatUnits" || method == "getAddress" || method == "formatEther"))
                                }
                                Expr::Binary { op: BinaryOp::Add, left, right } => {
                                    fn is_string_in_binary(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                        match expr {
                                            Expr::String(_) => true,
                                            Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                            Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) | Expr::JsonStringify(_) |
                                            Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                            Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                                            Expr::OsPlatform | Expr::OsArch | Expr::OsHostname | Expr::OsHomedir |
                                            Expr::OsTmpdir | Expr::OsType | Expr::OsRelease | Expr::OsEOL => true,
                                            Expr::Binary { op: BinaryOp::Add, left, right } => {
                                                is_string_in_binary(left, locals) || is_string_in_binary(right, locals)
                                            }
                                            _ => false,
                                        }
                                    }
                                    is_string_in_binary(left, locals) || is_string_in_binary(right, locals)
                                }
                                Expr::Call { callee, .. } => {
                                    if let Expr::PropertyGet { object, property: method_name } = callee.as_ref() {
                                        if method_name == "slice" || method_name == "substring" || method_name == "trim"
                                            || method_name == "toLowerCase" || method_name == "toUpperCase" || method_name == "replace" {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id).map(|i| i.is_string).unwrap_or(false)
                                            } else {
                                                false
                                            }
                                        } else if method_name == "toString" {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id).map(|i| i.is_buffer).unwrap_or(false)
                                            } else {
                                                false
                                            }
                                        } else {
                                            if let Expr::LocalGet(id) = object.as_ref() {
                                                locals.get(id)
                                                    .and_then(|info| info.class_name.as_ref())
                                                    .and_then(|class_name| classes.get(class_name))
                                                    .and_then(|class_meta| class_meta.method_return_types.get(method_name.as_str()))
                                                    .map(|return_type| matches!(return_type, perry_types::Type::String))
                                                    .unwrap_or(false)
                                            } else {
                                                false
                                            }
                                        }
                                    } else {
                                        false
                                    }
                                }
                                _ => false,
                            }
                        } else {
                            false
                        };

                        let is_bigint_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::BigInt(_) => true,
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_bigint).unwrap_or(false),
                                _ => false,
                            }
                        } else {
                            false
                        };

                        let is_union_arg = if let Some(arg) = args.first() {
                            match arg {
                                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_union).unwrap_or(false),
                                Expr::IndexGet { object, .. } => {
                                    if let Expr::LocalGet(arr_id) = object.as_ref() {
                                        locals.get(arr_id).map(|i| i.is_mixed_array).unwrap_or(false)
                                    } else {
                                        false
                                    }
                                }
                                Expr::PropertyGet { object, .. } => {
                                    if let Expr::LocalGet(id) = object.as_ref() {
                                        locals.get(id).map(|i| i.class_name.is_none() && !i.is_array && !i.is_string && !i.is_map && !i.is_set).unwrap_or(true)
                                    } else {
                                        true
                                    }
                                }
                                Expr::Conditional { .. } => true,
                                _ => false,
                            }
                        } else {
                            false
                        };

                        if is_union_arg {
                            if let Some(func_id) = extern_funcs.get("js_console_warn_dynamic") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Ensure arg is f64 (might be i64 pointer)
                                let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                builder.ins().call(func_ref, &[arg_f64]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else if is_string_arg {
                            if let Some(func_id) = extern_funcs.get("js_string_warn") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Extract string pointer - handles both NaN-boxed and raw pointer strings
                                let str_ptr = if builder.func.dfg.value_type(arg_vals[0]) == types::I64 {
                                    arg_vals[0]
                                } else {
                                    // Use js_get_string_pointer_unified to handle both NaN-boxed and raw pointer strings
                                    let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                        .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                    let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                    let val_f64 = ensure_f64(builder, arg_vals[0]);
                                    let call = builder.ins().call(get_str_ptr_ref, &[val_f64]);
                                    builder.inst_results(call)[0]
                                };
                                builder.ins().call(func_ref, &[str_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else if is_bigint_arg {
                            if let Some(func_id) = extern_funcs.get("js_bigint_warn") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                let bigint_ptr = if builder.func.dfg.value_type(arg_vals[0]) == types::I64 {
                                    arg_vals[0]
                                } else {
                                    builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0])
                                };
                                builder.ins().call(func_ref, &[bigint_ptr]);
                                return Ok(builder.ins().f64const(0.0));
                            }
                        } else {
                            // Check if the value is i64 - could be a string/pointer from function call
                            let val_type = builder.func.dfg.value_type(arg_vals[0]);
                            if val_type == types::I64 {
                                // Value is i64 (pointer type), use js_string_warn
                                if let Some(func_id) = extern_funcs.get("js_string_warn") {
                                    let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                    builder.ins().call(func_ref, &[arg_vals[0]]);
                                    return Ok(builder.ins().f64const(0.0));
                                }
                            } else {
                                // Note: js_console_warn_number takes a single f64, so log each value separately
                                if let Some(func_id) = extern_funcs.get("js_console_warn_number") {
                                    let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                    for val in &arg_vals {
                                        let val_f64 = ensure_f64(builder, *val);
                                        builder.ins().call(func_ref, &[val_f64]);
                                    }
                                    return Ok(builder.ins().f64const(0.0));
                                }
                            }
                        }
                        return Err(anyhow!("console.warn not available"));
                    }

                    // Handle process.exit(code)
                    if property == "exit" {
                        if let Expr::GlobalGet(_) = object.as_ref() {
                            if let Some(func_id) = extern_funcs.get("js_process_exit") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                let code = if arg_vals.is_empty() {
                                    builder.ins().f64const(0.0) // Default exit code is 0
                                } else {
                                    arg_vals[0]
                                };
                                builder.ins().call(func_ref, &[code]);
                                // process.exit never returns, but we need to return something
                                return Ok(builder.ins().f64const(0.0));
                            }
                        }
                    }

                    // Handle Promise.resolve()
                    if property == "resolve" {
                        // Check if object is a global (Promise)
                        if let Expr::GlobalGet(_) = object.as_ref() {
                            // Assume it's Promise.resolve(value)
                            if let Some(func_id) = extern_funcs.get("js_promise_resolved") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                let value = if arg_vals.is_empty() {
                                    const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                                    builder.ins().f64const(f64::from_bits(TAG_UNDEFINED)) // undefined
                                } else {
                                    let arg_val = arg_vals[0];
                                    let arg_type = builder.func.dfg.value_type(arg_val);
                                    if arg_type == types::I64 {
                                        // Pointer value (array/object/string) - NaN-box it
                                        let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                            .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let call = builder.ins().call(nanbox_ref, &[arg_val]);
                                        builder.inst_results(call)[0]
                                    } else {
                                        // Already f64 (number)
                                        arg_val
                                    }
                                };
                                let call = builder.ins().call(func_ref, &[value]);
                                let promise_ptr = builder.inst_results(call)[0];
                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), promise_ptr));
                            }
                        }
                    }

                    // Handle Promise.reject()
                    if property == "reject" {
                        // Check if object is a global (Promise)
                        if let Expr::GlobalGet(_) = object.as_ref() {
                            // Assume it's Promise.reject(reason)
                            if let Some(func_id) = extern_funcs.get("js_promise_rejected") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                let reason = if arg_vals.is_empty() {
                                    const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                                    builder.ins().f64const(f64::from_bits(TAG_UNDEFINED)) // undefined
                                } else {
                                    let arg_val = arg_vals[0];
                                    let arg_type = builder.func.dfg.value_type(arg_val);
                                    if arg_type == types::I64 {
                                        // Pointer value (array/object/string) - NaN-box it
                                        let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                            .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let call = builder.ins().call(nanbox_ref, &[arg_val]);
                                        builder.inst_results(call)[0]
                                    } else {
                                        // Already f64 (number)
                                        arg_val
                                    }
                                };
                                let call = builder.ins().call(func_ref, &[reason]);
                                let promise_ptr = builder.inst_results(call)[0];
                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), promise_ptr));
                            }
                        }
                    }

                    // Handle Promise.all(array)
                    if property == "all" {
                        // Check if object is a global (Promise)
                        if let Expr::GlobalGet(_) = object.as_ref() {
                            // Promise.all(promises_array)
                            if let Some(func_id) = extern_funcs.get("js_promise_all") {
                                let func_ref = module.declare_func_in_func(*func_id, builder.func);
                                // Get the array argument
                                let arr_ptr = if arg_vals.is_empty() {
                                    // No argument - use null (will return empty array promise)
                                    builder.ins().iconst(types::I64, 0)
                                } else {
                                    // Extract the array pointer from the argument
                                    let arg_val = arg_vals[0];
                                    ensure_i64(builder, arg_val)
                                };
                                let call = builder.ins().call(func_ref, &[arr_ptr]);
                                let promise_ptr = builder.inst_results(call)[0];
                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), promise_ptr));
                            }
                        }
                    }

                    // Handle Promise.delayed(value) - creates a pending promise that resolves on next microtask
                    if property == "delayed" {
                        if let Expr::GlobalGet(_) = object.as_ref() {
                            let new_func = extern_funcs.get("js_promise_new")
                                .ok_or_else(|| anyhow!("js_promise_new not found"))?;
                            let schedule_func = extern_funcs.get("js_promise_schedule_resolve")
                                .ok_or_else(|| anyhow!("js_promise_schedule_resolve not found"))?;

                            // Create new pending promise
                            let new_ref = module.declare_func_in_func(*new_func, builder.func);
                            let call = builder.ins().call(new_ref, &[]);
                            let promise_ptr = builder.inst_results(call)[0];

                            // Schedule it to resolve with the given value
                            let schedule_ref = module.declare_func_in_func(*schedule_func, builder.func);
                            let value = if arg_vals.is_empty() {
                                builder.ins().f64const(0.0)
                            } else {
                                let arg_val = arg_vals[0];
                                let arg_type = builder.func.dfg.value_type(arg_val);
                                if arg_type == types::I64 {
                                    // Pointer value (array/object/string) - NaN-box it
                                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                        .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                    let call = builder.ins().call(nanbox_ref, &[arg_val]);
                                    builder.inst_results(call)[0]
                                } else {
                                    // Already f64 (number)
                                    arg_val
                                }
                            };
                            builder.ins().call(schedule_ref, &[promise_ptr, value]);

                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), promise_ptr));
                        }
                    }

                    // Handle string methods: slice, indexOf, split
                    if let Expr::LocalGet(id) = object.as_ref() {
                        if let Some(info) = locals.get(id) {
                            if info.is_string {
                                let str_val = builder.use_var(info.var);
                                // Extract string pointer using unified function that handles both:
                                // - Properly NaN-boxed strings (from mysql2, etc.)
                                // - Raw pointers bitcast to f64 (for locally-created strings)
                                let str_ptr = if builder.func.dfg.value_type(str_val) == types::F64 {
                                    let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                        .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                    let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                    let call = builder.ins().call(get_str_ptr_ref, &[str_val]);
                                    builder.inst_results(call)[0]
                                } else {
                                    // Already i64 - use directly
                                    str_val
                                };

                                match property.as_str() {
                                    "slice" => {
                                        // str.slice(start, end)
                                        let slice_func = extern_funcs.get("js_string_slice")
                                            .ok_or_else(|| anyhow!("js_string_slice not declared"))?;
                                        let func_ref = module.declare_func_in_func(*slice_func, builder.func);

                                        let start = if arg_vals.len() > 0 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        let end = if arg_vals.len() > 1 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            // Use a large value to mean "to end"
                                            builder.ins().iconst(types::I32, i32::MAX as i64)
                                        };

                                        let call = builder.ins().call(func_ref, &[str_ptr, start, end]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "substring" => {
                                        // str.substring(start, end) - similar to slice but different edge case behavior
                                        let substring_func = extern_funcs.get("js_string_substring")
                                            .ok_or_else(|| anyhow!("js_string_substring not declared"))?;
                                        let func_ref = module.declare_func_in_func(*substring_func, builder.func);

                                        let start = if arg_vals.len() > 0 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        let end = if arg_vals.len() > 1 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            // Use a large value to mean "to end"
                                            builder.ins().iconst(types::I32, i32::MAX as i64)
                                        };

                                        let call = builder.ins().call(func_ref, &[str_ptr, start, end]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "trim" => {
                                        // str.trim() - remove whitespace from both ends
                                        let trim_func = extern_funcs.get("js_string_trim")
                                            .ok_or_else(|| anyhow!("js_string_trim not declared"))?;
                                        let func_ref = module.declare_func_in_func(*trim_func, builder.func);

                                        let call = builder.ins().call(func_ref, &[str_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "toLowerCase" => {
                                        // str.toLowerCase()
                                        let lower_func = extern_funcs.get("js_string_to_lower_case")
                                            .ok_or_else(|| anyhow!("js_string_to_lower_case not declared"))?;
                                        let func_ref = module.declare_func_in_func(*lower_func, builder.func);

                                        let call = builder.ins().call(func_ref, &[str_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "toUpperCase" => {
                                        // str.toUpperCase()
                                        let upper_func = extern_funcs.get("js_string_to_upper_case")
                                            .ok_or_else(|| anyhow!("js_string_to_upper_case not declared"))?;
                                        let func_ref = module.declare_func_in_func(*upper_func, builder.func);

                                        let call = builder.ins().call(func_ref, &[str_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "padStart" => {
                                        // str.padStart(targetLength, padString)
                                        let pad_func = extern_funcs.get("js_string_pad_start")
                                            .ok_or_else(|| anyhow!("js_string_pad_start not declared"))?;
                                        let func_ref = module.declare_func_in_func(*pad_func, builder.func);

                                        let target_len = if !arg_vals.is_empty() {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        // For default pad string " ", use js_string_alloc_space
                                        let pad_str = if arg_vals.len() >= 2 {
                                            // Extract string pointer from NaN-boxed value
                                            let pad_f64 = ensure_f64(builder, arg_vals[1]);
                                            let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                            let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                            let pad_call = builder.ins().call(get_str_ptr_ref, &[pad_f64]);
                                            builder.inst_results(pad_call)[0]
                                        } else {
                                            let alloc_space_func = extern_funcs.get("js_string_alloc_space")
                                                .ok_or_else(|| anyhow!("js_string_alloc_space not declared"))?;
                                            let alloc_space_ref = module.declare_func_in_func(*alloc_space_func, builder.func);
                                            let call = builder.ins().call(alloc_space_ref, &[]);
                                            builder.inst_results(call)[0]
                                        };

                                        let call = builder.ins().call(func_ref, &[str_ptr, target_len, pad_str]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "padEnd" => {
                                        // str.padEnd(targetLength, padString)
                                        let pad_func = extern_funcs.get("js_string_pad_end")
                                            .ok_or_else(|| anyhow!("js_string_pad_end not declared"))?;
                                        let func_ref = module.declare_func_in_func(*pad_func, builder.func);

                                        let target_len = if !arg_vals.is_empty() {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        // For default pad string " ", use js_string_alloc_space
                                        let pad_str = if arg_vals.len() >= 2 {
                                            // Extract string pointer from NaN-boxed value
                                            let pad_f64 = ensure_f64(builder, arg_vals[1]);
                                            let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                            let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                            let pad_call = builder.ins().call(get_str_ptr_ref, &[pad_f64]);
                                            builder.inst_results(pad_call)[0]
                                        } else {
                                            let alloc_space_func = extern_funcs.get("js_string_alloc_space")
                                                .ok_or_else(|| anyhow!("js_string_alloc_space not declared"))?;
                                            let alloc_space_ref = module.declare_func_in_func(*alloc_space_func, builder.func);
                                            let call = builder.ins().call(alloc_space_ref, &[]);
                                            builder.inst_results(call)[0]
                                        };

                                        let call = builder.ins().call(func_ref, &[str_ptr, target_len, pad_str]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "indexOf" => {
                                        // str.indexOf(needle) or str.indexOf(needle, fromIndex)
                                        // Extract needle string pointer from NaN-boxed value
                                        let needle_f64 = ensure_f64(builder, arg_vals[0]);
                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let needle_call = builder.ins().call(get_str_ptr_ref, &[needle_f64]);
                                        let needle_ptr = builder.inst_results(needle_call)[0];

                                        let result_i32 = if arg_vals.len() >= 2 {
                                            // str.indexOf(needle, fromIndex)
                                            let index_of_func = extern_funcs.get("js_string_index_of_from")
                                                .ok_or_else(|| anyhow!("js_string_index_of_from not declared"))?;
                                            let func_ref = module.declare_func_in_func(*index_of_func, builder.func);
                                            // Convert f64 fromIndex to i32
                                            let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                            let from_index = builder.ins().fcvt_to_sint(types::I32, arg_f64);
                                            let call = builder.ins().call(func_ref, &[str_ptr, needle_ptr, from_index]);
                                            builder.inst_results(call)[0]
                                        } else {
                                            // str.indexOf(needle)
                                            let index_of_func = extern_funcs.get("js_string_index_of")
                                                .ok_or_else(|| anyhow!("js_string_index_of not declared"))?;
                                            let func_ref = module.declare_func_in_func(*index_of_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[str_ptr, needle_ptr]);
                                            builder.inst_results(call)[0]
                                        };
                                        // Convert i32 to f64
                                        let result_f64 = builder.ins().fcvt_from_sint(types::F64, result_i32);
                                        return Ok(result_f64);
                                    }
                                    "split" => {
                                        // str.split(delimiter)
                                        let split_func = extern_funcs.get("js_string_split")
                                            .ok_or_else(|| anyhow!("js_string_split not declared"))?;
                                        let func_ref = module.declare_func_in_func(*split_func, builder.func);

                                        // Extract delimiter string pointer from NaN-boxed value
                                        let delim_f64 = ensure_f64(builder, arg_vals[0]);
                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let delim_call = builder.ins().call(get_str_ptr_ref, &[delim_f64]);
                                        let delim_ptr = builder.inst_results(delim_call)[0];

                                        let call = builder.ins().call(func_ref, &[str_ptr, delim_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the array pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                            .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "replace" => {
                                        // str.replace(pattern, replacement)
                                        // For now, assume pattern is a regex (first arg) and replacement is a string (second arg)
                                        if arg_vals.len() >= 2 {
                                            // Extract string pointers from NaN-boxed values
                                            let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                            let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);

                                            let pattern_f64 = ensure_f64(builder, arg_vals[0]);
                                            let pattern_call = builder.ins().call(get_str_ptr_ref, &[pattern_f64]);
                                            let pattern_ptr = builder.inst_results(pattern_call)[0];

                                            let replacement_f64 = ensure_f64(builder, arg_vals[1]);
                                            let replacement_call = builder.ins().call(get_str_ptr_ref, &[replacement_f64]);
                                            let replacement_ptr = builder.inst_results(replacement_call)[0];

                                            let replace_func = extern_funcs.get("js_string_replace_regex")
                                                .ok_or_else(|| anyhow!("js_string_replace_regex not declared"))?;
                                            let func_ref = module.declare_func_in_func(*replace_func, builder.func);

                                            let call = builder.ins().call(func_ref, &[str_ptr, pattern_ptr, replacement_ptr]);
                                            let result_ptr = builder.inst_results(call)[0];
                                            // NaN-box the result string
                                            let nanbox_func = extern_funcs.get("js_nanbox_string")
                                                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                            let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                            return Ok(builder.inst_results(nanbox_call)[0]);
                                        }
                                    }
                                    "repeat" => {
                                        // str.repeat(count)
                                        if !arg_vals.is_empty() {
                                            let func = extern_funcs.get("js_string_repeat")
                                                .ok_or_else(|| anyhow!("js_string_repeat not declared"))?;
                                            let func_ref = module.declare_func_in_func(*func, builder.func);
                                            let count = {
                                                let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                                builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                            };
                                            let call = builder.ins().call(func_ref, &[str_ptr, count]);
                                            let result_ptr = builder.inst_results(call)[0];
                                            // NaN-box the result string pointer
                                            let nanbox_func = extern_funcs.get("js_nanbox_string")
                                                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                            let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                            return Ok(builder.inst_results(nanbox_call)[0]);
                                        }
                                    }
                                    "charAt" => {
                                        // str.charAt(index)
                                        if !arg_vals.is_empty() {
                                            let func = extern_funcs.get("js_string_char_at")
                                                .ok_or_else(|| anyhow!("js_string_char_at not declared"))?;
                                            let func_ref = module.declare_func_in_func(*func, builder.func);
                                            let index = {
                                                let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                                builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                            };
                                            let call = builder.ins().call(func_ref, &[str_ptr, index]);
                                            let result_ptr = builder.inst_results(call)[0];
                                            // NaN-box the result string pointer
                                            let nanbox_func = extern_funcs.get("js_nanbox_string")
                                                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                            let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                            return Ok(builder.inst_results(nanbox_call)[0]);
                                        }
                                    }
                                    _ => {}
                                }
                            }

                            // Handle buffer method calls
                            if info.is_buffer {
                                let buf_val = builder.use_var(info.var);
                                let buf_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf_val);

                                match property.as_str() {
                                    "toString" => {
                                        // buf.toString(encoding?)
                                        let encoding = if arg_vals.len() > 0 {
                                            // TODO: Parse encoding string
                                            builder.ins().iconst(types::I32, 0) // UTF-8
                                        } else {
                                            builder.ins().iconst(types::I32, 0) // UTF-8 default
                                        };
                                        let func = extern_funcs.get("js_buffer_to_string")
                                            .ok_or_else(|| anyhow!("js_buffer_to_string not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let call = builder.ins().call(func_ref, &[buf_ptr, encoding]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr));
                                    }
                                    "slice" => {
                                        // buf.slice(start?, end?)
                                        let start = if arg_vals.len() > 0 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        let end = if arg_vals.len() > 1 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, i32::MAX as i64)
                                        };
                                        let func = extern_funcs.get("js_buffer_slice")
                                            .ok_or_else(|| anyhow!("js_buffer_slice not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let call = builder.ins().call(func_ref, &[buf_ptr, start, end]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr));
                                    }
                                    "equals" => {
                                        // buf.equals(other)
                                        let other_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                        let func = extern_funcs.get("js_buffer_equals")
                                            .ok_or_else(|| anyhow!("js_buffer_equals not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let call = builder.ins().call(func_ref, &[buf_ptr, other_ptr]);
                                        let result_i32 = builder.inst_results(call)[0];
                                        // Convert i32 (0 or 1) to f64
                                        return Ok(builder.ins().fcvt_from_sint(types::F64, result_i32));
                                    }
                                    "copy" => {
                                        // buf.copy(target, targetStart?, sourceStart?, sourceEnd?)
                                        let target_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                        let target_start = if arg_vals.len() > 1 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        let source_start = if arg_vals.len() > 2 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[2]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        let source_end = if arg_vals.len() > 3 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[3]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, i32::MAX as i64)
                                        };
                                        let func = extern_funcs.get("js_buffer_copy")
                                            .ok_or_else(|| anyhow!("js_buffer_copy not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let call = builder.ins().call(func_ref, &[buf_ptr, target_ptr, target_start, source_start, source_end]);
                                        let result_i32 = builder.inst_results(call)[0];
                                        return Ok(builder.ins().fcvt_from_sint(types::F64, result_i32));
                                    }
                                    "write" => {
                                        // buf.write(string, offset?, encoding?)
                                        let str_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                        let offset = if arg_vals.len() > 1 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        let encoding = builder.ins().iconst(types::I32, 0); // UTF-8
                                        let func = extern_funcs.get("js_buffer_write")
                                            .ok_or_else(|| anyhow!("js_buffer_write not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let call = builder.ins().call(func_ref, &[buf_ptr, str_ptr, offset, encoding]);
                                        let result_i32 = builder.inst_results(call)[0];
                                        return Ok(builder.ins().fcvt_from_sint(types::F64, result_i32));
                                    }
                                    _ => {}
                                }
                            }

                            // Handle bigint method calls
                            if info.is_bigint {
                                let bigint_val = builder.use_var(info.var);
                                // BigInt may be stored as I64 (raw pointer) or F64 (NaN-boxed)
                                let bigint_ptr = {
                                    let val_type = builder.func.dfg.value_type(bigint_val);
                                    if val_type == types::F64 {
                                        // NaN-boxed - extract raw pointer
                                        let get_bigint_func = extern_funcs.get("js_nanbox_get_bigint")
                                            .ok_or_else(|| anyhow!("js_nanbox_get_bigint not declared"))?;
                                        let get_bigint_ref = module.declare_func_in_func(*get_bigint_func, builder.func);
                                        let extract_call = builder.ins().call(get_bigint_ref, &[bigint_val]);
                                        builder.inst_results(extract_call)[0]
                                    } else {
                                        // Already a raw pointer
                                        bigint_val
                                    }
                                };

                                match property.as_str() {
                                    "toString" => {
                                        let to_string_func = extern_funcs.get("js_bigint_to_string")
                                            .ok_or_else(|| anyhow!("js_bigint_to_string not declared"))?;
                                        let func_ref = module.declare_func_in_func(*to_string_func, builder.func);
                                        let call = builder.ins().call(func_ref, &[bigint_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string with STRING_TAG
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    _ => {}
                                }
                            }

                            // Handle Map method calls (set, get, has, delete, clear, forEach)
                            if info.is_map {
                                let map_ptr = builder.use_var(info.var);
                                match property.as_str() {
                                    "set" => {
                                        // map.set(key, value) -> map
                                        if arg_vals.len() >= 2 {
                                            let key = ensure_f64(builder, arg_vals[0]);
                                            let value = ensure_f64(builder, arg_vals[1]);
                                            let set_func = extern_funcs.get("js_map_set")
                                                .ok_or_else(|| anyhow!("js_map_set not declared"))?;
                                            let func_ref = module.declare_func_in_func(*set_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[map_ptr, key, value]);
                                            let result_ptr = builder.inst_results(call)[0];
                                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr));
                                        }
                                    }
                                    "get" => {
                                        // map.get(key) -> value | undefined
                                        if !arg_vals.is_empty() {
                                            let key = ensure_f64(builder, arg_vals[0]);
                                            let get_func = extern_funcs.get("js_map_get")
                                                .ok_or_else(|| anyhow!("js_map_get not declared"))?;
                                            let func_ref = module.declare_func_in_func(*get_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[map_ptr, key]);
                                            return Ok(builder.inst_results(call)[0]);
                                        }
                                    }
                                    "has" => {
                                        // map.has(key) -> boolean
                                        if !arg_vals.is_empty() {
                                            let key = ensure_f64(builder, arg_vals[0]);
                                            let has_func = extern_funcs.get("js_map_has")
                                                .ok_or_else(|| anyhow!("js_map_has not declared"))?;
                                            let func_ref = module.declare_func_in_func(*has_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[map_ptr, key]);
                                            return Ok(builder.inst_results(call)[0]);
                                        }
                                    }
                                    "delete" => {
                                        // map.delete(key) -> boolean
                                        if !arg_vals.is_empty() {
                                            let key = ensure_f64(builder, arg_vals[0]);
                                            let delete_func = extern_funcs.get("js_map_delete")
                                                .ok_or_else(|| anyhow!("js_map_delete not declared"))?;
                                            let func_ref = module.declare_func_in_func(*delete_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[map_ptr, key]);
                                            return Ok(builder.inst_results(call)[0]);
                                        }
                                    }
                                    "clear" => {
                                        // map.clear() -> undefined
                                        let clear_func = extern_funcs.get("js_map_clear")
                                            .ok_or_else(|| anyhow!("js_map_clear not declared"))?;
                                        let func_ref = module.declare_func_in_func(*clear_func, builder.func);
                                        builder.ins().call(func_ref, &[map_ptr]);
                                        const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                                        return Ok(builder.ins().f64const(f64::from_bits(TAG_UNDEFINED))); // undefined
                                    }
                                    _ => {}
                                }
                            }

                            // Handle Set method calls (add, has, delete, clear)
                            if info.is_set {
                                let set_ptr = builder.use_var(info.var);
                                match property.as_str() {
                                    "add" => {
                                        // set.add(value) -> set
                                        if !arg_vals.is_empty() {
                                            let value = ensure_f64(builder, arg_vals[0]);
                                            let add_func = extern_funcs.get("js_set_add")
                                                .ok_or_else(|| anyhow!("js_set_add not declared"))?;
                                            let func_ref = module.declare_func_in_func(*add_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[set_ptr, value]);
                                            let result_ptr = builder.inst_results(call)[0];
                                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr));
                                        }
                                    }
                                    "has" => {
                                        // set.has(value) -> boolean
                                        if !arg_vals.is_empty() {
                                            let value = ensure_f64(builder, arg_vals[0]);
                                            let has_func = extern_funcs.get("js_set_has")
                                                .ok_or_else(|| anyhow!("js_set_has not declared"))?;
                                            let func_ref = module.declare_func_in_func(*has_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[set_ptr, value]);
                                            return Ok(builder.inst_results(call)[0]);
                                        }
                                    }
                                    "delete" => {
                                        // set.delete(value) -> boolean
                                        if !arg_vals.is_empty() {
                                            let value = ensure_f64(builder, arg_vals[0]);
                                            let delete_func = extern_funcs.get("js_set_delete")
                                                .ok_or_else(|| anyhow!("js_set_delete not declared"))?;
                                            let func_ref = module.declare_func_in_func(*delete_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[set_ptr, value]);
                                            return Ok(builder.inst_results(call)[0]);
                                        }
                                    }
                                    "clear" => {
                                        // set.clear() -> undefined
                                        let clear_func = extern_funcs.get("js_set_clear")
                                            .ok_or_else(|| anyhow!("js_set_clear not declared"))?;
                                        let func_ref = module.declare_func_in_func(*clear_func, builder.func);
                                        builder.ins().call(func_ref, &[set_ptr]);
                                        const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                                        return Ok(builder.ins().f64const(f64::from_bits(TAG_UNDEFINED))); // undefined
                                    }
                                    _ => {}
                                }
                            }

                            // Handle EventEmitter method calls
                            if info.is_event_emitter {
                                // EventEmitter is stored as f64 (bitcast of i64 handle)
                                // Extract the handle using js_nanbox_get_pointer
                                let emitter_f64 = builder.use_var(info.var);
                                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                                let ptr_call = builder.ins().call(get_ptr_ref, &[emitter_f64]);
                                let handle = builder.inst_results(ptr_call)[0];

                                match property.as_str() {
                                    "emit" => {
                                        // emit(eventName, arg?) - eventName is NaN-boxed string
                                        let func_name = if arg_vals.len() >= 2 {
                                            "js_event_emitter_emit"
                                        } else {
                                            "js_event_emitter_emit0"
                                        };
                                        let emit_func = extern_funcs.get(func_name)
                                            .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                                        let func_ref = module.declare_func_in_func(*emit_func, builder.func);

                                        // Extract string pointer from NaN-boxed event name
                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let event_f64 = ensure_f64(builder, arg_vals[0]);
                                        let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                        let event_ptr = builder.inst_results(event_call)[0];

                                        let mut call_args = vec![handle, event_ptr];
                                        if arg_vals.len() >= 2 {
                                            // Ensure arg is f64 (objects/pointers need bitcast)
                                            call_args.push(ensure_f64(builder, arg_vals[1]));
                                        }

                                        let call = builder.ins().call(func_ref, &call_args);
                                        return Ok(builder.inst_results(call)[0]);
                                    }
                                    "on" | "addListener" => {
                                        // on(eventName, callback) - eventName is NaN-boxed string, callback is closure
                                        let on_func = extern_funcs.get("js_event_emitter_on")
                                            .ok_or_else(|| anyhow!("js_event_emitter_on not declared"))?;
                                        let func_ref = module.declare_func_in_func(*on_func, builder.func);

                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let event_f64 = ensure_f64(builder, arg_vals[0]);
                                        let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                        let event_ptr = builder.inst_results(event_call)[0];
                                        let callback_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[1]);

                                        let call = builder.ins().call(func_ref, &[handle, event_ptr, callback_ptr]);
                                        let _ = builder.inst_results(call)[0];
                                        // Return emitter for chaining
                                        return Ok(emitter_f64);
                                    }
                                    "removeListener" | "off" => {
                                        let remove_func = extern_funcs.get("js_event_emitter_remove_listener")
                                            .ok_or_else(|| anyhow!("js_event_emitter_remove_listener not declared"))?;
                                        let func_ref = module.declare_func_in_func(*remove_func, builder.func);

                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let event_f64 = ensure_f64(builder, arg_vals[0]);
                                        let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                        let event_ptr = builder.inst_results(event_call)[0];
                                        let callback_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[1]);

                                        let call = builder.ins().call(func_ref, &[handle, event_ptr, callback_ptr]);
                                        let _ = builder.inst_results(call)[0];
                                        // Return emitter for chaining
                                        return Ok(emitter_f64);
                                    }
                                    "removeAllListeners" => {
                                        let remove_all_func = extern_funcs.get("js_event_emitter_remove_all_listeners")
                                            .ok_or_else(|| anyhow!("js_event_emitter_remove_all_listeners not declared"))?;
                                        let func_ref = module.declare_func_in_func(*remove_all_func, builder.func);

                                        let event_ptr = if !arg_vals.is_empty() {
                                            let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                            let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                            let event_f64 = ensure_f64(builder, arg_vals[0]);
                                            let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                            builder.inst_results(event_call)[0]
                                        } else {
                                            builder.ins().iconst(types::I64, 0) // null for no event name
                                        };

                                        let call = builder.ins().call(func_ref, &[handle, event_ptr]);
                                        let _ = builder.inst_results(call)[0];
                                        // Return emitter for chaining
                                        return Ok(emitter_f64);
                                    }
                                    "listenerCount" => {
                                        let count_func = extern_funcs.get("js_event_emitter_listener_count")
                                            .ok_or_else(|| anyhow!("js_event_emitter_listener_count not declared"))?;
                                        let func_ref = module.declare_func_in_func(*count_func, builder.func);

                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let event_f64 = ensure_f64(builder, arg_vals[0]);
                                        let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                        let event_ptr = builder.inst_results(event_call)[0];

                                        let call = builder.ins().call(func_ref, &[handle, event_ptr]);
                                        return Ok(builder.inst_results(call)[0]);
                                    }
                                    _ => {}
                                }
                            }
                        }
                    }

                    // Handle method calls on objects (e.g., rect.area())
                    if let Expr::LocalGet(id) = object.as_ref() {
                        if let Some(info) = locals.get(id) {
                            if let Some(ref class_name) = info.class_name {
                                if let Some(class_meta) = classes.get(class_name) {
                                    // First check for own methods
                                    if let Some(&method_id) = class_meta.method_ids.get(property) {
                                        // Get the object pointer - ensure it's i64
                                        let obj_val = builder.use_var(info.var);
                                        let obj_ptr = ensure_i64(builder, obj_val);

                                        // Build args: [this, ...args]
                                        // Method expects this as i64, args as f64
                                        let mut call_args = vec![obj_ptr];
                                        for arg in &arg_vals {
                                            call_args.push(ensure_f64(builder, *arg));
                                        }

                                        let func_ref = module.declare_func_in_func(method_id, builder.func);

                                        // Get expected parameter count and types from the function signature
                                        let actual_sig = module.declarations().get_function_decl(method_id);
                                        let expected_param_count = actual_sig.signature.params.len();

                                        // Convert arguments to match expected types
                                        let mut final_call_args: Vec<Value> = call_args.iter().enumerate()
                                            .map(|(i, &val)| {
                                                if i < actual_sig.signature.params.len() {
                                                    let expected_type = actual_sig.signature.params[i].value_type;
                                                    let actual_type = builder.func.dfg.value_type(val);
                                                    if expected_type == types::I64 && actual_type == types::F64 {
                                                        builder.ins().bitcast(types::I64, MemFlags::new(), val)
                                                    } else if expected_type == types::F64 && actual_type == types::I64 {
                                                        builder.ins().bitcast(types::F64, MemFlags::new(), val)
                                                    } else {
                                                        val
                                                    }
                                                } else {
                                                    val
                                                }
                                            })
                                            .collect();

                                        // Pad or truncate arguments to match expected count with correct types
                                        while final_call_args.len() < expected_param_count {
                                            let expected_type = actual_sig.signature.params[final_call_args.len()].value_type;
                                            if expected_type == types::I64 {
                                                final_call_args.push(builder.ins().iconst(types::I64, 0));
                                            } else {
                                                final_call_args.push(builder.ins().f64const(f64::NAN));
                                            }
                                        }
                                        final_call_args.truncate(expected_param_count);

                                        let call = builder.ins().call(func_ref, &final_call_args);
                                        return Ok(builder.inst_results(call)[0]);
                                    }

                                    // Check for methods inherited from native parent (e.g., EventEmitter)
                                    if let Some((native_module, _native_class)) = &class_meta.native_parent {
                                        if native_module == "events" {
                                            // Get the object pointer - ensure it's i64
                                            let obj_val = builder.use_var(info.var);
                                            let obj_ptr = ensure_i64(builder, obj_val);
                                            // Get the native handle from field 0 (offset 16 after ObjectHeader)
                                            let field_offset = builder.ins().iconst(types::I64, 16);
                                            let field_ptr = builder.ins().iadd(obj_ptr, field_offset);
                                            let handle_f64 = builder.ins().load(types::F64, MemFlags::new(), field_ptr, 0);
                                            let handle = builder.ins().bitcast(types::I64, MemFlags::new(), handle_f64);

                                            match property.as_str() {
                                                "emit" => {
                                                    let func_name = if arg_vals.len() >= 2 {
                                                        "js_event_emitter_emit"
                                                    } else {
                                                        "js_event_emitter_emit0"
                                                    };
                                                    let emit_func = extern_funcs.get(func_name)
                                                        .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                                                    let func_ref = module.declare_func_in_func(*emit_func, builder.func);

                                                    let event_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                                    let mut call_args = vec![handle, event_ptr];
                                                    if arg_vals.len() >= 2 {
                                                        // Ensure arg is f64 (objects/pointers need bitcast)
                                                        call_args.push(ensure_f64(builder, arg_vals[1]));
                                                    }

                                                    let call = builder.ins().call(func_ref, &call_args);
                                                    return Ok(builder.inst_results(call)[0]);
                                                }
                                                "on" | "addListener" => {
                                                    let on_func = extern_funcs.get("js_event_emitter_on")
                                                        .ok_or_else(|| anyhow!("js_event_emitter_on not declared"))?;
                                                    let func_ref = module.declare_func_in_func(*on_func, builder.func);

                                                    let event_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                                    let callback_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[1]);

                                                    let call = builder.ins().call(func_ref, &[handle, event_ptr, callback_ptr]);
                                                    let _ = builder.inst_results(call)[0];
                                                    // Return this for chaining
                                                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), obj_ptr));
                                                }
                                                "removeListener" | "off" => {
                                                    let remove_func = extern_funcs.get("js_event_emitter_remove_listener")
                                                        .ok_or_else(|| anyhow!("js_event_emitter_remove_listener not declared"))?;
                                                    let func_ref = module.declare_func_in_func(*remove_func, builder.func);

                                                    let event_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                                    let callback_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[1]);

                                                    let call = builder.ins().call(func_ref, &[handle, event_ptr, callback_ptr]);
                                                    let _ = builder.inst_results(call)[0];
                                                    // Return this for chaining
                                                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), obj_ptr));
                                                }
                                                _ => {}
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Handle method calls on 'this' (e.g., this.emit())
                    if matches!(object.as_ref(), Expr::This) {
                        if let Some(ctx) = this_ctx {
                            let class_meta = &ctx.class_meta;

                            // First check if it's our own method
                            if let Some(&method_id) = class_meta.method_ids.get(property) {
                                let this_ptr = builder.use_var(ctx.this_var);
                                // Method expects this as i64, args as f64
                                let mut call_args = vec![this_ptr];
                                for arg in &arg_vals {
                                    call_args.push(ensure_f64(builder, *arg));
                                }

                                let func_ref = module.declare_func_in_func(method_id, builder.func);

                                // Get expected parameter count and types from the function signature
                                let actual_sig = module.declarations().get_function_decl(method_id);
                                let expected_param_count = actual_sig.signature.params.len();

                                // Convert arguments to match expected types
                                let mut final_call_args: Vec<Value> = call_args.iter().enumerate()
                                    .map(|(i, &val)| {
                                        if i < actual_sig.signature.params.len() {
                                            let expected_type = actual_sig.signature.params[i].value_type;
                                            let actual_type = builder.func.dfg.value_type(val);
                                            if expected_type == types::I64 && actual_type == types::F64 {
                                                builder.ins().bitcast(types::I64, MemFlags::new(), val)
                                            } else if expected_type == types::F64 && actual_type == types::I64 {
                                                builder.ins().bitcast(types::F64, MemFlags::new(), val)
                                            } else {
                                                val
                                            }
                                        } else {
                                            val
                                        }
                                    })
                                    .collect();

                                // Pad or truncate arguments to match expected count with correct types
                                while final_call_args.len() < expected_param_count {
                                    let expected_type = actual_sig.signature.params[final_call_args.len()].value_type;
                                    if expected_type == types::I64 {
                                        final_call_args.push(builder.ins().iconst(types::I64, 0));
                                    } else {
                                        final_call_args.push(builder.ins().f64const(f64::NAN));
                                    }
                                }
                                final_call_args.truncate(expected_param_count);

                                let call = builder.ins().call(func_ref, &final_call_args);
                                return Ok(builder.inst_results(call)[0]);
                            }

                            // Check if it's a method inherited from native parent (e.g., EventEmitter)
                            if let Some((native_module, _native_class)) = &class_meta.native_parent {
                                if native_module == "events" {
                                    // Get the native handle from field 0
                                    let this_ptr = builder.use_var(ctx.this_var);
                                    let field_offset = builder.ins().iconst(types::I64, 16); // After ObjectHeader
                                    let field_ptr = builder.ins().iadd(this_ptr, field_offset);
                                    let handle_f64 = builder.ins().load(types::F64, MemFlags::new(), field_ptr, 0);
                                    let handle = builder.ins().bitcast(types::I64, MemFlags::new(), handle_f64);

                                    match property.as_str() {
                                        "emit" => {
                                            // emit(eventName, arg?)
                                            let func_name = if arg_vals.len() >= 2 {
                                                "js_event_emitter_emit"
                                            } else {
                                                "js_event_emitter_emit0"
                                            };
                                            let emit_func = extern_funcs.get(func_name)
                                                .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                                            let func_ref = module.declare_func_in_func(*emit_func, builder.func);

                                            let event_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                            let mut call_args = vec![handle, event_ptr];
                                            if arg_vals.len() >= 2 {
                                                // Ensure arg is f64 (objects/pointers need bitcast)
                                                call_args.push(ensure_f64(builder, arg_vals[1]));
                                            }

                                            let call = builder.ins().call(func_ref, &call_args);
                                            return Ok(builder.inst_results(call)[0]);
                                        }
                                        "on" | "addListener" => {
                                            // on(eventName, callback)
                                            let on_func = extern_funcs.get("js_event_emitter_on")
                                                .ok_or_else(|| anyhow!("js_event_emitter_on not declared"))?;
                                            let func_ref = module.declare_func_in_func(*on_func, builder.func);

                                            let event_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                            let callback_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[1]);

                                            let call = builder.ins().call(func_ref, &[handle, event_ptr, callback_ptr]);
                                            // Return this for chaining
                                            let _ = builder.inst_results(call)[0];
                                            let this_ptr = builder.use_var(ctx.this_var);
                                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), this_ptr));
                                        }
                                        "removeListener" | "off" => {
                                            let remove_func = extern_funcs.get("js_event_emitter_remove_listener")
                                                .ok_or_else(|| anyhow!("js_event_emitter_remove_listener not declared"))?;
                                            let func_ref = module.declare_func_in_func(*remove_func, builder.func);

                                            let event_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                            let callback_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[1]);

                                            let call = builder.ins().call(func_ref, &[handle, event_ptr, callback_ptr]);
                                            let _ = builder.inst_results(call)[0];
                                            let this_ptr = builder.use_var(ctx.this_var);
                                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), this_ptr));
                                        }
                                        _ => {}
                                    }
                                }
                            }
                        }
                    }

                    // Handle toString on bigint field access (e.g., this.reserve1.toString())
                    if property == "toString" {
                        if let Expr::PropertyGet { object: inner_obj, property: field_name } = object.as_ref() {
                            if let Expr::This = inner_obj.as_ref() {
                                if let Some(ctx) = this_ctx {
                                    // Check if the field is a bigint by looking up class field types
                                    if let Some(field_type) = ctx.class_meta.field_types.get(field_name) {
                                        if matches!(field_type, perry_types::Type::BigInt) {
                                            // This is a bigint field - compile as bigint.toString()
                                            // First get the field value
                                            if let Some(&field_idx) = ctx.class_meta.field_indices.get(field_name) {
                                                let this_ptr = builder.use_var(ctx.this_var);
                                                let field_offset = 16 + (field_idx as i64 * 8);
                                                let field_ptr = builder.ins().iadd_imm(this_ptr, field_offset);
                                                let bigint_val = builder.ins().load(types::F64, MemFlags::new(), field_ptr, 0);
                                                let bigint_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), bigint_val);

                                                let to_string_func = extern_funcs.get("js_bigint_to_string")
                                                    .ok_or_else(|| anyhow!("js_bigint_to_string not declared"))?;
                                                let func_ref = module.declare_func_in_func(*to_string_func, builder.func);
                                                let call = builder.ins().call(func_ref, &[bigint_ptr]);
                                                let result_ptr = builder.inst_results(call)[0];
                                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr));
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Handle method chaining on NativeMethodCall results
                    // e.g., cmd.name("app").description("desc").parse()
                    if let Expr::NativeMethodCall { module: native_module, method: native_method, .. } = object.as_ref() {
                        // Handle toString() on BigInt-returning methods (e.g., parseEther('1.5').toString())
                        if property == "toString" {
                            // Check if the NativeMethodCall returns a BigInt
                            let returns_bigint = native_module == "ethers" &&
                                (native_method == "parseUnits" || native_method == "parseEther");

                            if returns_bigint {
                                // Compile the object expression (the BigInt value)
                                let bigint_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;

                                // Extract the BigInt pointer from the NaN-boxed value
                                let bigint_f64 = ensure_f64(builder, bigint_val);
                                let get_bigint_func = extern_funcs.get("js_nanbox_get_bigint")
                                    .ok_or_else(|| anyhow!("js_nanbox_get_bigint not declared"))?;
                                let get_bigint_ref = module.declare_func_in_func(*get_bigint_func, builder.func);
                                let extract_call = builder.ins().call(get_bigint_ref, &[bigint_f64]);
                                let bigint_ptr = builder.inst_results(extract_call)[0];

                                // Call js_bigint_to_string
                                let to_string_func = extern_funcs.get("js_bigint_to_string")
                                    .ok_or_else(|| anyhow!("js_bigint_to_string not declared"))?;
                                let func_ref = module.declare_func_in_func(*to_string_func, builder.func);
                                let call = builder.ins().call(func_ref, &[bigint_ptr]);
                                let result_ptr = builder.inst_results(call)[0];

                                // NaN-box the result string with STRING_TAG
                                let nanbox_func = extern_funcs.get("js_nanbox_string")
                                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                return Ok(builder.inst_results(nanbox_call)[0]);
                            }
                        }

                        // Compile the object expression to get the handle from the previous call
                        let handle = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                        let handle_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), handle);

                        // Dispatch based on the native module
                        let func_name = match (native_module.as_str(), property.as_str()) {
                            // Commander chaining methods
                            ("commander", "name") => Some("js_commander_name"),
                            ("commander", "description") => Some("js_commander_description"),
                            ("commander", "version") => Some("js_commander_version"),
                            ("commander", "option") => Some("js_commander_option"),
                            ("commander", "parse") => Some("js_commander_parse"),
                            ("commander", "opts") => Some("js_commander_opts"),
                            // Decimal chaining methods
                            ("big.js" | "decimal.js" | "bignumber.js", "plus") => Some("js_decimal_plus"),
                            ("big.js" | "decimal.js" | "bignumber.js", "minus") => Some("js_decimal_minus"),
                            ("big.js" | "decimal.js" | "bignumber.js", "times") => Some("js_decimal_times"),
                            ("big.js" | "decimal.js" | "bignumber.js", "div") => Some("js_decimal_div"),
                            ("big.js" | "decimal.js" | "bignumber.js", "toFixed") => Some("js_decimal_to_fixed"),
                            ("big.js" | "decimal.js" | "bignumber.js", "toString") => Some("js_decimal_to_string"),
                            _ => None,
                        };

                        if let Some(func_name) = func_name {
                            let func = extern_funcs.get(func_name)
                                .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                            let func_ref = module.declare_func_in_func(*func, builder.func);

                            // Build args: [handle, ...args]
                            let mut call_args = vec![handle_i64];
                            for arg in &arg_vals {
                                // Convert f64 args to i64 (for string pointers)
                                let arg_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), *arg);
                                call_args.push(arg_i64);
                            }

                            let call = builder.ins().call(func_ref, &call_args);
                            let result = builder.inst_results(call)[0];
                            // Convert result back to f64 for uniform handling
                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result));
                        }
                    }

                    // Handle slice specially - it could be array.slice() or string.slice()
                    // Check if the object is an array by looking at the local variable info or expression type
                    if property == "slice" {
                        let is_array = if let Expr::LocalGet(id) = object.as_ref() {
                            locals.get(id).map(|info| info.is_array).unwrap_or(false)
                        } else if let Expr::Call { callee, .. } = object.as_ref() {
                            // Check if the callee is a method that returns an array
                            if let Expr::PropertyGet { property: method_name, .. } = callee.as_ref() {
                                // split(), map(), filter(), etc. return arrays
                                matches!(method_name.as_str(), "split" | "map" | "filter" | "concat" |
                                    "flat" | "flatMap" | "reverse" | "sort" | "toSorted" | "toReversed" | "with")
                            } else {
                                false
                            }
                        } else if let Expr::Array(_) | Expr::ArraySpread(_) = object.as_ref() {
                            true
                        } else {
                            false
                        };

                        if is_array {
                            // Array slice - extract pointer and call js_array_slice
                            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                            // Extract the array pointer from NaN-boxed value if needed
                            let arr_ptr = if builder.func.dfg.value_type(arr_val) == types::F64 {
                                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                                let call = builder.ins().call(get_ptr_ref, &[arr_val]);
                                builder.inst_results(call)[0]
                            } else {
                                arr_val
                            };

                            // Get start index
                            let start_i32 = if !arg_vals.is_empty() {
                                let start_f64 = ensure_f64(builder, arg_vals[0]);
                                builder.ins().fcvt_to_sint(types::I32, start_f64)
                            } else {
                                builder.ins().iconst(types::I32, 0)
                            };

                            // Get end index
                            let end_i32 = if arg_vals.len() > 1 {
                                let end_f64 = ensure_f64(builder, arg_vals[1]);
                                builder.ins().fcvt_to_sint(types::I32, end_f64)
                            } else {
                                builder.ins().iconst(types::I32, i32::MAX as i64)
                            };

                            let func = extern_funcs.get("js_array_slice")
                                .ok_or_else(|| anyhow!("js_array_slice not declared"))?;
                            let func_ref = module.declare_func_in_func(*func, builder.func);
                            let call = builder.ins().call(func_ref, &[arr_ptr, start_i32, end_i32]);
                            let result_ptr = builder.inst_results(call)[0];
                            // NaN-box the result array pointer
                            let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                            let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                            return Ok(builder.inst_results(nanbox_call)[0]);
                        }
                        // Fall through to string slice if not an array
                    }

                    // Handle string methods on any expression (e.g., query.queryText.substring(0, 20))
                    // This handles property access chains and other cases where the object is not a LocalGet
                    match property.as_str() {
                        "substring" | "slice" | "trim" | "toLowerCase" | "toUpperCase" | "indexOf" | "includes" | "split" | "replace" | "startsWith" | "endsWith" | "padStart" | "padEnd" | "repeat" | "charAt" | "charCodeAt" => {
                            // Compile the object expression to get a string value
                            let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;

                            // The value might be NaN-boxed (from PropertyGet on objects) or a raw pointer bitcast to f64 (from string literals)
                            // Use unified function that handles both representations
                            let str_ptr = if builder.func.dfg.value_type(str_val) == types::F64 {
                                // Value is f64 - could be NaN-boxed string or raw pointer bitcast
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                let call = builder.ins().call(get_str_ptr_ref, &[str_val]);
                                builder.inst_results(call)[0]
                            } else {
                                // Value is already i64 - raw pointer
                                str_val
                            };

                            match property.as_str() {
                                "substring" | "slice" => {
                                    let func_name = if property == "substring" { "js_string_substring" } else { "js_string_slice" };
                                    let func = extern_funcs.get(func_name)
                                        .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                                    let func_ref = module.declare_func_in_func(*func, builder.func);

                                    let start = if !arg_vals.is_empty() {
                                        let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                        builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                    } else {
                                        builder.ins().iconst(types::I32, 0)
                                    };
                                    let end = if arg_vals.len() > 1 {
                                        let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                        builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                    } else {
                                        builder.ins().iconst(types::I32, i32::MAX as i64)
                                    };

                                    let call = builder.ins().call(func_ref, &[str_ptr, start, end]);
                                    let result_ptr = builder.inst_results(call)[0];
                                    // NaN-box the result so it can be printed correctly
                                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                    let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                    return Ok(builder.inst_results(nanbox_call)[0]);
                                }
                                "trim" => {
                                    let trim_func = extern_funcs.get("js_string_trim")
                                        .ok_or_else(|| anyhow!("js_string_trim not declared"))?;
                                    let func_ref = module.declare_func_in_func(*trim_func, builder.func);
                                    let call = builder.ins().call(func_ref, &[str_ptr]);
                                    let result_ptr = builder.inst_results(call)[0];
                                    // NaN-box the result
                                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                    let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                    return Ok(builder.inst_results(nanbox_call)[0]);
                                }
                                "toLowerCase" => {
                                    let lower_func = extern_funcs.get("js_string_to_lower_case")
                                        .ok_or_else(|| anyhow!("js_string_to_lower_case not declared"))?;
                                    let func_ref = module.declare_func_in_func(*lower_func, builder.func);
                                    let call = builder.ins().call(func_ref, &[str_ptr]);
                                    let result_ptr = builder.inst_results(call)[0];
                                    // NaN-box the result
                                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                    let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                    return Ok(builder.inst_results(nanbox_call)[0]);
                                }
                                "toUpperCase" => {
                                    let upper_func = extern_funcs.get("js_string_to_upper_case")
                                        .ok_or_else(|| anyhow!("js_string_to_upper_case not declared"))?;
                                    let func_ref = module.declare_func_in_func(*upper_func, builder.func);
                                    let call = builder.ins().call(func_ref, &[str_ptr]);
                                    let result_ptr = builder.inst_results(call)[0];
                                    // NaN-box the result
                                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                    let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                    return Ok(builder.inst_results(nanbox_call)[0]);
                                }
                                "indexOf" => {
                                    if !arg_vals.is_empty() {
                                        // Extract needle string pointer from NaN-boxed value
                                        let needle_f64 = ensure_f64(builder, arg_vals[0]);
                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let needle_call = builder.ins().call(get_str_ptr_ref, &[needle_f64]);
                                        let needle_ptr = builder.inst_results(needle_call)[0];

                                        let result_i32 = if arg_vals.len() >= 2 {
                                            let index_of_func = extern_funcs.get("js_string_index_of_from")
                                                .ok_or_else(|| anyhow!("js_string_index_of_from not declared"))?;
                                            let func_ref = module.declare_func_in_func(*index_of_func, builder.func);
                                            let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                            let from_index = builder.ins().fcvt_to_sint(types::I32, arg_f64);
                                            let call = builder.ins().call(func_ref, &[str_ptr, needle_ptr, from_index]);
                                            builder.inst_results(call)[0]
                                        } else {
                                            let index_of_func = extern_funcs.get("js_string_index_of")
                                                .ok_or_else(|| anyhow!("js_string_index_of not declared"))?;
                                            let func_ref = module.declare_func_in_func(*index_of_func, builder.func);
                                            let call = builder.ins().call(func_ref, &[str_ptr, needle_ptr]);
                                            builder.inst_results(call)[0]
                                        };
                                        let result_f64 = builder.ins().fcvt_from_sint(types::F64, result_i32);
                                        return Ok(result_f64);
                                    }
                                }
                                "includes" => {
                                    if !arg_vals.is_empty() {
                                        // Extract needle string pointer from NaN-boxed value
                                        let needle_f64 = ensure_f64(builder, arg_vals[0]);
                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let needle_call = builder.ins().call(get_str_ptr_ref, &[needle_f64]);
                                        let needle_ptr = builder.inst_results(needle_call)[0];

                                        let index_of_func = extern_funcs.get("js_string_index_of")
                                            .ok_or_else(|| anyhow!("js_string_index_of not declared"))?;
                                        let func_ref = module.declare_func_in_func(*index_of_func, builder.func);
                                        let call = builder.ins().call(func_ref, &[str_ptr, needle_ptr]);
                                        let index_i32 = builder.inst_results(call)[0];
                                        // includes returns true if index >= 0
                                        let zero = builder.ins().iconst(types::I32, 0);
                                        let is_found = builder.ins().icmp(IntCC::SignedGreaterThanOrEqual, index_i32, zero);
                                        // Convert i8 bool to f64 (1.0 or 0.0)
                                        let extended = builder.ins().uextend(types::I32, is_found);
                                        let result_f64 = builder.ins().fcvt_from_sint(types::F64, extended);
                                        return Ok(result_f64);
                                    }
                                }
                                "split" => {
                                    if !arg_vals.is_empty() {
                                        // Extract delimiter string pointer from NaN-boxed value
                                        let delim_f64 = ensure_f64(builder, arg_vals[0]);
                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let delim_call = builder.ins().call(get_str_ptr_ref, &[delim_f64]);
                                        let delim_ptr = builder.inst_results(delim_call)[0];

                                        let split_func = extern_funcs.get("js_string_split")
                                            .ok_or_else(|| anyhow!("js_string_split not declared"))?;
                                        let func_ref = module.declare_func_in_func(*split_func, builder.func);
                                        let call = builder.ins().call(func_ref, &[str_ptr, delim_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the array pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                            .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                }
                                "startsWith" => {
                                    if !arg_vals.is_empty() {
                                        // Extract prefix string pointer from NaN-boxed value
                                        let prefix_f64 = ensure_f64(builder, arg_vals[0]);
                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let prefix_call = builder.ins().call(get_str_ptr_ref, &[prefix_f64]);
                                        let prefix_ptr = builder.inst_results(prefix_call)[0];

                                        let func = extern_funcs.get("js_string_starts_with")
                                            .ok_or_else(|| anyhow!("js_string_starts_with not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let call = builder.ins().call(func_ref, &[str_ptr, prefix_ptr]);
                                        let result_i32 = builder.inst_results(call)[0];
                                        let result_f64 = builder.ins().fcvt_from_sint(types::F64, result_i32);
                                        return Ok(result_f64);
                                    }
                                }
                                "endsWith" => {
                                    if !arg_vals.is_empty() {
                                        // Extract suffix string pointer from NaN-boxed value
                                        let suffix_f64 = ensure_f64(builder, arg_vals[0]);
                                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                        let suffix_call = builder.ins().call(get_str_ptr_ref, &[suffix_f64]);
                                        let suffix_ptr = builder.inst_results(suffix_call)[0];

                                        let func = extern_funcs.get("js_string_ends_with")
                                            .ok_or_else(|| anyhow!("js_string_ends_with not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let call = builder.ins().call(func_ref, &[str_ptr, suffix_ptr]);
                                        let result_i32 = builder.inst_results(call)[0];
                                        let result_f64 = builder.ins().fcvt_from_sint(types::F64, result_i32);
                                        return Ok(result_f64);
                                    }
                                }
                                "replace" => {
                                    if arg_vals.len() >= 2 {
                                        let pattern_ptr = ensure_i64(builder, arg_vals[0]);
                                        let replacement_ptr = ensure_i64(builder, arg_vals[1]);
                                        let replace_func = extern_funcs.get("js_string_replace_regex")
                                            .ok_or_else(|| anyhow!("js_string_replace_regex not declared"))?;
                                        let func_ref = module.declare_func_in_func(*replace_func, builder.func);
                                        let call = builder.ins().call(func_ref, &[str_ptr, pattern_ptr, replacement_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr));
                                    }
                                }
                                "padStart" | "padEnd" => {
                                    if !arg_vals.is_empty() {
                                        let func_name = if property == "padStart" { "js_string_pad_start" } else { "js_string_pad_end" };
                                        let func = extern_funcs.get(func_name)
                                            .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let target_len = {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        };
                                        let pad_str = if arg_vals.len() > 1 {
                                            ensure_i64(builder, arg_vals[1])
                                        } else {
                                            // Default pad string is " " (space)
                                            builder.ins().iconst(types::I64, 0)
                                        };
                                        let call = builder.ins().call(func_ref, &[str_ptr, target_len, pad_str]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result_ptr));
                                    }
                                }
                                "repeat" => {
                                    if !arg_vals.is_empty() {
                                        let func = extern_funcs.get("js_string_repeat")
                                            .ok_or_else(|| anyhow!("js_string_repeat not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let count = {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        };
                                        let call = builder.ins().call(func_ref, &[str_ptr, count]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                }
                                "charAt" => {
                                    if !arg_vals.is_empty() {
                                        let func = extern_funcs.get("js_string_char_at")
                                            .ok_or_else(|| anyhow!("js_string_char_at not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let index = {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        };
                                        let call = builder.ins().call(func_ref, &[str_ptr, index]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        // NaN-box the result string pointer
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                }
                                "charCodeAt" => {
                                    if !arg_vals.is_empty() {
                                        let func = extern_funcs.get("js_string_char_code_at")
                                            .ok_or_else(|| anyhow!("js_string_char_code_at not declared"))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);
                                        let index = {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        };
                                        let call = builder.ins().call(func_ref, &[str_ptr, index]);
                                        let result_f64 = builder.inst_results(call)[0];
                                        return Ok(result_f64);
                                    }
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }

                    // Handle array methods on any expression (e.g., data.content.find(...))
                    // These methods are called on expressions that may be arrays but aren't local variables
                    // Use dynamic versions that handle both JS handle arrays (from JSON) and native arrays
                    match property.as_str() {
                        "find" => {
                            if arg_vals.len() >= 1 {
                                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                // Use dynamic version that handles both JS handle and native arrays
                                let arr_f64 = ensure_f64(builder, arr_val);
                                let cb_ptr = ensure_i64(builder, arg_vals[0]);

                                let func = extern_funcs.get("js_dynamic_array_find")
                                    .ok_or_else(|| anyhow!("js_dynamic_array_find not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                let call = builder.ins().call(func_ref, &[arr_f64, cb_ptr]);
                                return Ok(builder.inst_results(call)[0]);
                            }
                        }
                        "findIndex" => {
                            if arg_vals.len() >= 1 {
                                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                // Use dynamic version that handles both JS handle and native arrays
                                let arr_f64 = ensure_f64(builder, arr_val);
                                let cb_ptr = ensure_i64(builder, arg_vals[0]);

                                let func = extern_funcs.get("js_dynamic_array_findIndex")
                                    .ok_or_else(|| anyhow!("js_dynamic_array_findIndex not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                let call = builder.ins().call(func_ref, &[arr_f64, cb_ptr]);
                                // Result is already f64 from dynamic version
                                return Ok(builder.inst_results(call)[0]);
                            }
                        }
                        "forEach" => {
                            if arg_vals.len() >= 1 {
                                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                let arr_ptr = ensure_i64(builder, arr_val);
                                let cb_ptr = ensure_i64(builder, arg_vals[0]);

                                let func = extern_funcs.get("js_array_forEach")
                                    .ok_or_else(|| anyhow!("js_array_forEach not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                builder.ins().call(func_ref, &[arr_ptr, cb_ptr]);
                                const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                                return Ok(builder.ins().f64const(f64::from_bits(TAG_UNDEFINED))); // forEach returns undefined
                            }
                        }
                        "map" => {
                            if arg_vals.len() >= 1 {
                                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                let arr_ptr = ensure_i64(builder, arr_val);
                                let cb_ptr = ensure_i64(builder, arg_vals[0]);

                                let func = extern_funcs.get("js_array_map")
                                    .ok_or_else(|| anyhow!("js_array_map not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                let call = builder.ins().call(func_ref, &[arr_ptr, cb_ptr]);
                                let result = builder.inst_results(call)[0];
                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result));
                            }
                        }
                        "filter" => {
                            if arg_vals.len() >= 1 {
                                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                let arr_ptr = ensure_i64(builder, arr_val);
                                let cb_ptr = ensure_i64(builder, arg_vals[0]);

                                let func = extern_funcs.get("js_array_filter")
                                    .ok_or_else(|| anyhow!("js_array_filter not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                let call = builder.ins().call(func_ref, &[arr_ptr, cb_ptr]);
                                let result = builder.inst_results(call)[0];
                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result));
                            }
                        }
                        "includes" => {
                            if arg_vals.len() >= 1 {
                                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                let arr_ptr = ensure_i64(builder, arr_val);
                                let value = ensure_f64(builder, arg_vals[0]);

                                let func = extern_funcs.get("js_array_includes_f64")
                                    .ok_or_else(|| anyhow!("js_array_includes_f64 not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                let call = builder.ins().call(func_ref, &[arr_ptr, value]);
                                let result_i32 = builder.inst_results(call)[0];
                                return Ok(builder.ins().fcvt_from_sint(types::F64, result_i32));
                            }
                        }
                        "slice" => {
                            // array.slice(start, end?) - returns a new array
                            let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                            // Extract the array pointer from NaN-boxed value if needed
                            let arr_ptr = if builder.func.dfg.value_type(arr_val) == types::F64 {
                                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                                let call = builder.ins().call(get_ptr_ref, &[arr_val]);
                                builder.inst_results(call)[0]
                            } else {
                                arr_val
                            };

                            // Get start index
                            let start_i32 = if !arg_vals.is_empty() {
                                let start_f64 = ensure_f64(builder, arg_vals[0]);
                                builder.ins().fcvt_to_sint(types::I32, start_f64)
                            } else {
                                builder.ins().iconst(types::I32, 0)
                            };

                            // Get end index
                            let end_i32 = if arg_vals.len() > 1 {
                                let end_f64 = ensure_f64(builder, arg_vals[1]);
                                builder.ins().fcvt_to_sint(types::I32, end_f64)
                            } else {
                                builder.ins().iconst(types::I32, i32::MAX as i64)
                            };

                            let func = extern_funcs.get("js_array_slice")
                                .ok_or_else(|| anyhow!("js_array_slice not declared"))?;
                            let func_ref = module.declare_func_in_func(*func, builder.func);
                            let call = builder.ins().call(func_ref, &[arr_ptr, start_i32, end_i32]);
                            let result_ptr = builder.inst_results(call)[0];
                            // NaN-box the result array pointer
                            let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                            let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                            return Ok(builder.inst_results(nanbox_call)[0]);
                        }
                        // Promise methods
                        "catch" => {
                            if arg_vals.len() >= 1 {
                                let promise_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                let promise_ptr = ensure_i64(builder, promise_val);
                                let on_rejected = ensure_i64(builder, arg_vals[0]);

                                let func = extern_funcs.get("js_promise_catch")
                                    .ok_or_else(|| anyhow!("js_promise_catch not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                let call = builder.ins().call(func_ref, &[promise_ptr, on_rejected]);
                                let result = builder.inst_results(call)[0];
                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result));
                            }
                        }
                        "then" => {
                            // .then(onFulfilled) or .then(onFulfilled, onRejected)
                            if arg_vals.len() >= 1 {
                                let promise_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                let promise_ptr = ensure_i64(builder, promise_val);
                                let on_fulfilled = ensure_i64(builder, arg_vals[0]);
                                let on_rejected = if arg_vals.len() >= 2 {
                                    ensure_i64(builder, arg_vals[1])
                                } else {
                                    builder.ins().iconst(types::I64, 0) // null
                                };

                                let func = extern_funcs.get("js_promise_then")
                                    .ok_or_else(|| anyhow!("js_promise_then not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                let call = builder.ins().call(func_ref, &[promise_ptr, on_fulfilled, on_rejected]);
                                let result = builder.inst_results(call)[0];
                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result));
                            }
                        }
                        "finally" => {
                            if arg_vals.len() >= 1 {
                                let promise_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                                let promise_ptr = ensure_i64(builder, promise_val);
                                let on_finally = ensure_i64(builder, arg_vals[0]);

                                let func = extern_funcs.get("js_promise_finally")
                                    .ok_or_else(|| anyhow!("js_promise_finally not declared"))?;
                                let func_ref = module.declare_func_in_func(*func, builder.func);
                                let call = builder.ins().call(func_ref, &[promise_ptr, on_finally]);
                                let result = builder.inst_results(call)[0];
                                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result));
                            }
                        }
                        _ => {}
                    }

                    // Fallback: If js_native_call_method is available (JS runtime enabled),
                    // use dynamic JS interop for unknown method calls
                    if extern_funcs.contains_key("js_native_call_method") {
                        // Compile object expression
                        let obj_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                        // js_native_call_method expects f64 for object, ensure we have the right type
                        let obj_val_type = builder.func.dfg.value_type(obj_val_raw);
                        let obj_val = if obj_val_type == types::I64 {
                            builder.ins().bitcast(types::F64, MemFlags::new(), obj_val_raw)
                        } else {
                            obj_val_raw
                        };

                        // Create string constant for method name
                        let name_bytes = property.as_bytes();
                        let name_len = name_bytes.len();

                        let name_data_id = module.declare_data(
                            &format!("__js_method_{}_{}", property, next_js_data_id()),
                            Linkage::Local,
                            false,
                            false,
                        )?;
                        let mut data_desc = cranelift_module::DataDescription::new();
                        data_desc.define(name_bytes.to_vec().into_boxed_slice());
                        module.define_data(name_data_id, &data_desc)?;

                        let name_gv = module.declare_data_in_func(name_data_id, builder.func);
                        let name_ptr = builder.ins().global_value(types::I64, name_gv);
                        let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

                        // Build arguments array on stack using already-compiled arg_vals
                        let args_count = arg_vals.len();
                        if args_count > 0 {
                            let stack_slot = builder.create_sized_stack_slot(StackSlotData::new(
                                StackSlotKind::ExplicitSlot,
                                (args_count * 8) as u32,
                                8,
                            ));
                            let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                            for (i, &arg_val_raw) in arg_vals.iter().enumerate() {
                                // Ensure argument is f64 for JS interop
                                let arg_val_type = builder.func.dfg.value_type(arg_val_raw);
                                let arg_val = if arg_val_type == types::I64 {
                                    builder.ins().bitcast(types::F64, MemFlags::new(), arg_val_raw)
                                } else {
                                    arg_val_raw
                                };
                                let offset = (i * 8) as i32;
                                builder.ins().store(MemFlags::new(), arg_val, args_ptr, offset);
                            }

                            let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                            let call_func = extern_funcs.get("js_native_call_method").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[obj_val, name_ptr, name_len_val, args_ptr, args_count_val]);
                            return Ok(builder.inst_results(call)[0]);
                        } else {
                            let null_ptr = builder.ins().iconst(types::I64, 0);
                            let zero_count = builder.ins().iconst(types::I64, 0);

                            let call_func = extern_funcs.get("js_native_call_method").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[obj_val, name_ptr, name_len_val, null_ptr, zero_count]);
                            return Ok(builder.inst_results(call)[0]);
                        }
                    }

                    Err(anyhow!("Unsupported method call: {}", property))
                }
                Expr::LocalGet(id) => {
                    // Calling a closure stored in a variable
                    if let Some(info) = locals.get(id) {
                        // If a variable is being called as a function, it must be a closure.
                        // Always use js_closure_call* for calling local variables.
                        // This handles:
                        // - Explicitly typed function parameters (is_closure=true)
                        // - Pointer-typed variables (is_pointer=true)
                        // - Captured variables in closures where type info was lost (is_closure=false, is_pointer=false)
                        //   e.g., `resolve` captured from Promise executor
                        {
                            // Get the closure pointer - ensure it's i64
                            let closure_val = builder.use_var(info.var);
                            let closure_ptr = ensure_i64(builder, closure_val);

                            // Select the appropriate js_closure_call* function based on arg count
                            let call_func_name = match arg_vals.len() {
                                0 => "js_closure_call0",
                                1 => "js_closure_call1",
                                2 => "js_closure_call2",
                                3 => "js_closure_call3",
                                4 => "js_closure_call4",
                                n => return Err(anyhow!("Closure calls with {} arguments not supported (max 4)", n)),
                            };

                            let call_func = extern_funcs.get(call_func_name)
                                .ok_or_else(|| anyhow!("{} not declared", call_func_name))?;
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);

                            // Build call args: [closure_ptr, ...args]
                            // Closure call functions expect all args as f64, so convert as needed
                            let mut call_args = vec![closure_ptr];
                            for &arg_val in arg_vals.iter() {
                                let arg_type = builder.func.dfg.value_type(arg_val);
                                let arg_f64 = if arg_type == types::I64 {
                                    builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), arg_val)
                                } else if arg_type == types::I32 {
                                    builder.ins().fcvt_from_sint(types::F64, arg_val)
                                } else {
                                    arg_val
                                };
                                call_args.push(arg_f64);
                            }

                            let call = builder.ins().call(call_ref, &call_args);
                            return Ok(builder.inst_results(call)[0]);
                        }
                    }
                    Err(anyhow!("Unsupported callee: LocalGet with unknown variable"))
                }
                Expr::ExternFuncRef { name: func_name, param_types, return_type } => {
                    // Calling an imported function by name
                    // First check if it's already in extern_funcs (runtime functions)
                    if let Some(&func_id) = extern_funcs.get(func_name.as_str()) {
                        let func_ref = module.declare_func_in_func(func_id, builder.func);

                        // Get the function signature to check parameter types
                        let sig = module.declarations().get_function_decl(func_id);
                        let sig = sig.signature.clone();

                        // Convert arguments to match expected parameter types
                        let mut converted_args = Vec::with_capacity(arg_vals.len());
                        for (i, arg_val) in arg_vals.iter().enumerate() {
                            if i < sig.params.len() {
                                let expected_type = sig.params[i].value_type;
                                let actual_type = builder.func.dfg.value_type(*arg_val);
                                if expected_type == types::I64 && actual_type == types::F64 {
                                    // Bitcast f64 to i64 (for handle/pointer arguments)
                                    converted_args.push(builder.ins().bitcast(types::I64, MemFlags::new(), *arg_val));
                                } else if expected_type == types::F64 && actual_type == types::I64 {
                                    // Bitcast i64 to f64
                                    converted_args.push(builder.ins().bitcast(types::F64, MemFlags::new(), *arg_val));
                                } else if expected_type == types::F64 && actual_type == types::I32 {
                                    // i32 (from loop optimization) -> f64
                                    converted_args.push(builder.ins().fcvt_from_sint(types::F64, *arg_val));
                                } else if expected_type == types::I64 && actual_type == types::I32 {
                                    // i32 (from loop optimization) -> i64
                                    converted_args.push(builder.ins().sextend(types::I64, *arg_val));
                                } else {
                                    converted_args.push(*arg_val);
                                }
                            } else {
                                converted_args.push(*arg_val);
                            }
                        }

                        // Pad arguments if function expects more params than we have
                        let expected_param_count = sig.params.len();
                        while converted_args.len() < expected_param_count {
                            // Determine the type expected for this parameter
                            let expected_type = sig.params[converted_args.len()].value_type;
                            if expected_type == types::I64 {
                                converted_args.push(builder.ins().iconst(types::I64, 0));
                            } else {
                                converted_args.push(builder.ins().f64const(f64::NAN));
                            }
                        }
                        // Truncate if we have too many
                        converted_args.truncate(expected_param_count);

                        let call = builder.ins().call(func_ref, &converted_args);
                        let results = builder.inst_results(call);

                        // Handle functions that return void (like clearInterval)
                        if results.is_empty() {
                            // Return undefined (0.0 for f64 representation)
                            return Ok(builder.ins().f64const(0.0));
                        }

                        let result = results[0];

                        // Some functions return i64 (like setTimeout which returns Promise*)
                        // Need to properly NaN-box handles and strings for uniform expression type handling
                        let result_type = builder.func.dfg.value_type(result);
                        if result_type == types::I64 {
                            // HTTP server/request handle functions need NaN-boxing with POINTER_TAG
                            if func_name == "js_http_server_create" || func_name == "js_http_server_accept_v2" {
                                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                let nanbox_call = builder.ins().call(nanbox_ref, &[result]);
                                return Ok(builder.inst_results(nanbox_call)[0]);
                            }
                            // HTTP string-returning functions need NaN-boxing with STRING_TAG
                            if func_name.starts_with("js_http_request_method")
                                || func_name.starts_with("js_http_request_path")
                                || func_name.starts_with("js_http_request_query")
                                || func_name.starts_with("js_http_request_body")
                                || func_name.starts_with("js_http_request_content_type")
                                || func_name.starts_with("js_http_request_header")
                                || func_name == "js_http_request_query_all"
                                || func_name == "js_http_request_headers_all"
                                || func_name == "js_http_respond_status_text"
                            {
                                let nanbox_func = extern_funcs.get("js_nanbox_string")
                                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                let nanbox_call = builder.ins().call(nanbox_ref, &[result]);
                                return Ok(builder.inst_results(nanbox_call)[0]);
                            }
                            // Other i64 returns (like setTimeout returning Promise*) - bitcast
                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result));
                        }
                        return Ok(result);
                    }

                    // For TypeScript module imports, call the exported wrapper function
                    // which has a uniform ABI: (i64, f64*) -> f64
                    // The wrapper handles NaN-boxing for pointer returns
                    let wrapper_name = format!("__wrapper_{}", func_name);

                    // Build the wrapper signature: first param is i64 (closure_ptr, ignored),
                    // remaining params are all f64, return is always f64
                    // IMPORTANT: Use the full function signature (not call-site arity) to ensure
                    // functions with optional parameters always have a consistent signature.
                    // Priority: 1) imported_func_param_counts (from cross-module compile info)
                    //          2) param_types.len() (from HIR type info)
                    //          3) arg_vals.len() (fallback to call-site arity)
                    let initial_param_count = if let Some(&count) = imported_func_param_counts.get(func_name) {
                        // Use the registered full param count from the exporting module
                        count
                    } else if !param_types.is_empty() {
                        // Use param_types from ExternFuncRef
                        param_types.len()
                    } else {
                        // Fallback for builtins without type info - use call-site arity
                        arg_vals.len()
                    };
                    let mut sig = module.make_signature();
                    sig.params.push(AbiParam::new(types::I64)); // closure_ptr (will be 0)
                    for _ in 0..initial_param_count {
                        sig.params.push(AbiParam::new(types::F64));
                    }
                    sig.returns.push(AbiParam::new(types::F64)); // always f64 return

                    // Declare the wrapper function as imported
                    // If it's already declared with a different signature (e.g., more params),
                    // find the existing declaration and use its signature instead.
                    let (func_id, full_param_count) = match module.declare_function(
                        &wrapper_name,
                        cranelift_module::Linkage::Import,
                        &sig,
                    ) {
                        Ok(id) => (id, initial_param_count),
                        Err(e) => {
                            // Check if this is an incompatible declaration error
                            let err_str = format!("{:?}", e);
                            let err_msg = e.to_string();
                            let is_incompatible = err_str.to_lowercase().contains("incompatible") ||
                                                   err_msg.to_lowercase().contains("incompatible") ||
                                                   matches!(e, cranelift_module::ModuleError::IncompatibleDeclaration(_));
                            if is_incompatible {
                                // Find existing function by name and use its signature
                                let mut found = None;
                                for (id, decl) in module.declarations().get_functions() {
                                    if decl.name.as_deref() == Some(&wrapper_name) {
                                        // Found existing declaration - get its param count
                                        let existing_param_count = decl.signature.params.len() - 1; // -1 for closure_ptr
                                        found = Some((id, existing_param_count));
                                        break;
                                    }
                                }
                                match found {
                                    Some((id, count)) => (id, count),
                                    None => return Err(anyhow!("Failed to declare wrapper function {}: incompatible signature but no existing declaration found: {}", wrapper_name, e)),
                                }
                            } else {
                                return Err(anyhow!("Failed to declare wrapper function {}: {}", wrapper_name, e));
                            }
                        }
                    };

                    let func_ref = module.declare_func_in_func(func_id, builder.func);

                    // Build call args: [0 (closure_ptr), ...args as f64]
                    let mut call_args = vec![builder.ins().iconst(types::I64, 0)];
                    for &arg_val in arg_vals.iter() {
                        let arg_type = builder.func.dfg.value_type(arg_val);
                        let arg_f64 = if arg_type == types::I64 {
                            // Properly NaN-box i64 pointers for cross-module calls
                            // (simple bitcast doesn't add the NaN-box tag bits)
                            let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                            let call = builder.ins().call(nanbox_ref, &[arg_val]);
                            builder.inst_results(call)[0]
                        } else {
                            arg_val
                        };
                        call_args.push(arg_f64);
                    }

                    // Pad missing optional arguments with undefined
                    // This ensures the call matches the full function signature
                    const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                    while call_args.len() < full_param_count + 1 { // +1 for closure_ptr
                        call_args.push(builder.ins().f64const(f64::from_bits(TAG_UNDEFINED)));
                    }

                    // Truncate if we have too many arguments (handles variadic-like patterns)
                    // This can happen when the function was already declared with fewer params
                    call_args.truncate(full_param_count + 1);

                    let call = builder.ins().call(func_ref, &call_args);
                    return Ok(builder.inst_results(call)[0]);
                }
                // Handle optional chaining method calls (e.g., str?.substring(0, 10))
                // The callee is a Conditional { condition: obj == null, then: undefined, else: PropertyGet }
                Expr::Conditional { condition: _, then_expr: _, else_expr } => {
                    // Check if the else_expr is a PropertyGet for a string method
                    if let Expr::PropertyGet { object, property } = else_expr.as_ref() {
                        match property.as_str() {
                            "substring" | "slice" | "trim" | "toLowerCase" | "toUpperCase" |
                            "indexOf" | "includes" | "split" | "replace" | "startsWith" |
                            "endsWith" | "padStart" | "padEnd" | "repeat" | "charAt" | "charCodeAt" => {
                                // Compile the object to get the string value
                                let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;

                                // Extract string pointer using unified function
                                let str_ptr = if builder.func.dfg.value_type(str_val) == types::F64 {
                                    let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                        .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                    let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                    let call = builder.ins().call(get_str_ptr_ref, &[str_val]);
                                    builder.inst_results(call)[0]
                                } else {
                                    str_val
                                };

                                match property.as_str() {
                                    "substring" | "slice" => {
                                        let func_name = if property == "substring" { "js_string_substring" } else { "js_string_slice" };
                                        let func = extern_funcs.get(func_name)
                                            .ok_or_else(|| anyhow!("{} not declared", func_name))?;
                                        let func_ref = module.declare_func_in_func(*func, builder.func);

                                        let start = if !arg_vals.is_empty() {
                                            let arg_f64 = ensure_f64(builder, arg_vals[0]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, 0)
                                        };
                                        let end = if arg_vals.len() > 1 {
                                            let arg_f64 = ensure_f64(builder, arg_vals[1]);
                                            builder.ins().fcvt_to_sint(types::I32, arg_f64)
                                        } else {
                                            builder.ins().iconst(types::I32, i32::MAX as i64)
                                        };

                                        let call = builder.ins().call(func_ref, &[str_ptr, start, end]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "trim" => {
                                        let trim_func = extern_funcs.get("js_string_trim")
                                            .ok_or_else(|| anyhow!("js_string_trim not declared"))?;
                                        let func_ref = module.declare_func_in_func(*trim_func, builder.func);
                                        let call = builder.ins().call(func_ref, &[str_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "toLowerCase" => {
                                        let lower_func = extern_funcs.get("js_string_to_lower_case")
                                            .ok_or_else(|| anyhow!("js_string_to_lower_case not declared"))?;
                                        let func_ref = module.declare_func_in_func(*lower_func, builder.func);
                                        let call = builder.ins().call(func_ref, &[str_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    "toUpperCase" => {
                                        let upper_func = extern_funcs.get("js_string_to_upper_case")
                                            .ok_or_else(|| anyhow!("js_string_to_upper_case not declared"))?;
                                        let func_ref = module.declare_func_in_func(*upper_func, builder.func);
                                        let call = builder.ins().call(func_ref, &[str_ptr]);
                                        let result_ptr = builder.inst_results(call)[0];
                                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                        let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
                                        return Ok(builder.inst_results(nanbox_call)[0]);
                                    }
                                    _ => {
                                        // Other string methods - fall through to default handling
                                    }
                                }
                            }
                            _ => {
                                // Not a string method - fall through
                            }
                        }
                    }
                    // Fall through to default handling
                    if extern_funcs.contains_key("js_native_call_value") {
                        // Compile the callee expression to get a JS function value
                        let func_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callee, this_ctx)?;
                        // js_native_call_value expects f64, ensure we have the right type
                        let func_val_type = builder.func.dfg.value_type(func_val_raw);
                        let func_val = if func_val_type == types::I64 {
                            builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), func_val_raw)
                        } else {
                            func_val_raw
                        };

                        // Build args array if needed
                        if !arg_vals.is_empty() {
                            let args_count = arg_vals.len();
                            let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                                cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                                (args_count * 8) as u32,
                                8,
                            ));
                            let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                            for (i, &arg_val_raw) in arg_vals.iter().enumerate() {
                                // Ensure argument is f64 for JS interop
                                let arg_val_type = builder.func.dfg.value_type(arg_val_raw);
                                let arg_val = if arg_val_type == types::I64 {
                                    builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), arg_val_raw)
                                } else {
                                    arg_val_raw
                                };
                                let offset = (i * 8) as i32;
                                builder.ins().store(cranelift_codegen::ir::MemFlags::new(), arg_val, args_ptr, offset);
                            }

                            let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                            let call_func = extern_funcs.get("js_native_call_value").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[func_val, args_ptr, args_count_val]);
                            return Ok(builder.inst_results(call)[0]);
                        } else {
                            let null_ptr = builder.ins().iconst(types::I64, 0);
                            let zero_count = builder.ins().iconst(types::I64, 0);

                            let call_func = extern_funcs.get("js_native_call_value").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[func_val, null_ptr, zero_count]);
                            return Ok(builder.inst_results(call)[0]);
                        }
                    }
                    Err(anyhow!("Unsupported callee expression: Conditional"))
                }
                // Fallback: If js_native_call_value is available (JS runtime enabled),
                // try to compile the callee as an expression and call it as a JS function
                _ => {
                    if extern_funcs.contains_key("js_native_call_value") {
                        // Compile the callee expression to get a JS function value
                        let func_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callee, this_ctx)?;
                        // js_native_call_value expects f64, ensure we have the right type
                        let func_val_type = builder.func.dfg.value_type(func_val_raw);
                        let func_val = if func_val_type == types::I64 {
                            builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), func_val_raw)
                        } else {
                            func_val_raw
                        };

                        // Build args array if needed
                        if !arg_vals.is_empty() {
                            let args_count = arg_vals.len();
                            let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                                cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                                (args_count * 8) as u32,
                                8,
                            ));
                            let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                            for (i, &arg_val_raw) in arg_vals.iter().enumerate() {
                                // Ensure argument is f64 for JS interop
                                let arg_val_type = builder.func.dfg.value_type(arg_val_raw);
                                let arg_val = if arg_val_type == types::I64 {
                                    builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), arg_val_raw)
                                } else {
                                    arg_val_raw
                                };
                                let offset = (i * 8) as i32;
                                builder.ins().store(cranelift_codegen::ir::MemFlags::new(), arg_val, args_ptr, offset);
                            }

                            let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                            let call_func = extern_funcs.get("js_native_call_value").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[func_val, args_ptr, args_count_val]);
                            return Ok(builder.inst_results(call)[0]);
                        } else {
                            let null_ptr = builder.ins().iconst(types::I64, 0);
                            let zero_count = builder.ins().iconst(types::I64, 0);

                            let call_func = extern_funcs.get("js_native_call_value").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[func_val, null_ptr, zero_count]);
                            return Ok(builder.inst_results(call)[0]);
                        }
                    }
                    Err(anyhow!("Unsupported callee expression"))
                }
            }
        }
        Expr::CallSpread { callee, args, .. } => {
            // Handle function calls with spread arguments
            // For now, we support the case where spread is used to pass array elements as individual arguments

            // Count how many spread args we have
            let spread_count = args.iter().filter(|a| matches!(a, CallArg::Spread(_))).count();
            let regular_args: Vec<&Expr> = args.iter().filter_map(|a| {
                if let CallArg::Expr(e) = a { Some(e) } else { None }
            }).collect();

            // Get the function being called
            match callee.as_ref() {
                Expr::FuncRef(func_id) => {
                    // Get the Cranelift function ID first to get the actual signature
                    let clif_func_id = func_ids.get(func_id)
                        .ok_or_else(|| anyhow!("Unknown function ID: {}", func_id))?;

                    // Get expected parameter count from the actual Cranelift signature
                    let actual_sig = module.declarations().get_function_decl(*clif_func_id);
                    let expected_params = actual_sig.signature.params.len();

                    // Also get HIR param types for type conversion
                    let param_types = func_param_types.get(func_id);

                    if spread_count == 1 && regular_args.is_empty() {
                        // Single spread argument: fn(...arr)
                        // We need to unpack the array at runtime

                        // Find the spread expression
                        let spread_expr = args.iter().find_map(|a| {
                            if let CallArg::Spread(e) = a { Some(e) } else { None }
                        }).unwrap();

                        // Compile the spread array
                        let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, spread_expr, this_ctx)?;
                        let arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arr_val);

                        // Get array elements
                        let get_func = extern_funcs.get("js_array_get_f64")
                            .ok_or_else(|| anyhow!("js_array_get_f64 not declared"))?;
                        let get_ref = module.declare_func_in_func(*get_func, builder.func);

                        // Extract elements from the array based on expected params from actual signature
                        let mut arg_vals = Vec::new();
                        for i in 0..expected_params {
                            let idx = builder.ins().iconst(types::I32, i as i64);
                            let call = builder.ins().call(get_ref, &[arr_ptr, idx]);
                            let elem = builder.inst_results(call)[0];

                            // Convert f64 to expected parameter type (i64 for strings/objects/arrays)
                            // The f64 value may be NaN-boxed, so extract the raw pointer
                            let converted = if let Some(param_types) = param_types {
                                if i < param_types.len() && param_types[i] == types::I64 {
                                    // Parameter expects i64 (string/array/object), extract from NaN-boxed f64
                                    let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                                        .expect("js_nanbox_get_pointer not declared");
                                    let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                                    let call = builder.ins().call(get_ptr_ref, &[elem]);
                                    builder.inst_results(call)[0]
                                } else {
                                    elem
                                }
                            } else {
                                elem
                            };
                            arg_vals.push(converted);
                        }

                        // Call the function with unpacked arguments
                        let func_ref = module.declare_func_in_func(*clif_func_id, builder.func);

                        // Get expected parameter count and types from the actual function signature
                        let actual_sig = module.declarations().get_function_decl(*clif_func_id);
                        let expected_param_count = actual_sig.signature.params.len();

                        // Convert arguments to match expected types
                        let mut final_args: Vec<Value> = arg_vals.iter().enumerate()
                            .map(|(i, &val)| {
                                if i < actual_sig.signature.params.len() {
                                    let expected_type = actual_sig.signature.params[i].value_type;
                                    let actual_type = builder.func.dfg.value_type(val);
                                    if expected_type == types::I64 && actual_type == types::F64 {
                                        builder.ins().bitcast(types::I64, MemFlags::new(), val)
                                    } else if expected_type == types::F64 && actual_type == types::I64 {
                                        builder.ins().bitcast(types::F64, MemFlags::new(), val)
                                    } else {
                                        val
                                    }
                                } else {
                                    val
                                }
                            })
                            .collect();

                        // Pad arguments to match expected count with correct types
                        while final_args.len() < expected_param_count {
                            let expected_type = actual_sig.signature.params[final_args.len()].value_type;
                            if expected_type == types::I64 {
                                final_args.push(builder.ins().iconst(types::I64, 0));
                            } else {
                                final_args.push(builder.ins().f64const(f64::NAN));
                            }
                        }
                        final_args.truncate(expected_param_count);

                        let call = builder.ins().call(func_ref, &final_args);
                        return Ok(builder.inst_results(call)[0]);
                    }

                    // For mixed regular + spread args, or multiple spreads, not yet supported
                    return Err(anyhow!("Complex spread call patterns not yet supported"));
                }
                Expr::PropertyGet { object, property } => {
                    // Method call with spread: obj.method(...arr)

                    // Special handling for console.log/error/warn with spread
                    // These are built-in methods that need special treatment since console is a GlobalGet
                    if matches!(object.as_ref(), Expr::GlobalGet(_)) &&
                       (property == "log" || property == "error" || property == "warn") {
                        // Build a runtime array with all arguments, then call js_console_*_spread
                        let spread_func_name = match property.as_str() {
                            "log" => "js_console_log_spread",
                            "error" => "js_console_error_spread",
                            "warn" => "js_console_warn_spread",
                            _ => unreachable!(),
                        };

                        if let Some(spread_func) = extern_funcs.get(spread_func_name) {
                            // Allocate a runtime array to hold all arguments
                            let initial_capacity = (regular_args.len() + 8) as i64;
                            let alloc_func = extern_funcs.get("js_array_alloc")
                                .ok_or_else(|| anyhow!("js_array_alloc not declared"))?;
                            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                            let capacity = builder.ins().iconst(types::I32, initial_capacity);
                            let alloc_call = builder.ins().call(alloc_ref, &[capacity]);
                            let initial_arr_ptr = builder.inst_results(alloc_call)[0];

                            // Track the array pointer (may change during push operations)
                            let arr_var = Variable::new(next_temp_var_id());
                            builder.declare_var(arr_var, types::I64);
                            builder.def_var(arr_var, initial_arr_ptr);

                            // Get function references we'll need
                            let push_func = extern_funcs.get("js_array_push_f64")
                                .ok_or_else(|| anyhow!("js_array_push_f64 not declared"))?;
                            let push_ref = module.declare_func_in_func(*push_func, builder.func);

                            let length_func = extern_funcs.get("js_array_length")
                                .ok_or_else(|| anyhow!("js_array_length not declared"))?;
                            let length_ref = module.declare_func_in_func(*length_func, builder.func);

                            let get_func = extern_funcs.get("js_array_get_f64")
                                .ok_or_else(|| anyhow!("js_array_get_f64 not declared"))?;
                            let get_ref = module.declare_func_in_func(*get_func, builder.func);

                            // Get nanbox_string function for string values
                            let nanbox_string_func = extern_funcs.get("js_nanbox_string")
                                .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                            let nanbox_string_ref = module.declare_func_in_func(*nanbox_string_func, builder.func);

                            // Helper to check if an expression produces a string
                            fn is_string_expr_for_spread(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                match expr {
                                    Expr::String(_) => true,
                                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) => true,
                                    Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                                    Expr::PathExtname(_) | Expr::PathResolve(_) | Expr::JsonStringify(_) => true,
                                    Expr::CryptoRandomBytes(_) | Expr::CryptoRandomUUID |
                                    Expr::CryptoSha256(_) | Expr::CryptoMd5(_) => true,
                                    Expr::DateToISOString(_) => true,
                                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                    // Binary Add that produces a string (template literals)
                                    Expr::Binary { op: BinaryOp::Add, left, right } => {
                                        is_string_expr_for_spread(left, locals) || is_string_expr_for_spread(right, locals)
                                    }
                                    _ => false,
                                }
                            }

                            // Process arguments in order (regular args and spreads)
                            for arg in args {
                                match arg {
                                    CallArg::Expr(expr) => {
                                        // Regular argument - compile and push
                                        let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
                                        // For strings, we need to NaN-box the pointer with STRING_TAG
                                        // The value might be i64 (from closure params) or f64 (from string literals)
                                        let val_f64 = if is_string_expr_for_spread(expr, locals) {
                                            let ptr = ensure_i64(builder, val);
                                            let call = builder.ins().call(nanbox_string_ref, &[ptr]);
                                            builder.inst_results(call)[0]
                                        } else {
                                            ensure_f64(builder, val)
                                        };
                                        let arr_ptr = builder.use_var(arr_var);
                                        let push_call = builder.ins().call(push_ref, &[arr_ptr, val_f64]);
                                        let new_arr_ptr = builder.inst_results(push_call)[0];
                                        builder.def_var(arr_var, new_arr_ptr);
                                    }
                                    CallArg::Spread(spread_expr) => {
                                        // Spread argument - iterate and push each element
                                        let spread_arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, spread_expr, this_ctx)?;
                                        // Array might be i64 (from closure params) or f64 (from other sources)
                                        let spread_arr_ptr = ensure_i64(builder, spread_arr_val);

                                        // Get length of spread array
                                        let len_call = builder.ins().call(length_ref, &[spread_arr_ptr]);
                                        let spread_len = builder.inst_results(len_call)[0];

                                        // Create loop to iterate over spread array
                                        let loop_header = builder.create_block();
                                        let loop_body = builder.create_block();
                                        let loop_exit = builder.create_block();

                                        // Initialize loop counter
                                        let idx_var = Variable::new(next_temp_var_id());
                                        builder.declare_var(idx_var, types::I32);
                                        let zero = builder.ins().iconst(types::I32, 0);
                                        builder.def_var(idx_var, zero);

                                        // Jump to loop header
                                        builder.ins().jump(loop_header, &[]);

                                        // Loop header: check if idx < length
                                        builder.switch_to_block(loop_header);
                                        let idx = builder.use_var(idx_var);
                                        let cmp = builder.ins().icmp(IntCC::SignedLessThan, idx, spread_len);
                                        builder.ins().brif(cmp, loop_body, &[], loop_exit, &[]);

                                        // Loop body: get element and push it
                                        builder.switch_to_block(loop_body);
                                        let idx = builder.use_var(idx_var);
                                        let get_call = builder.ins().call(get_ref, &[spread_arr_ptr, idx]);
                                        let elem_val = builder.inst_results(get_call)[0];

                                        let arr_ptr = builder.use_var(arr_var);
                                        let push_call = builder.ins().call(push_ref, &[arr_ptr, elem_val]);
                                        let new_arr_ptr = builder.inst_results(push_call)[0];
                                        builder.def_var(arr_var, new_arr_ptr);

                                        // Increment counter
                                        let idx = builder.use_var(idx_var);
                                        let one = builder.ins().iconst(types::I32, 1);
                                        let next_idx = builder.ins().iadd(idx, one);
                                        builder.def_var(idx_var, next_idx);

                                        // Jump back to header
                                        builder.ins().jump(loop_header, &[]);

                                        // Seal the loop blocks
                                        builder.seal_block(loop_header);
                                        builder.seal_block(loop_body);
                                        builder.seal_block(loop_exit);

                                        // Continue from loop exit
                                        builder.switch_to_block(loop_exit);
                                    }
                                }
                            }

                            // Call the spread function with the built array
                            let final_arr_ptr = builder.use_var(arr_var);
                            let spread_func_ref = module.declare_func_in_func(*spread_func, builder.func);
                            builder.ins().call(spread_func_ref, &[final_arr_ptr]);
                            return Ok(builder.ins().f64const(0.0));
                        }
                    }

                    // Use js_native_call_value runtime function for dynamic dispatch
                    if spread_count == 1 && regular_args.is_empty() {
                        // Compile the object (receiver)
                        let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;

                        // Find the spread expression
                        let spread_expr = args.iter().find_map(|a| {
                            if let CallArg::Spread(e) = a { Some(e) } else { None }
                        }).unwrap();

                        // Compile the spread array
                        let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, spread_expr, this_ctx)?;
                        let arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arr_val);

                        // Get the method from the object
                        let obj_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), obj_val);

                        // Create a string for the method name
                        let method_bytes = property.as_bytes();
                        let method_len = method_bytes.len();
                        let method_slot = builder.create_sized_stack_slot(StackSlotData::new(
                            StackSlotKind::ExplicitSlot,
                            method_len as u32,
                            0,
                        ));
                        for (i, &byte) in method_bytes.iter().enumerate() {
                            let byte_val = builder.ins().iconst(types::I8, byte as i64);
                            builder.ins().stack_store(byte_val, method_slot, i as i32);
                        }
                        let method_addr = builder.ins().stack_addr(types::I64, method_slot, 0);
                        let str_func = extern_funcs.get("js_string_from_bytes")
                            .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
                        let str_ref = module.declare_func_in_func(*str_func, builder.func);
                        let method_len_val = builder.ins().iconst(types::I32, method_len as i64);
                        let str_call = builder.ins().call(str_ref, &[method_addr, method_len_val]);
                        let method_str = builder.inst_results(str_call)[0];

                        // Get the method function from the object
                        // Ensure both arguments are i64
                        let obj_ptr_i64 = ensure_i64(builder, obj_ptr);
                        let method_str_i64 = ensure_i64(builder, method_str);
                        let get_field_func = extern_funcs.get("js_object_get_field_by_name_f64")
                            .ok_or_else(|| anyhow!("js_object_get_field_by_name_f64 not declared"))?;
                        let get_field_ref = module.declare_func_in_func(*get_field_func, builder.func);
                        let get_call = builder.ins().call(get_field_ref, &[obj_ptr_i64, method_str_i64]);
                        let method_val = builder.inst_results(get_call)[0];

                        // Get the array length
                        let len_func = extern_funcs.get("js_array_length")
                            .ok_or_else(|| anyhow!("js_array_length not declared"))?;
                        let len_ref = module.declare_func_in_func(*len_func, builder.func);
                        let len_call = builder.ins().call(len_ref, &[arr_ptr]);
                        let arr_len = builder.inst_results(len_call)[0];
                        let arr_len_i64 = builder.ins().uextend(types::I64, arr_len);

                        // Call the method with the spread array using js_native_call_value
                        let call_func = extern_funcs.get("js_native_call_value")
                            .ok_or_else(|| anyhow!("js_native_call_value not declared"))?;
                        let call_ref = module.declare_func_in_func(*call_func, builder.func);
                        // js_native_call_value expects f64 for func_value, ensure we have the right type
                        let method_f64 = ensure_f64(builder, method_val);
                        let call = builder.ins().call(call_ref, &[method_f64, arr_ptr, arr_len_i64]);
                        return Ok(builder.inst_results(call)[0]);
                    }

                    // Handle mixed regular args + spread args for method calls
                    // Build a runtime array containing all arguments, then call js_native_call_method
                    if extern_funcs.contains_key("js_native_call_method") {
                        // Compile the object (receiver)
                        let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                        // js_native_call_method expects f64 for object
                        let obj_f64 = ensure_f64(builder, obj_val);

                        // Create string constant for method name
                        let name_bytes = property.as_bytes();
                        let name_len = name_bytes.len();

                        let name_data_id = module.declare_data(
                            &format!("__js_method_spread_{}_{}", property, next_js_data_id()),
                            Linkage::Local,
                            false,
                            false,
                        )?;
                        let mut data_desc = cranelift_module::DataDescription::new();
                        data_desc.define(name_bytes.to_vec().into_boxed_slice());
                        module.define_data(name_data_id, &data_desc)?;

                        let name_gv = module.declare_data_in_func(name_data_id, builder.func);
                        let name_ptr = builder.ins().global_value(types::I64, name_gv);
                        let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

                        // Allocate a runtime array to hold all arguments
                        let initial_capacity = (regular_args.len() + 8) as i64; // Regular args + some space for spread
                        let alloc_func = extern_funcs.get("js_array_alloc")
                            .ok_or_else(|| anyhow!("js_array_alloc not declared"))?;
                        let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                        let capacity = builder.ins().iconst(types::I32, initial_capacity);
                        let alloc_call = builder.ins().call(alloc_ref, &[capacity]);
                        let initial_arr_ptr = builder.inst_results(alloc_call)[0];

                        // Track the array pointer (may change during push operations)
                        let arr_var = Variable::new(next_temp_var_id());
                        builder.declare_var(arr_var, types::I64);
                        builder.def_var(arr_var, initial_arr_ptr);

                        // Get function references we'll need
                        let push_func = extern_funcs.get("js_array_push_f64")
                            .ok_or_else(|| anyhow!("js_array_push_f64 not declared"))?;
                        let push_ref = module.declare_func_in_func(*push_func, builder.func);

                        let length_func = extern_funcs.get("js_array_length")
                            .ok_or_else(|| anyhow!("js_array_length not declared"))?;
                        let length_ref = module.declare_func_in_func(*length_func, builder.func);

                        let get_func = extern_funcs.get("js_array_get_f64")
                            .ok_or_else(|| anyhow!("js_array_get_f64 not declared"))?;
                        let get_ref = module.declare_func_in_func(*get_func, builder.func);

                        // Process arguments in order (regular args and spreads)
                        for arg in args {
                            match arg {
                                CallArg::Expr(expr) => {
                                    // Regular argument - compile and push
                                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
                                    let val_f64 = ensure_f64(builder, val);
                                    let arr_ptr = builder.use_var(arr_var);
                                    let push_call = builder.ins().call(push_ref, &[arr_ptr, val_f64]);
                                    let new_arr_ptr = builder.inst_results(push_call)[0];
                                    builder.def_var(arr_var, new_arr_ptr);
                                }
                                CallArg::Spread(spread_expr) => {
                                    // Spread argument - iterate and push each element
                                    let spread_arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, spread_expr, this_ctx)?;
                                    let spread_arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), spread_arr_val);

                                    // Get length of spread array
                                    let len_call = builder.ins().call(length_ref, &[spread_arr_ptr]);
                                    let spread_len = builder.inst_results(len_call)[0];

                                    // Create loop to iterate over spread array
                                    let loop_header = builder.create_block();
                                    let loop_body = builder.create_block();
                                    let loop_exit = builder.create_block();

                                    // Initialize loop counter
                                    let idx_var = Variable::new(next_temp_var_id());
                                    builder.declare_var(idx_var, types::I32);
                                    let zero = builder.ins().iconst(types::I32, 0);
                                    builder.def_var(idx_var, zero);

                                    // Jump to loop header
                                    builder.ins().jump(loop_header, &[]);

                                    // Loop header: check if idx < length
                                    builder.switch_to_block(loop_header);
                                    let idx = builder.use_var(idx_var);
                                    let cmp = builder.ins().icmp(IntCC::SignedLessThan, idx, spread_len);
                                    builder.ins().brif(cmp, loop_body, &[], loop_exit, &[]);

                                    // Loop body: get element and push it
                                    builder.switch_to_block(loop_body);
                                    let idx = builder.use_var(idx_var);
                                    let get_call = builder.ins().call(get_ref, &[spread_arr_ptr, idx]);
                                    let elem_val = builder.inst_results(get_call)[0];

                                    let arr_ptr = builder.use_var(arr_var);
                                    let push_call = builder.ins().call(push_ref, &[arr_ptr, elem_val]);
                                    let new_arr_ptr = builder.inst_results(push_call)[0];
                                    builder.def_var(arr_var, new_arr_ptr);

                                    // Increment counter
                                    let idx = builder.use_var(idx_var);
                                    let one = builder.ins().iconst(types::I32, 1);
                                    let next_idx = builder.ins().iadd(idx, one);
                                    builder.def_var(idx_var, next_idx);

                                    // Jump back to header
                                    builder.ins().jump(loop_header, &[]);

                                    // Seal the loop blocks
                                    builder.seal_block(loop_header);
                                    builder.seal_block(loop_body);
                                    builder.seal_block(loop_exit);

                                    // Continue from loop exit
                                    builder.switch_to_block(loop_exit);
                                }
                            }
                        }

                        // Get final array pointer and length
                        let final_arr_ptr = builder.use_var(arr_var);
                        let len_call = builder.ins().call(length_ref, &[final_arr_ptr]);
                        let total_len = builder.inst_results(len_call)[0];
                        let total_len_i64 = builder.ins().uextend(types::I64, total_len);

                        // Calculate data pointer: array pointer + 8 (size of ArrayHeader)
                        let header_size = builder.ins().iconst(types::I64, 8);
                        let data_ptr = builder.ins().iadd(final_arr_ptr, header_size);

                        // Call js_native_call_method with the arguments
                        let call_func = extern_funcs.get("js_native_call_method").unwrap();
                        let call_ref = module.declare_func_in_func(*call_func, builder.func);
                        let call = builder.ins().call(call_ref, &[obj_f64, name_ptr, name_len_val, data_ptr, total_len_i64]);
                        return Ok(builder.inst_results(call)[0]);
                    }

                    return Err(anyhow!("Complex spread call patterns with methods not yet supported (JS runtime not enabled)"));
                }
                Expr::LocalGet(local_id) => {
                    // Calling a local variable (closure) with spread
                    if let Some(info) = locals.get(local_id) {
                        if info.is_closure {
                            if spread_count == 1 && regular_args.is_empty() {
                                // Find the spread expression
                                let spread_expr = args.iter().find_map(|a| {
                                    if let CallArg::Spread(e) = a { Some(e) } else { None }
                                }).unwrap();

                                // Compile the spread array
                                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, spread_expr, this_ctx)?;
                                let arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arr_val);

                                // Get closure pointer
                                let closure_val = builder.use_var(info.var);

                                // Get array length
                                let len_func = extern_funcs.get("js_array_length")
                                    .ok_or_else(|| anyhow!("js_array_length not declared"))?;
                                let len_ref = module.declare_func_in_func(*len_func, builder.func);
                                let len_call = builder.ins().call(len_ref, &[arr_ptr]);
                                let arr_len = builder.inst_results(len_call)[0];
                                let arr_len_i64 = builder.ins().uextend(types::I64, arr_len);

                                // Call the closure with spread args using js_native_call_value
                                let call_func = extern_funcs.get("js_native_call_value")
                                    .ok_or_else(|| anyhow!("js_native_call_value not declared"))?;
                                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                                // js_native_call_value expects f64 for func_value, ensure we have the right type
                                let closure_f64 = ensure_f64(builder, closure_val);
                                let call = builder.ins().call(call_ref, &[closure_f64, arr_ptr, arr_len_i64]);
                                return Ok(builder.inst_results(call)[0]);
                            }
                        }
                    }
                    return Err(anyhow!("Spread calls with local variables not yet fully supported"));
                }
                _ => {
                    return Err(anyhow!("Spread calls with non-function callees not yet supported"));
                }
            }
        }
        Expr::Conditional { condition, then_expr, else_expr } => {
            // Helper to detect if an expression produces a string at the HIR level
            fn is_string_conditional_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    _ => false,
                }
            }

            // Check if either branch produces a string - we need NaN-boxing for those
            let then_is_string = is_string_conditional_expr(then_expr, locals);
            let else_is_string = is_string_conditional_expr(else_expr, locals);

            let cond_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, condition, this_ctx)?;
            let cond_val = ensure_f64(builder, cond_val_raw);
            // Use js_is_truthy for proper JavaScript truthiness semantics
            let truthy_func = extern_funcs.get("js_is_truthy")
                .ok_or_else(|| anyhow!("js_is_truthy not declared"))?;
            let truthy_ref = module.declare_func_in_func(*truthy_func, builder.func);
            let truthy_call = builder.ins().call(truthy_ref, &[cond_val]);
            let truthy_result = builder.inst_results(truthy_call)[0];
            let zero_i32 = builder.ins().iconst(types::I32, 0);
            let cond_bool = builder.ins().icmp(IntCC::NotEqual, truthy_result, zero_i32);

            let then_block = builder.create_block();
            let else_block = builder.create_block();
            let merge_block = builder.create_block();
            builder.append_block_param(merge_block, types::F64);

            builder.ins().brif(cond_bool, then_block, &[], else_block, &[]);

            builder.switch_to_block(then_block);
            builder.seal_block(then_block);
            let then_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, then_expr, this_ctx)?;
            // NaN-box string values for proper dynamic type detection
            // Strings are compiled as bitcast(f64, i64_ptr), so we need to convert back and NaN-box
            let then_val_f64 = if then_is_string {
                let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), then_val);
                let nanbox_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let func_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(func_ref, &[ptr]);
                builder.inst_results(call)[0]
            } else {
                ensure_f64(builder, then_val)
            };
            builder.ins().jump(merge_block, &[then_val_f64]);

            builder.switch_to_block(else_block);
            builder.seal_block(else_block);
            let else_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, else_expr, this_ctx)?;
            // NaN-box string values for proper dynamic type detection
            let else_val_f64 = if else_is_string {
                let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), else_val);
                let nanbox_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let func_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(func_ref, &[ptr]);
                builder.inst_results(call)[0]
            } else {
                ensure_f64(builder, else_val)
            };
            builder.ins().jump(merge_block, &[else_val_f64]);

            builder.switch_to_block(merge_block);
            builder.seal_block(merge_block);
            Ok(builder.block_params(merge_block)[0])
        }
        Expr::New { class_name, args, .. } => {
            // Handle native module constructors first
            if class_name == "EventEmitter" {
                // new EventEmitter() - call js_event_emitter_new()
                let new_func = extern_funcs.get("js_event_emitter_new")
                    .ok_or_else(|| anyhow!("js_event_emitter_new not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                let call = builder.ins().call(func_ref, &[]);
                let handle = builder.inst_results(call)[0];
                // Return handle as f64 (NaN-boxed pointer)
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
            }

            // new Promise(executor) - call js_promise_new_with_executor(executor)
            // The executor is a closure (resolve, reject) => void
            if class_name == "Promise" {
                if args.is_empty() {
                    // new Promise() without executor - just create an empty promise
                    let new_func = extern_funcs.get("js_promise_new")
                        .ok_or_else(|| anyhow!("js_promise_new not declared"))?;
                    let func_ref = module.declare_func_in_func(*new_func, builder.func);
                    let call = builder.ins().call(func_ref, &[]);
                    let handle = builder.inst_results(call)[0];
                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
                }

                // Compile the executor closure argument
                let executor_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                let executor_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), executor_val);

                let new_func = extern_funcs.get("js_promise_new_with_executor")
                    .ok_or_else(|| anyhow!("js_promise_new_with_executor not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                let call = builder.ins().call(func_ref, &[executor_ptr]);
                let handle = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
            }

            // new Array() or new Array(length) or new Array(...elements)
            if class_name == "Array" {
                let alloc_func = extern_funcs.get("js_array_alloc")
                    .ok_or_else(|| anyhow!("js_array_alloc not declared"))?;
                let func_ref = module.declare_func_in_func(*alloc_func, builder.func);

                if args.is_empty() {
                    // new Array() - empty array with default capacity
                    let zero_cap = builder.ins().iconst(types::I32, 0);
                    let call = builder.ins().call(func_ref, &[zero_cap]);
                    let arr_ptr = builder.inst_results(call)[0];
                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), arr_ptr));
                } else if args.len() == 1 {
                    // new Array(length) - create array with specified length
                    // Check if the argument is a number literal
                    match &args[0] {
                        Expr::Number(n) => {
                            let cap = builder.ins().iconst(types::I32, *n as i64);
                            let call = builder.ins().call(func_ref, &[cap]);
                            let arr_ptr = builder.inst_results(call)[0];
                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), arr_ptr));
                        }
                        _ => {
                            // Compile the argument as an expression
                            let len_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                            let len_f64 = ensure_f64(builder, len_val);
                            let len_i32 = builder.ins().fcvt_to_sint(types::I32, len_f64);
                            let call = builder.ins().call(func_ref, &[len_i32]);
                            let arr_ptr = builder.inst_results(call)[0];
                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), arr_ptr));
                        }
                    }
                } else {
                    // new Array(e1, e2, ...) - create array with elements
                    let cap = builder.ins().iconst(types::I32, args.len() as i64);
                    let call = builder.ins().call(func_ref, &[cap]);
                    let mut arr_ptr = builder.inst_results(call)[0];

                    // Push each element
                    let push_func = extern_funcs.get("js_array_push_f64")
                        .ok_or_else(|| anyhow!("js_array_push_f64 not declared"))?;
                    let push_ref = module.declare_func_in_func(*push_func, builder.func);

                    for arg in args.iter() {
                        let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                        let val_f64 = ensure_f64(builder, val);
                        let push_call = builder.ins().call(push_ref, &[arr_ptr, val_f64]);
                        arr_ptr = builder.inst_results(push_call)[0];
                    }

                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), arr_ptr));
                }
            }

            // new Uint8Array() or new Uint8Array(length) or new Uint8Array(array)
            // new Buffer(size) - treated as Uint8Array
            if class_name == "Uint8Array" || class_name == "Buffer" {
                if args.is_empty() {
                    // new Uint8Array() / new Buffer() - empty buffer
                    let alloc_func = extern_funcs.get("js_buffer_alloc")
                        .ok_or_else(|| anyhow!("js_buffer_alloc not declared"))?;
                    let func_ref = module.declare_func_in_func(*alloc_func, builder.func);
                    let zero_size = builder.ins().iconst(types::I32, 0);
                    let zero_fill = builder.ins().iconst(types::I32, 0);
                    let call = builder.ins().call(func_ref, &[zero_size, zero_fill]);
                    let buf_ptr = builder.inst_results(call)[0];
                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), buf_ptr));
                } else if args.len() == 1 {
                    // Check if argument is a number (length) or array
                    match &args[0] {
                        Expr::Number(n) => {
                            // new Uint8Array(length) - create with specified length
                            let alloc_func = extern_funcs.get("js_buffer_alloc")
                                .ok_or_else(|| anyhow!("js_buffer_alloc not declared"))?;
                            let func_ref = module.declare_func_in_func(*alloc_func, builder.func);
                            let size = builder.ins().iconst(types::I32, *n as i64);
                            let zero_fill = builder.ins().iconst(types::I32, 0);
                            let call = builder.ins().call(func_ref, &[size, zero_fill]);
                            let buf_ptr = builder.inst_results(call)[0];
                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), buf_ptr));
                        }
                        Expr::Array(elements) => {
                            // new Uint8Array([...]) - create from array literal
                            // First create the array, then convert to buffer
                            let arr_alloc_func = extern_funcs.get("js_array_alloc")
                                .ok_or_else(|| anyhow!("js_array_alloc not declared"))?;
                            let arr_func_ref = module.declare_func_in_func(*arr_alloc_func, builder.func);
                            let cap = builder.ins().iconst(types::I32, elements.len() as i64);
                            let arr_call = builder.ins().call(arr_func_ref, &[cap]);
                            let mut arr_ptr = builder.inst_results(arr_call)[0];

                            let push_func = extern_funcs.get("js_array_push_f64")
                                .ok_or_else(|| anyhow!("js_array_push_f64 not declared"))?;
                            let push_ref = module.declare_func_in_func(*push_func, builder.func);

                            for elem in elements.iter() {
                                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, elem, this_ctx)?;
                                let val_f64 = ensure_f64(builder, val);
                                let push_call = builder.ins().call(push_ref, &[arr_ptr, val_f64]);
                                arr_ptr = builder.inst_results(push_call)[0];
                            }

                            // Convert array to buffer
                            let from_array_func = extern_funcs.get("js_buffer_from_array")
                                .ok_or_else(|| anyhow!("js_buffer_from_array not declared"))?;
                            let from_array_ref = module.declare_func_in_func(*from_array_func, builder.func);
                            let buf_call = builder.ins().call(from_array_ref, &[arr_ptr]);
                            let buf_ptr = builder.inst_results(buf_call)[0];
                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), buf_ptr));
                        }
                        _ => {
                            // Generic argument - compile it and determine at runtime
                            let arg_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                            let arg_f64 = ensure_f64(builder, arg_val);

                            // Check if it's a number (use as length) or treat as array
                            // For simplicity, if it looks like it could be a number, use js_buffer_alloc
                            // Otherwise, try js_buffer_from_array
                            // For now, assume it's a length (number)
                            let alloc_func = extern_funcs.get("js_buffer_alloc")
                                .ok_or_else(|| anyhow!("js_buffer_alloc not declared"))?;
                            let func_ref = module.declare_func_in_func(*alloc_func, builder.func);
                            let size_i32 = builder.ins().fcvt_to_sint(types::I32, arg_f64);
                            let zero_fill = builder.ins().iconst(types::I32, 0);
                            let call = builder.ins().call(func_ref, &[size_i32, zero_fill]);
                            let buf_ptr = builder.inst_results(call)[0];
                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), buf_ptr));
                        }
                    }
                } else {
                    // Multiple arguments - for Buffer, might be (size, fill) or other cases
                    // new Uint8Array(buffer, byteOffset, length) - not yet supported
                    // For now, just allocate with the first argument as length
                    let arg_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                    let arg_f64 = ensure_f64(builder, arg_val);
                    let alloc_func = extern_funcs.get("js_buffer_alloc")
                        .ok_or_else(|| anyhow!("js_buffer_alloc not declared"))?;
                    let func_ref = module.declare_func_in_func(*alloc_func, builder.func);
                    let size_i32 = builder.ins().fcvt_to_sint(types::I32, arg_f64);
                    let zero_fill = builder.ins().iconst(types::I32, 0);
                    let call = builder.ins().call(func_ref, &[size_i32, zero_fill]);
                    let buf_ptr = builder.inst_results(call)[0];
                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), buf_ptr));
                }
            }

            // new Map() or new Map(iterable)
            if class_name == "Map" {
                let alloc_func = extern_funcs.get("js_map_alloc")
                    .ok_or_else(|| anyhow!("js_map_alloc not declared"))?;
                let func_ref = module.declare_func_in_func(*alloc_func, builder.func);
                // Initial capacity (default to 0 which will use 4 internally)
                let cap = builder.ins().iconst(types::I32, 0);
                let call = builder.ins().call(func_ref, &[cap]);
                let map_ptr = builder.inst_results(call)[0];
                // TODO: If args provided, iterate over iterable and add entries
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), map_ptr));
            }

            // new Set() or new Set(iterable)
            if class_name == "Set" {
                let alloc_func = extern_funcs.get("js_set_alloc")
                    .ok_or_else(|| anyhow!("js_set_alloc not declared"))?;
                let func_ref = module.declare_func_in_func(*alloc_func, builder.func);
                // Initial capacity (default to 0 which will use 4 internally)
                let cap = builder.ins().iconst(types::I32, 0);
                let call = builder.ins().call(func_ref, &[cap]);
                let set_ptr = builder.inst_results(call)[0];
                // TODO: If args provided, iterate over iterable and add entries
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), set_ptr));
            }

            // new WeakMap() - WeakMaps are essentially Maps with weak references (not fully supported yet)
            // For now, we use a regular Map as a fallback
            if class_name == "WeakMap" {
                let alloc_func = extern_funcs.get("js_map_alloc")
                    .ok_or_else(|| anyhow!("js_map_alloc not declared"))?;
                let func_ref = module.declare_func_in_func(*alloc_func, builder.func);
                let cap = builder.ins().iconst(types::I32, 0);
                let call = builder.ins().call(func_ref, &[cap]);
                let map_ptr = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), map_ptr));
            }

            // new WeakSet() - WeakSets are essentially Sets with weak references (not fully supported yet)
            // For now, we use a regular Set as a fallback
            if class_name == "WeakSet" {
                let alloc_func = extern_funcs.get("js_set_alloc")
                    .ok_or_else(|| anyhow!("js_set_alloc not declared"))?;
                let func_ref = module.declare_func_in_func(*alloc_func, builder.func);
                let cap = builder.ins().iconst(types::I32, 0);
                let call = builder.ins().call(func_ref, &[cap]);
                let set_ptr = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), set_ptr));
            }

            // new LRUCache({ max: number }) - call js_lru_cache_new(max_size)
            if class_name == "LRUCache" {
                let new_func = extern_funcs.get("js_lru_cache_new")
                    .ok_or_else(|| anyhow!("js_lru_cache_new not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                // Default max size if not specified
                let max_size = if !args.is_empty() {
                    // TODO: Extract 'max' property from options object
                    // For now, just use the first argument as max size
                    compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?
                } else {
                    builder.ins().f64const(100.0) // default
                };
                let call = builder.ins().call(func_ref, &[max_size]);
                let handle = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
            }

            // new Redis(config?) - call js_ioredis_new(config)
            // Returns Handle (u64) synchronously - connects lazily like real ioredis
            if class_name == "Redis" {
                let new_func = extern_funcs.get("js_ioredis_new")
                    .ok_or_else(|| anyhow!("js_ioredis_new not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                // Compile config argument if provided, otherwise pass null
                let config_ptr = if !args.is_empty() {
                    let config_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                    builder.ins().bitcast(types::I64, MemFlags::new(), config_val)
                } else {
                    builder.ins().iconst(types::I64, 0)
                };
                let call = builder.ins().call(func_ref, &[config_ptr]);
                let handle = builder.inst_results(call)[0];
                // NaN-box the handle with POINTER_TAG so it's treated as an object
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let nanbox_call = builder.ins().call(nanbox_ref, &[handle]);
                return Ok(builder.inst_results(nanbox_call)[0]);
            }

            // new Command() - call js_commander_new()
            if class_name == "Command" {
                let new_func = extern_funcs.get("js_commander_new")
                    .ok_or_else(|| anyhow!("js_commander_new not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                let call = builder.ins().call(func_ref, &[]);
                let handle = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
            }

            // new Pool(config) - PostgreSQL connection pool
            if class_name == "Pool" {
                // Pool needs config object, compile the first argument
                if args.is_empty() {
                    return Err(anyhow!("new Pool() requires a config argument"));
                }

                // Compile the config argument
                let config_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                // Bitcast f64 to i64 for the function call
                let config_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), config_val);

                let new_func = extern_funcs.get("js_pg_create_pool")
                    .ok_or_else(|| anyhow!("js_pg_create_pool not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                let call = builder.ins().call(func_ref, &[config_i64]);
                let handle = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
            }

            // new WebSocket(url) - WebSocket connection
            if class_name == "WebSocket" {
                if args.is_empty() {
                    return Err(anyhow!("new WebSocket() requires a URL argument"));
                }

                // Compile the URL argument
                let url_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                // Bitcast f64 to i64 for the function call (url is a string pointer)
                let url_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), url_val);

                let new_func = extern_funcs.get("js_ws_connect")
                    .ok_or_else(|| anyhow!("js_ws_connect not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                let call = builder.ins().call(func_ref, &[url_i64]);
                let handle = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
            }

            // new URLSearchParams(init?) - URL query string params
            if class_name == "URLSearchParams" {
                if args.is_empty() {
                    // new URLSearchParams() - empty
                    let new_func = extern_funcs.get("js_url_search_params_new_empty")
                        .ok_or_else(|| anyhow!("js_url_search_params_new_empty not declared"))?;
                    let func_ref = module.declare_func_in_func(*new_func, builder.func);
                    let call = builder.ins().call(func_ref, &[]);
                    let handle = builder.inst_results(call)[0];
                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
                }

                // Compile the init argument (string, object, or iterable)
                let init_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;
                // Bitcast f64 to i64 for the function call
                let init_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), init_val);

                let new_func = extern_funcs.get("js_url_search_params_new")
                    .ok_or_else(|| anyhow!("js_url_search_params_new not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                let call = builder.ins().call(func_ref, &[init_i64]);
                let handle = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
            }

            // new AbortController() - Web standard abort controller
            if class_name == "AbortController" {
                let new_func = extern_funcs.get("js_abort_controller_new")
                    .ok_or_else(|| anyhow!("js_abort_controller_new not declared"))?;
                let func_ref = module.declare_func_in_func(*new_func, builder.func);
                let call = builder.ins().call(func_ref, &[]);
                let handle = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
            }

            // new Big(value) / new Decimal(value) / new BigNumber(value)
            if class_name == "Big" || class_name == "Decimal" || class_name == "BigNumber" {
                if args.is_empty() {
                    // Default to 0
                    let new_func = extern_funcs.get("js_decimal_from_number")
                        .ok_or_else(|| anyhow!("js_decimal_from_number not declared"))?;
                    let func_ref = module.declare_func_in_func(*new_func, builder.func);
                    let zero = builder.ins().f64const(0.0);
                    let call = builder.ins().call(func_ref, &[zero]);
                    let handle = builder.inst_results(call)[0];
                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
                }

                // Compile the first argument
                let arg_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &args[0], this_ctx)?;

                // Check if argument is a string or number based on the expression type
                let is_string_arg = match &args[0] {
                    Expr::String(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|l| l.is_string).unwrap_or(false),
                    _ => false,
                };

                if is_string_arg {
                    // Use js_decimal_from_string for string arguments
                    let new_func = extern_funcs.get("js_decimal_from_string")
                        .ok_or_else(|| anyhow!("js_decimal_from_string not declared"))?;
                    let func_ref = module.declare_func_in_func(*new_func, builder.func);
                    // String is a pointer, need to bitcast f64 -> i64
                    let str_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_val);
                    let call = builder.ins().call(func_ref, &[str_ptr]);
                    let handle = builder.inst_results(call)[0];
                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
                } else {
                    // Use js_decimal_from_number for number arguments
                    let new_func = extern_funcs.get("js_decimal_from_number")
                        .ok_or_else(|| anyhow!("js_decimal_from_number not declared"))?;
                    let func_ref = module.declare_func_in_func(*new_func, builder.func);

                    // Ensure the argument is f64 (integer literals need conversion)
                    let arg_f64 = if builder.func.dfg.value_type(arg_val) == types::I64 {
                        builder.ins().fcvt_from_sint(types::F64, arg_val)
                    } else {
                        arg_val
                    };

                    let call = builder.ins().call(func_ref, &[arg_f64]);
                    let handle = builder.inst_results(call)[0];
                    return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), handle));
                }
            }

            // Handle new ClassName(args)
            // First try to find a known class definition
            if let Some(class_meta) = classes.get(class_name) {
                // Get parent class ID for inheritance (0 if no parent)
                let parent_id = if let Some(ref parent_name) = class_meta.parent_class {
                    classes.get(parent_name).map(|p| p.id).unwrap_or(0)
                } else {
                    0
                };

                // Allocate with parent class ID for proper instanceof support
                // Use fast allocation (bump allocator, no field initialization)
                let alloc_func = extern_funcs.get("js_object_alloc_fast_with_parent")
                    .ok_or_else(|| anyhow!("js_object_alloc_fast_with_parent not declared"))?;
                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);

                let class_id = builder.ins().iconst(types::I32, class_meta.id as i64);
                let parent_class_id = builder.ins().iconst(types::I32, parent_id as i64);
                let field_count = builder.ins().iconst(types::I32, class_meta.field_count as i64);
                let alloc_call = builder.ins().call(alloc_ref, &[class_id, parent_class_id, field_count]);
                let obj_ptr = builder.inst_results(alloc_call)[0];

                // Call the constructor with 'this' as first argument
                if let Some(ctor_id) = class_meta.constructor_id {
                    // Compile constructor arguments
                    let arg_vals: Vec<Value> = args.iter()
                        .map(|a| compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, a, this_ctx))
                        .collect::<Result<_>>()?;

                    // Build call args: this pointer first, then user args
                    // Constructor params are all declared as f64, so convert any i64 args
                    let mut call_args = vec![obj_ptr];
                    for arg_val in arg_vals {
                        call_args.push(ensure_f64(builder, arg_val));
                    }

                    let func_ref = module.declare_func_in_func(ctor_id, builder.func);

                    // Get expected parameter count and types from the function signature
                    let actual_sig = module.declarations().get_function_decl(ctor_id);
                    let expected_param_count = actual_sig.signature.params.len();

                    // Convert arguments to match expected types
                    let mut final_call_args: Vec<Value> = call_args.iter().enumerate()
                        .map(|(i, &val)| {
                            if i < actual_sig.signature.params.len() {
                                let expected_type = actual_sig.signature.params[i].value_type;
                                let actual_type = builder.func.dfg.value_type(val);
                                if expected_type == types::I64 && actual_type == types::F64 {
                                    builder.ins().bitcast(types::I64, MemFlags::new(), val)
                                } else if expected_type == types::F64 && actual_type == types::I64 {
                                    builder.ins().bitcast(types::F64, MemFlags::new(), val)
                                } else {
                                    val
                                }
                            } else {
                                val
                            }
                        })
                        .collect();

                    // Pad or truncate arguments to match expected count with correct types
                    while final_call_args.len() < expected_param_count {
                        let expected_type = actual_sig.signature.params[final_call_args.len()].value_type;
                        if expected_type == types::I64 {
                            final_call_args.push(builder.ins().iconst(types::I64, 0));
                        } else {
                            final_call_args.push(builder.ins().f64const(f64::NAN));
                        }
                    }
                    final_call_args.truncate(expected_param_count);

                    builder.ins().call(func_ref, &final_call_args);
                }

                // Return the object pointer as f64-bitcasted
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), obj_ptr));
            }

            // Class not found - try to find a local variable with this name
            // This handles dynamically created constructor functions like:
            //   const SpyRPCService = grpc.makeGenericClientConstructor(...)
            //   new SpyRPCService(address, credentials)
            let maybe_local_id = locals.iter().find_map(|(id, info)| {
                if info.name.as_ref().map(|n| n == class_name).unwrap_or(false) {
                    Some(*id)
                } else {
                    None
                }
            });

            if let Some(local_id) = maybe_local_id {
                // Found a local variable with this name - treat it as a constructor function
                // and use js_new_from_handle to call it dynamically
                let info = locals.get(&local_id).unwrap();
                let ctor_val = builder.use_var(info.var);
                // Ensure the constructor value is f64 for js_new_from_handle
                let ctor_f64 = ensure_f64(builder, ctor_val);

                // Compile arguments
                let args_count = args.len();
                if args_count > 0 {
                    let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                        cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                        (args_count * 8) as u32,
                        8,
                    ));
                    let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                    for (i, arg) in args.iter().enumerate() {
                        let arg_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                        // Ensure argument is f64 for JS interop
                        let arg_val = ensure_f64(builder, arg_val_raw);
                        let offset = (i * 8) as i32;
                        builder.ins().store(cranelift_codegen::ir::MemFlags::new(), arg_val, args_ptr, offset);
                    }

                    let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                    let call_func = extern_funcs.get("js_new_from_handle")
                        .ok_or_else(|| anyhow!("js_new_from_handle not declared"))?;
                    let call_ref = module.declare_func_in_func(*call_func, builder.func);
                    let call = builder.ins().call(call_ref, &[ctor_f64, args_ptr, args_count_val]);
                    return Ok(builder.inst_results(call)[0]);
                } else {
                    let null_ptr = builder.ins().iconst(types::I64, 0);
                    let zero_count = builder.ins().iconst(types::I64, 0);

                    let call_func = extern_funcs.get("js_new_from_handle")
                        .ok_or_else(|| anyhow!("js_new_from_handle not declared"))?;
                    let call_ref = module.declare_func_in_func(*call_func, builder.func);
                    let call = builder.ins().call(call_ref, &[ctor_f64, null_ptr, zero_count]);
                    return Ok(builder.inst_results(call)[0]);
                }
            }

            // Neither a known class nor a local variable
            // Try to use js_get_global to look up the class by name at runtime
            if extern_funcs.contains_key("js_get_global") {
                // Get the class from global scope by name
                let bytes = class_name.as_bytes();
                let data_id = module.declare_anonymous_data(false, false)?;
                let mut data_description = cranelift_module::DataDescription::new();
                data_description.define(bytes.to_vec().into_boxed_slice());
                module.define_data(data_id, &data_description)?;

                let global_val = module.declare_data_in_func(data_id, builder.func);
                let name_ptr = builder.ins().global_value(types::I64, global_val);
                let name_len = builder.ins().iconst(types::I64, bytes.len() as i64);

                let get_global_func = extern_funcs.get("js_get_global").unwrap();
                let get_global_ref = module.declare_func_in_func(*get_global_func, builder.func);
                let get_call = builder.ins().call(get_global_ref, &[name_ptr, name_len]);
                let ctor_val = builder.inst_results(get_call)[0];
                let ctor_f64 = ensure_f64(builder, ctor_val);

                // Compile arguments
                let args_count = args.len();
                if args_count > 0 {
                    let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                        cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                        (args_count * 8) as u32,
                        8,
                    ));
                    let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                    for (i, arg) in args.iter().enumerate() {
                        let arg_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                        let arg_val = ensure_f64(builder, arg_val_raw);
                        let offset = (i * 8) as i32;
                        builder.ins().store(cranelift_codegen::ir::MemFlags::new(), arg_val, args_ptr, offset);
                    }

                    let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                    let call_func = extern_funcs.get("js_new_from_handle")
                        .ok_or_else(|| anyhow!("js_new_from_handle not declared"))?;
                    let call_ref = module.declare_func_in_func(*call_func, builder.func);
                    let call = builder.ins().call(call_ref, &[ctor_f64, args_ptr, args_count_val]);
                    return Ok(builder.inst_results(call)[0]);
                } else {
                    let null_ptr = builder.ins().iconst(types::I64, 0);
                    let zero_count = builder.ins().iconst(types::I64, 0);

                    let call_func = extern_funcs.get("js_new_from_handle")
                        .ok_or_else(|| anyhow!("js_new_from_handle not declared"))?;
                    let call_ref = module.declare_func_in_func(*call_func, builder.func);
                    let call = builder.ins().call(call_ref, &[ctor_f64, null_ptr, zero_count]);
                    return Ok(builder.inst_results(call)[0]);
                }
            }

            Err(anyhow!("Unknown class: {}", class_name))
        }
        Expr::NewDynamic { callee, args } => {
            // Handle dynamic new expressions (new with non-identifier callee)
            match callee.as_ref() {
                Expr::ClassRef(class_name) => {
                    // Reuse the regular New handling by recursing
                    let new_expr = Expr::New {
                        class_name: class_name.clone(),
                        args: args.clone(),
                        type_args: Vec::new(),
                    };
                    compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids,
                        extern_funcs, async_func_ids, classes, enums, func_param_types,
                        func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, &new_expr, this_ctx)
                }
                _ => {
                    // For other dynamic new expressions (e.g., new someVariable()),
                    // compile the callee as a regular expression and use js_new_from_handle
                    let ctor_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, callee, this_ctx)?;
                    let ctor_f64 = ensure_f64(builder, ctor_val_raw);

                    // Compile arguments
                    let args_count = args.len();
                    if args_count > 0 {
                        let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                            cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                            (args_count * 8) as u32,
                            8,
                        ));
                        let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                        for (i, arg) in args.iter().enumerate() {
                            let arg_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                            let arg_val = ensure_f64(builder, arg_val_raw);
                            let offset = (i * 8) as i32;
                            builder.ins().store(cranelift_codegen::ir::MemFlags::new(), arg_val, args_ptr, offset);
                        }

                        let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                        let call_func = extern_funcs.get("js_new_from_handle")
                            .ok_or_else(|| anyhow!("js_new_from_handle not declared"))?;
                        let call_ref = module.declare_func_in_func(*call_func, builder.func);
                        let call = builder.ins().call(call_ref, &[ctor_f64, args_ptr, args_count_val]);
                        Ok(builder.inst_results(call)[0])
                    } else {
                        let null_ptr = builder.ins().iconst(types::I64, 0);
                        let zero_count = builder.ins().iconst(types::I64, 0);

                        let call_func = extern_funcs.get("js_new_from_handle")
                            .ok_or_else(|| anyhow!("js_new_from_handle not declared"))?;
                        let call_ref = module.declare_func_in_func(*call_func, builder.func);
                        let call = builder.ins().call(call_ref, &[ctor_f64, null_ptr, zero_count]);
                        Ok(builder.inst_results(call)[0])
                    }
                }
            }
        }
        Expr::PropertySet { object, property, value } => {
            // Handle obj.field = value (where obj is a local variable holding an object)
            // Check for setter first
            if let Expr::LocalGet(id) = object.as_ref() {
                if let Some(info) = locals.get(id) {
                    if let Some(ref class_name) = info.class_name {
                        if let Some(class_meta) = classes.get(class_name) {
                            // Check if there's a setter for this property
                            if let Some(&setter_id) = class_meta.setter_ids.get(property) {
                                // Get the object pointer - ensure it's i64
                                let obj_val = builder.use_var(info.var);
                                let obj_ptr = ensure_i64(builder, obj_val);
                                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
                                // Ensure val is f64 before the call
                                let val_f64 = ensure_f64(builder, val);

                                let func_ref = module.declare_func_in_func(setter_id, builder.func);
                                // Setter expects this as i64, value as f64
                                builder.ins().call(func_ref, &[obj_ptr, val_f64]);

                                return Ok(val);
                            }

                            // Fall back to direct field access (inline store)
                            if let Some(&field_idx) = class_meta.field_indices.get(property) {
                                // Get the object pointer - ensure it's i64
                                let obj_val = builder.use_var(info.var);
                                let obj_ptr = ensure_i64(builder, obj_val);
                                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
                                // Ensure val is f64 for storage
                                let val_f64 = ensure_f64(builder, val);

                                // ObjectHeader is 24 bytes, fields start after that
                                let field_offset = 24 + (field_idx as i32) * 8;
                                builder.ins().store(MemFlags::new(), val_f64, obj_ptr, field_offset);

                                return Ok(val);
                            }
                        }
                    }
                }
            }

            // Handle this.field = value (in constructor/method context)
            if let Some(ctx) = this_ctx {
                if matches!(object.as_ref(), Expr::This) {
                    // Check if there's a setter for this property
                    if let Some(&setter_id) = ctx.class_meta.setter_ids.get(property) {
                        let obj_ptr = builder.use_var(ctx.this_var);
                        let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
                        // Ensure val is f64 before the call (setter expects i64 this, f64 value)
                        let val_f64 = ensure_f64(builder, val);

                        let func_ref = module.declare_func_in_func(setter_id, builder.func);
                        builder.ins().call(func_ref, &[obj_ptr, val_f64]);

                        return Ok(val);
                    }

                    // Fall back to direct field access (inline store)
                    if let Some(&field_idx) = ctx.class_meta.field_indices.get(property) {
                        let obj_ptr = builder.use_var(ctx.this_var);
                        let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

                        // ObjectHeader is 24 bytes, fields start after that
                        let field_offset = 24 + (field_idx as i32) * 8;
                        builder.ins().store(MemFlags::new(), val, obj_ptr, field_offset);

                        return Ok(val);
                    }
                }
            }

            // Generic fallback: use runtime js_object_set_field_by_name for dynamic property access
            // This handles cases like: obj.prop = value where obj is any expression (object literal,
            // function call result, global variable, etc.)

            // Compile the object expression
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
            // Only bitcast if not already i64 (module-level variables are stored as i64 directly)
            let obj_ptr = if builder.func.dfg.value_type(obj_val) == types::I64 {
                obj_val
            } else {
                builder.ins().bitcast(types::I64, MemFlags::new(), obj_val)
            };

            // Create string for property name
            let prop_bytes = property.as_bytes();
            let prop_len = prop_bytes.len();
            let slot = builder.create_sized_stack_slot(StackSlotData::new(
                StackSlotKind::ExplicitSlot,
                prop_len as u32,
                1,
            ));
            for (i, &byte) in prop_bytes.iter().enumerate() {
                let byte_val = builder.ins().iconst(types::I8, byte as i64);
                builder.ins().stack_store(byte_val, slot, i as i32);
            }
            let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
            let alloc_func = extern_funcs.get("js_string_from_bytes")
                .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
            let len_val = builder.ins().iconst(types::I32, prop_len as i64);
            let call = builder.ins().call(alloc_ref, &[slot_addr, len_val]);
            let key_str_ptr = builder.inst_results(call)[0];

            // Compile the value
            let val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
            let val = ensure_f64(builder, val_raw);

            // Call js_object_set_field_by_name(obj_ptr, key_str, value)
            // Ensure key_str_ptr is i64 (js_string_from_bytes returns i64 but it may be bitcast to f64)
            let key_str_ptr_i64 = ensure_i64(builder, key_str_ptr);
            let set_func = extern_funcs.get("js_object_set_field_by_name")
                .ok_or_else(|| anyhow!("js_object_set_field_by_name not declared"))?;
            let set_ref = module.declare_func_in_func(*set_func, builder.func);
            builder.ins().call(set_ref, &[obj_ptr, key_str_ptr_i64, val]);

            Ok(val)
        }
        Expr::PropertyUpdate { object, property, op, prefix } => {
            // Handle this.field++ / ++this.field / this.field-- / --this.field
            // Desugar to: (old = this.field, this.field = old +/- 1, return old/new)

            // Handle this.field++ in method context
            if let Some(ctx) = this_ctx {
                if matches!(object.as_ref(), Expr::This) {
                    if let Some(&field_idx) = ctx.class_meta.field_indices.get(property) {
                        let obj_ptr = builder.use_var(ctx.this_var);

                        // Get current value (inline load)
                        let field_offset = 24 + (field_idx as i32) * 8;
                        let old_val = builder.ins().load(types::F64, MemFlags::new(), obj_ptr, field_offset);

                        // Compute new value: old +/- 1
                        let one = builder.ins().f64const(1.0);
                        let new_val = match op {
                            BinaryOp::Add => builder.ins().fadd(old_val, one),
                            BinaryOp::Sub => builder.ins().fsub(old_val, one),
                            _ => return Err(anyhow!("Unexpected op in PropertyUpdate: {:?}", op)),
                        };

                        // Set new value (inline store)
                        builder.ins().store(MemFlags::new(), new_val, obj_ptr, field_offset);

                        // Return old value for postfix (x++), new value for prefix (++x)
                        return Ok(if *prefix { new_val } else { old_val });
                    }
                }
            }

            // Handle obj.field++ where obj is a local variable
            if let Expr::LocalGet(id) = object.as_ref() {
                if let Some(info) = locals.get(id) {
                    if let Some(ref class_name) = info.class_name {
                        if let Some(class_meta) = classes.get(class_name) {
                            if let Some(&field_idx) = class_meta.field_indices.get(property) {
                                // Get the object pointer - ensure it's i64
                                let obj_val = builder.use_var(info.var);
                                let obj_ptr = ensure_i64(builder, obj_val);

                                // Get current value (inline load)
                                let field_offset = 24 + (field_idx as i32) * 8;
                                let old_val = builder.ins().load(types::F64, MemFlags::new(), obj_ptr, field_offset);

                                // Compute new value: old +/- 1
                                let one = builder.ins().f64const(1.0);
                                let new_val = match op {
                                    BinaryOp::Add => builder.ins().fadd(old_val, one),
                                    BinaryOp::Sub => builder.ins().fsub(old_val, one),
                                    _ => return Err(anyhow!("Unexpected op in PropertyUpdate: {:?}", op)),
                                };

                                // Set new value (inline store)
                                builder.ins().store(MemFlags::new(), new_val, obj_ptr, field_offset);

                                // Return old value for postfix (x++), new value for prefix (++x)
                                return Ok(if *prefix { new_val } else { old_val });
                            }
                        }
                    }
                }
            }

            // Generic fallback: Use runtime functions for dynamic property update
            // This handles cases like obj.field++ where obj is any expression
            // Compile the object expression
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
            let obj_ptr = if builder.func.dfg.value_type(obj_val) == types::I64 {
                obj_val
            } else {
                builder.ins().bitcast(types::I64, MemFlags::new(), obj_val)
            };

            // Create string for property name
            let prop_bytes = property.as_bytes();
            let prop_len = prop_bytes.len();
            let slot = builder.create_sized_stack_slot(StackSlotData::new(
                StackSlotKind::ExplicitSlot,
                prop_len as u32,
                1,
            ));
            for (i, &byte) in prop_bytes.iter().enumerate() {
                let byte_val = builder.ins().iconst(types::I8, byte as i64);
                builder.ins().stack_store(byte_val, slot, i as i32);
            }
            let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
            let alloc_func = extern_funcs.get("js_string_from_bytes")
                .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
            let len_val = builder.ins().iconst(types::I32, prop_len as i64);
            let call = builder.ins().call(alloc_ref, &[slot_addr, len_val]);
            let key_str_ptr = builder.inst_results(call)[0];
            let key_str_ptr_i64 = ensure_i64(builder, key_str_ptr);

            // Get current value using js_object_get_field_by_name_f64
            let get_func = extern_funcs.get("js_object_get_field_by_name_f64")
                .ok_or_else(|| anyhow!("js_object_get_field_by_name_f64 not declared"))?;
            let get_ref = module.declare_func_in_func(*get_func, builder.func);
            let get_call = builder.ins().call(get_ref, &[obj_ptr, key_str_ptr_i64]);
            let old_val = builder.inst_results(get_call)[0];

            // Compute new value: old +/- 1
            let one = builder.ins().f64const(1.0);
            let new_val = match op {
                BinaryOp::Add => builder.ins().fadd(old_val, one),
                BinaryOp::Sub => builder.ins().fsub(old_val, one),
                _ => return Err(anyhow!("Unexpected op in PropertyUpdate: {:?}", op)),
            };

            // Set new value using js_object_set_field_by_name
            let set_func = extern_funcs.get("js_object_set_field_by_name")
                .ok_or_else(|| anyhow!("js_object_set_field_by_name not declared"))?;
            let set_ref = module.declare_func_in_func(*set_func, builder.func);
            builder.ins().call(set_ref, &[obj_ptr, key_str_ptr_i64, new_val]);

            // Return old value for postfix (x++), new value for prefix (++x)
            Ok(if *prefix { new_val } else { old_val })
        }
        Expr::PropertyGet { object, property } => {
            // Handle process.argv.length specially (ProcessArgv returns an array, not object)
            if matches!(object.as_ref(), Expr::ProcessArgv) && property == "length" {
                // Compile ProcessArgv to get the array pointer
                let arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                let arr_ptr = ensure_i64(builder, arr_val);
                let len_func = extern_funcs.get("js_array_length")
                    .ok_or_else(|| anyhow!("js_array_length not declared"))?;
                let func_ref = module.declare_func_in_func(*len_func, builder.func);
                let call = builder.ins().call(func_ref, &[arr_ptr]);
                let len_i32 = builder.inst_results(call)[0];
                // Convert i32 to f64
                let len_f64 = builder.ins().fcvt_from_sint(types::F64, len_i32);
                return Ok(len_f64);
            }

            // Handle obj.field (where obj is a local variable holding an object)
            // Check for getter first
            if let Expr::LocalGet(id) = object.as_ref() {
                if let Some(info) = locals.get(id) {
                    // ESCAPE ANALYSIS: Use scalar variable if object is scalar-replaced
                    if let Some(ref scalar_fields) = info.scalar_fields {
                        if let Some(var) = scalar_fields.get(property) {
                            return Ok(builder.use_var(*var));
                        }
                    }

                    // Handle array.length
                    if info.is_array && property == "length" {
                        // Get the array value - may be NaN-boxed from await results
                        let arr_val = builder.use_var(info.var);
                        let arr_f64 = ensure_f64(builder, arr_val);
                        // Extract pointer from NaN-boxed value (handles both raw and boxed)
                        let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                            .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                        let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                        let ptr_call = builder.ins().call(get_ptr_ref, &[arr_f64]);
                        let arr_ptr = builder.inst_results(ptr_call)[0];

                        let len_func = extern_funcs.get("js_array_length")
                            .ok_or_else(|| anyhow!("js_array_length not declared"))?;
                        let func_ref = module.declare_func_in_func(*len_func, builder.func);
                        let call = builder.ins().call(func_ref, &[arr_ptr]);
                        let len_i32 = builder.inst_results(call)[0];
                        // Convert i32 to f64
                        let len_f64 = builder.ins().fcvt_from_sint(types::F64, len_i32);
                        return Ok(len_f64);
                    }

                    // Handle string.length
                    if info.is_string && property == "length" {
                        // Get the string value - may be NaN-boxed from native method calls
                        let str_val = builder.use_var(info.var);
                        let str_f64 = ensure_f64(builder, str_val);
                        // Extract pointer from NaN-boxed value (handles both raw and boxed)
                        let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                            .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                        let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                        let ptr_call = builder.ins().call(get_ptr_ref, &[str_f64]);
                        let str_ptr = builder.inst_results(ptr_call)[0];

                        let len_func = extern_funcs.get("js_string_length")
                            .ok_or_else(|| anyhow!("js_string_length not declared"))?;
                        let func_ref = module.declare_func_in_func(*len_func, builder.func);
                        let call = builder.ins().call(func_ref, &[str_ptr]);
                        let len_i32 = builder.inst_results(call)[0];
                        // Convert i32 to f64
                        let len_f64 = builder.ins().fcvt_from_sint(types::F64, len_i32);
                        return Ok(len_f64);
                    }

                    // Handle buffer.length
                    if info.is_buffer && property == "length" {
                        let buf_val = builder.use_var(info.var);
                        // Buffer is stored as f64 (bitcasted from pointer)
                        let buf_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), buf_val);
                        let len_func = extern_funcs.get("js_buffer_length")
                            .ok_or_else(|| anyhow!("js_buffer_length not declared"))?;
                        let func_ref = module.declare_func_in_func(*len_func, builder.func);
                        let call = builder.ins().call(func_ref, &[buf_ptr]);
                        let len_i32 = builder.inst_results(call)[0];
                        // Convert i32 to f64
                        let len_f64 = builder.ins().fcvt_from_sint(types::F64, len_i32);
                        return Ok(len_f64);
                    }

                    // Handle map.size
                    if info.is_map && property == "size" {
                        // Map is stored as i64 pointer directly
                        let map_ptr = builder.use_var(info.var);
                        let size_func = extern_funcs.get("js_map_size")
                            .ok_or_else(|| anyhow!("js_map_size not declared"))?;
                        let func_ref = module.declare_func_in_func(*size_func, builder.func);
                        let call = builder.ins().call(func_ref, &[map_ptr]);
                        let size_i32 = builder.inst_results(call)[0];
                        // Convert i32 to f64
                        let size_f64 = builder.ins().fcvt_from_sint(types::F64, size_i32);
                        return Ok(size_f64);
                    }

                    // Handle set.size
                    if info.is_set && property == "size" {
                        // Set is stored as i64 pointer directly
                        let set_ptr = builder.use_var(info.var);
                        let size_func = extern_funcs.get("js_set_size")
                            .ok_or_else(|| anyhow!("js_set_size not declared"))?;
                        let func_ref = module.declare_func_in_func(*size_func, builder.func);
                        let call = builder.ins().call(func_ref, &[set_ptr]);
                        let size_i32 = builder.inst_results(call)[0];
                        // Convert i32 to f64
                        let size_f64 = builder.ins().fcvt_from_sint(types::F64, size_i32);
                        return Ok(size_f64);
                    }

                    // Handle LRUCache.size property
                    if info.class_name.as_deref() == Some("LRUCache") && property == "size" {
                        let cache_val = builder.use_var(info.var);
                        // LRUCache handles are stored as f64, bitcast to i64
                        let handle = builder.ins().bitcast(types::I64, MemFlags::new(), cache_val);
                        let size_func = extern_funcs.get("js_lru_cache_size")
                            .ok_or_else(|| anyhow!("js_lru_cache_size not declared"))?;
                        let func_ref = module.declare_func_in_func(*size_func, builder.func);
                        let call = builder.ins().call(func_ref, &[handle]);
                        // Returns f64 directly
                        return Ok(builder.inst_results(call)[0]);
                    }

                    // Handle object field access (check for getter first)
                    if let Some(ref class_name) = info.class_name {
                        if let Some(class_meta) = classes.get(class_name) {
                            // Get the object pointer - ensure it's i64 for memory access
                            // The variable might be stored as f64 (bitcast from i64) if is_union is true,
                            // or as i64 if is_pointer && !is_union. Use ensure_i64 to handle both cases.
                            let obj_val = builder.use_var(info.var);
                            let obj_ptr = ensure_i64(builder, obj_val);

                            // Check if there's a getter for this property
                            if let Some(&getter_id) = class_meta.getter_ids.get(property) {
                                let func_ref = module.declare_func_in_func(getter_id, builder.func);
                                let call = builder.ins().call(func_ref, &[obj_ptr]);

                                return Ok(builder.inst_results(call)[0]);
                            }

                            // Fall back to direct field access (inline load)
                            if let Some(&field_idx) = class_meta.field_indices.get(property) {
                                // ObjectHeader is 24 bytes, fields start after that
                                // field offset = 24 + field_idx * 8
                                let field_offset = 24 + (field_idx as i32) * 8;
                                let value = builder.ins().load(types::F64, MemFlags::new(), obj_ptr, field_offset);
                                return Ok(value);
                            }
                        }
                    }
                }
            }

            // Handle this.field (in constructor/method context)
            if let Some(ctx) = this_ctx {
                if matches!(object.as_ref(), Expr::This) {
                    // Check if there's a getter for this property
                    if let Some(&getter_id) = ctx.class_meta.getter_ids.get(property) {
                        let obj_ptr = builder.use_var(ctx.this_var);

                        let func_ref = module.declare_func_in_func(getter_id, builder.func);
                        let call = builder.ins().call(func_ref, &[obj_ptr]);

                        return Ok(builder.inst_results(call)[0]);
                    }

                    // Fall back to direct field access (inline load)
                    if let Some(&field_idx) = ctx.class_meta.field_indices.get(property) {
                        let obj_ptr = builder.use_var(ctx.this_var);
                        // ObjectHeader is 24 bytes, fields start after that
                        let field_offset = 24 + (field_idx as i32) * 8;
                        let value = builder.ins().load(types::F64, MemFlags::new(), obj_ptr, field_offset);
                        return Ok(value);
                    }
                }
            }

            // Special handling for ExternFuncRef (imported values from another module)
            // e.g., import { config } from './config'; then config.db.host
            if let Expr::ExternFuncRef { name, .. } = object.as_ref() {
                // Load the exported value from the other module's global
                let global_name = format!("__export_{}", name);
                let data_id = module.declare_data(&global_name, Linkage::Import, true, false)
                    .map_err(|e| anyhow!("Failed to import global {}: {}", global_name, e))?;
                let global_val = module.declare_data_in_func(data_id, builder.func);
                let ptr = builder.ins().global_value(types::I64, global_val);
                let obj_val = builder.ins().load(types::F64, MemFlags::new(), ptr, 0);

                // Handle .length property on imported arrays
                if property == "length" {
                    // Use dynamic array length function which handles NaN-boxed arrays
                    let len_func = extern_funcs.get("js_dynamic_array_length")
                        .ok_or_else(|| anyhow!("js_dynamic_array_length not declared"))?;
                    let func_ref = module.declare_func_in_func(*len_func, builder.func);
                    let call = builder.ins().call(func_ref, &[obj_val]);
                    let len_i32 = builder.inst_results(call)[0];
                    // Convert i32 to f64
                    let len_f64 = builder.ins().fcvt_from_sint(types::F64, len_i32);
                    return Ok(len_f64);
                }

                let obj_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), obj_val);

                // Create a string for the property name
                let prop_bytes = property.as_bytes();
                let prop_len = prop_bytes.len();

                let slot = builder.create_sized_stack_slot(StackSlotData::new(
                    StackSlotKind::ExplicitSlot,
                    prop_len as u32,
                    0,
                ));

                for (i, &byte) in prop_bytes.iter().enumerate() {
                    let byte_val = builder.ins().iconst(types::I8, byte as i64);
                    builder.ins().stack_store(byte_val, slot, i as i32);
                }

                let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
                let str_alloc_func = extern_funcs.get("js_string_from_bytes")
                    .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
                let str_alloc_ref = module.declare_func_in_func(*str_alloc_func, builder.func);
                let len_val = builder.ins().iconst(types::I32, prop_len as i64);
                let str_call = builder.ins().call(str_alloc_ref, &[slot_addr, len_val]);
                let key_str_ptr = builder.inst_results(str_call)[0];

                // Call js_object_get_field_by_name_f64
                // Ensure both arguments are i64
                let obj_ptr_i64 = ensure_i64(builder, obj_ptr);
                let key_str_ptr_i64 = ensure_i64(builder, key_str_ptr);
                let get_func = extern_funcs.get("js_object_get_field_by_name_f64")
                    .ok_or_else(|| anyhow!("js_object_get_field_by_name_f64 not declared"))?;
                let get_ref = module.declare_func_in_func(*get_func, builder.func);
                let call = builder.ins().call(get_ref, &[obj_ptr_i64, key_str_ptr_i64]);
                return Ok(builder.inst_results(call)[0]);
            }

            // Special handling for .length on variables from destructuring/await that might be arrays
            // These aren't marked as is_array but still need proper array length handling
            // Use js_dynamic_array_length to handle both JS handle arrays and native arrays
            if property == "length" {
                // Check if it's a LocalGet with specific flags
                let use_dynamic_length = if let Expr::LocalGet(id) = object.as_ref() {
                    if let Some(info) = locals.get(id) {
                        // If the variable is not marked as array/string/buffer but could be from await/destructuring
                        !info.is_array && !info.is_string && !info.is_buffer && !info.is_map && !info.is_set
                    } else {
                        false
                    }
                } else if let Expr::PropertyGet { .. } = object.as_ref() {
                    // Chained property access (e.g., obj.items.length) - the intermediate
                    // result could be an array, so use dynamic length handling
                    true
                } else {
                    false
                };

                if use_dynamic_length {
                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
                    let val_f64 = ensure_f64(builder, val);

                    // Use dynamic array length that handles both JS handles and native arrays
                    let len_func = extern_funcs.get("js_dynamic_array_length")
                        .ok_or_else(|| anyhow!("js_dynamic_array_length not declared"))?;
                    let len_ref = module.declare_func_in_func(*len_func, builder.func);
                    let len_call = builder.ins().call(len_ref, &[val_f64]);
                    let len_i32 = builder.inst_results(len_call)[0];
                    let len_f64 = builder.ins().fcvt_from_sint(types::F64, len_i32);
                    return Ok(len_f64);
                }
            }

            // For generic object property access (object literals, JS handles, etc.)
            // Use js_dynamic_object_get_property which handles both JS handles and native objects

            // Compile the object expression
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
            let obj_f64 = ensure_f64(builder, obj_val);

            // Create the property name string in the stack
            let prop_bytes = property.as_bytes();
            let prop_len = prop_bytes.len();

            let slot = builder.create_sized_stack_slot(StackSlotData::new(
                StackSlotKind::ExplicitSlot,
                prop_len as u32,
                0,
            ));

            for (i, &byte) in prop_bytes.iter().enumerate() {
                let byte_val = builder.ins().iconst(types::I8, byte as i64);
                builder.ins().stack_store(byte_val, slot, i as i32);
            }

            let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
            let len_val = builder.ins().iconst(types::I64, prop_len as i64);

            // Use unified dynamic property access that handles both JS handles and native objects
            let get_func = extern_funcs.get("js_dynamic_object_get_property")
                .ok_or_else(|| anyhow!("js_dynamic_object_get_property not declared"))?;
            let get_ref = module.declare_func_in_func(*get_func, builder.func);
            let call = builder.ins().call(get_ref, &[obj_f64, slot_addr, len_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::This => {
            if let Some(ctx) = this_ctx {
                // 'this' is a pointer, but we need to return something compile_expr can use
                // For now, we'll return the pointer as i64 bitcast to f64 (hacky but works for property access)
                let ptr = builder.use_var(ctx.this_var);
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), ptr))
            } else {
                // 'this' used outside class context - return undefined (null pointer)
                // This handles cases like module-level arrow functions or callbacks
                // that reference 'this' but aren't actually in a class context
                Ok(builder.ins().f64const(0.0))
            }
        }
        Expr::SuperCall(args) => {
            // super(args) - call parent class constructor with current 'this'
            if let Some(ctx) = this_ctx {
                // Check for native parent first (e.g., EventEmitter)
                if let Some((native_module, native_class)) = &ctx.class_meta.native_parent {
                    // Create native handle based on the native class type
                    if native_module == "events" && native_class == "EventEmitter" {
                        // Create a new EventEmitter and store its handle in field 0
                        let new_func = extern_funcs.get("js_event_emitter_new")
                            .ok_or_else(|| anyhow!("js_event_emitter_new not declared"))?;
                        let func_ref = module.declare_func_in_func(*new_func, builder.func);
                        let call = builder.ins().call(func_ref, &[]);
                        let handle = builder.inst_results(call)[0]; // i64 handle

                        // Store the handle in field 0 of this object
                        let this_ptr = builder.use_var(ctx.this_var);
                        let field_offset = builder.ins().iconst(types::I64, 16); // After ObjectHeader (16 bytes)
                        let field_ptr = builder.ins().iadd(this_ptr, field_offset);

                        // Store handle as f64 (bitcast i64 to f64 for storage)
                        let handle_f64 = builder.ins().bitcast(types::F64, MemFlags::new(), handle);
                        builder.ins().store(MemFlags::new(), handle_f64, field_ptr, 0);

                        // super() returns undefined
                        Ok(builder.ins().f64const(0.0))
                    } else {
                        Err(anyhow!("Unsupported native parent class: {}::{}", native_module, native_class))
                    }
                } else if let Some(parent_name) = &ctx.class_meta.parent_class {
                    // Regular class inheritance
                    if let Some(parent_meta) = classes.get(parent_name) {
                        // Found the parent class in our compiled classes
                        if let Some(parent_ctor_id) = parent_meta.constructor_id {
                            // Compile arguments
                            let arg_vals: Vec<Value> = args.iter()
                                .map(|a| compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, a, this_ctx))
                                .collect::<Result<_>>()?;

                            // Build call args: this pointer first (i64), then user args (f64)
                            let this_ptr = builder.use_var(ctx.this_var);
                            let mut call_args = vec![this_ptr];
                            for arg in arg_vals {
                                call_args.push(ensure_f64(builder, arg));
                            }

                            let func_ref = module.declare_func_in_func(parent_ctor_id, builder.func);

                            // Get expected parameter count from the function signature
                            let actual_sig = module.declarations().get_function_decl(parent_ctor_id);
                            let expected_param_count = actual_sig.signature.params.len();

                            // Pad or truncate arguments to match expected count
                            while call_args.len() < expected_param_count {
                                call_args.push(builder.ins().f64const(f64::NAN));
                            }
                            call_args.truncate(expected_param_count);

                            builder.ins().call(func_ref, &call_args);

                            // super() returns undefined
                            Ok(builder.ins().f64const(0.0))
                        } else {
                            // Parent has no constructor - just return undefined
                            Ok(builder.ins().f64const(0.0))
                        }
                    } else {
                        // Parent class is external (e.g., from a JS runtime library like ethers)
                        // For now, we skip the super() call and return undefined
                        // This allows the compilation to proceed for JS interop scenarios
                        // The parent's initialization is expected to be handled by the JS runtime
                        // when the class is used in a JS context
                        Ok(builder.ins().f64const(0.0))
                    }
                } else {
                    Err(anyhow!("super() called in class without parent"))
                }
            } else {
                Err(anyhow!("super() called outside of class context"))
            }
        }
        Expr::SuperMethodCall { method, args } => {
            // super.method(args) - call parent class method with current 'this'
            if let Some(ctx) = this_ctx {
                if let Some(parent_name) = &ctx.class_meta.parent_class {
                    if let Some(parent_meta) = classes.get(parent_name) {
                        // Found the parent class in our compiled classes
                        if let Some(&method_id) = parent_meta.method_ids.get(method) {
                            // Compile arguments
                            let arg_vals: Vec<Value> = args.iter()
                                .map(|a| compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, a, this_ctx))
                                .collect::<Result<_>>()?;

                            // Build call args: this pointer first (i64), then user args (f64)
                            let this_ptr = builder.use_var(ctx.this_var);
                            let mut call_args = vec![this_ptr];
                            for arg in arg_vals {
                                call_args.push(ensure_f64(builder, arg));
                            }

                            let func_ref = module.declare_func_in_func(method_id, builder.func);

                            // Get expected parameter count and types from the function signature
                            let actual_sig = module.declarations().get_function_decl(method_id);
                            let expected_param_count = actual_sig.signature.params.len();

                            // Convert arguments to match expected types
                            let mut final_call_args: Vec<Value> = call_args.iter().enumerate()
                                .map(|(i, &val)| {
                                    if i < actual_sig.signature.params.len() {
                                        let expected_type = actual_sig.signature.params[i].value_type;
                                        let actual_type = builder.func.dfg.value_type(val);
                                        if expected_type == types::I64 && actual_type == types::F64 {
                                            builder.ins().bitcast(types::I64, MemFlags::new(), val)
                                        } else if expected_type == types::F64 && actual_type == types::I64 {
                                            builder.ins().bitcast(types::F64, MemFlags::new(), val)
                                        } else {
                                            val
                                        }
                                    } else {
                                        val
                                    }
                                })
                                .collect();

                            // Pad or truncate arguments to match expected count with correct types
                            while final_call_args.len() < expected_param_count {
                                let expected_type = actual_sig.signature.params[final_call_args.len()].value_type;
                                if expected_type == types::I64 {
                                    final_call_args.push(builder.ins().iconst(types::I64, 0));
                                } else {
                                    final_call_args.push(builder.ins().f64const(f64::NAN));
                                }
                            }
                            final_call_args.truncate(expected_param_count);

                            let call = builder.ins().call(func_ref, &final_call_args);

                            // Return the method's result
                            if builder.inst_results(call).is_empty() {
                                Ok(builder.ins().f64const(0.0))
                            } else {
                                Ok(builder.inst_results(call)[0])
                            }
                        } else {
                            Err(anyhow!("Method '{}' not found on parent class '{}'", method, parent_name))
                        }
                    } else {
                        // Parent class is external (e.g., from a JS runtime library)
                        // Return undefined as a fallback for external class method calls
                        Ok(builder.ins().f64const(0.0))
                    }
                } else {
                    Err(anyhow!("super.{}() called in class without parent", method))
                }
            } else {
                Err(anyhow!("super.{}() called outside of class context", method))
            }
        }
        Expr::Array(elements) => {
            // Helper to detect if an expression is a string
            fn is_string_element(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) => true,
                    Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                    Expr::PathExtname(_) | Expr::PathResolve(_) | Expr::JsonStringify(_) => true,
                    Expr::CryptoRandomBytes(_) | Expr::CryptoRandomUUID |
                    Expr::CryptoSha256(_) | Expr::CryptoMd5(_) => true,
                    Expr::DateToISOString(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    _ => false,
                }
            }

            // Helper to detect if an expression is a number
            fn is_number_element(expr: &Expr) -> bool {
                matches!(expr, Expr::Number(_) | Expr::Integer(_) | Expr::Bool(_))
            }

            // Helper to detect if an expression is an object/array (pointer type)
            fn is_object_element(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::Object(_) | Expr::Array(_) | Expr::ArraySpread(_) => true,
                    Expr::Call { .. } | Expr::New { .. } | Expr::NativeMethodCall { .. } => true,
                    Expr::Await(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_pointer && !i.is_string).unwrap_or(false),
                    Expr::JsonParse(_) => true,
                    _ => false,
                }
            }

            // Check if this array has mixed types (contains both strings and numbers)
            let has_string = elements.iter().any(|e| is_string_element(e, locals));
            let has_number = elements.iter().any(|e| is_number_element(e));
            let has_object = elements.iter().any(|e| is_object_element(e, locals));
            let is_mixed = (has_string && has_number) || has_object;

            // Create an array from elements
            // First, compile all elements and store them in stack memory
            let count = elements.len();

            if count == 0 {
                // Empty array - just allocate with 0 elements
                let alloc_func = extern_funcs.get("js_array_from_f64")
                    .ok_or_else(|| anyhow!("js_array_from_f64 not declared"))?;
                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                let null_ptr = builder.ins().iconst(types::I64, 0);
                let zero_count = builder.ins().iconst(types::I32, 0);
                let call = builder.ins().call(alloc_ref, &[null_ptr, zero_count]);
                let arr_ptr = builder.inst_results(call)[0];
                return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), arr_ptr));
            }

            // Check if array contains string elements (need NaN-boxing)
            let has_string_elements = has_string;

            if is_mixed || has_string_elements {
                // Array with strings or mixed types: use js_array_from_jsvalue
                // Elements need to be properly NaN-boxed
                let slot = builder.create_sized_stack_slot(StackSlotData::new(
                    StackSlotKind::ExplicitSlot,
                    (count * 8) as u32, // 8 bytes per u64
                    0,
                ));

                // Get the nanbox functions for pointer and string values
                let nanbox_string_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let nanbox_string_ref = module.declare_func_in_func(*nanbox_string_func, builder.func);

                let nanbox_pointer_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_pointer_ref = module.declare_func_in_func(*nanbox_pointer_func, builder.func);

                // Compile and store each element as NaN-boxed JSValue bits (u64)
                for (i, elem) in elements.iter().enumerate() {
                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, elem, this_ctx)?;

                    // For string elements, NaN-box with STRING_TAG
                    // For object elements, NaN-box with POINTER_TAG
                    // For number elements, the f64 bits are used directly
                    let jsvalue_bits = if is_string_element(elem, locals) {
                        // String pointer needs NaN-boxing with STRING_TAG
                        let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                        let call = builder.ins().call(nanbox_string_ref, &[ptr]);
                        let boxed_f64 = builder.inst_results(call)[0];
                        builder.ins().bitcast(types::I64, MemFlags::new(), boxed_f64)
                    } else if is_object_element(elem, locals) {
                        // Object pointer needs NaN-boxing with POINTER_TAG
                        let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                        let call = builder.ins().call(nanbox_pointer_ref, &[ptr]);
                        let boxed_f64 = builder.inst_results(call)[0];
                        builder.ins().bitcast(types::I64, MemFlags::new(), boxed_f64)
                    } else {
                        // Numbers: f64 bits stored as-is
                        builder.ins().bitcast(types::I64, MemFlags::new(), val)
                    };
                    builder.ins().stack_store(jsvalue_bits, slot, (i * 8) as i32);
                }

                // Get the stack slot address
                let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);

                // Call js_array_from_jsvalue
                let alloc_func = extern_funcs.get("js_array_from_jsvalue")
                    .ok_or_else(|| anyhow!("js_array_from_jsvalue not declared"))?;
                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                let count_val = builder.ins().iconst(types::I32, count as i64);
                let call = builder.ins().call(alloc_ref, &[slot_addr, count_val]);
                let arr_ptr = builder.inst_results(call)[0];

                // Return as f64-bitcasted pointer
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), arr_ptr))
            } else {
                // Homogeneous array: use js_array_from_f64
                let slot = builder.create_sized_stack_slot(StackSlotData::new(
                    StackSlotKind::ExplicitSlot,
                    (count * 8) as u32, // 8 bytes per f64
                    0,
                ));

                // Compile and store each element
                for (i, elem) in elements.iter().enumerate() {
                    let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, elem, this_ctx)?;
                    builder.ins().stack_store(val, slot, (i * 8) as i32);
                }

                // Get the stack slot address
                let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);

                // Call js_array_from_f64
                let alloc_func = extern_funcs.get("js_array_from_f64")
                    .ok_or_else(|| anyhow!("js_array_from_f64 not declared"))?;
                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                let count_val = builder.ins().iconst(types::I32, count as i64);
                let call = builder.ins().call(alloc_ref, &[slot_addr, count_val]);
                let arr_ptr = builder.inst_results(call)[0];

                // Return as f64-bitcasted pointer
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), arr_ptr))
            }
        }
        Expr::ArraySpread(elements) => {
            // Create an array with spread elements
            // We need to allocate an initial empty array and then push elements dynamically

            // Count non-spread elements for initial capacity hint
            let non_spread_count = elements.iter().filter(|e| matches!(e, ArrayElement::Expr(_))).count();

            // Allocate array with initial capacity (may grow as spreads are processed)
            let alloc_func = extern_funcs.get("js_array_alloc")
                .ok_or_else(|| anyhow!("js_array_alloc not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
            let capacity = builder.ins().iconst(types::I32, std::cmp::max(non_spread_count, 4) as i64);
            let call = builder.ins().call(alloc_ref, &[capacity]);
            let initial_arr_ptr = builder.inst_results(call)[0];

            // We need to track the current array pointer as it may change during push operations
            let arr_var = Variable::new(next_temp_var_id());
            builder.declare_var(arr_var, types::I64);
            builder.def_var(arr_var, initial_arr_ptr);

            // Get function references we'll need
            let push_f64_func = extern_funcs.get("js_array_push_f64")
                .ok_or_else(|| anyhow!("js_array_push_f64 not declared"))?;
            let push_f64_ref = module.declare_func_in_func(*push_f64_func, builder.func);

            let push_jsvalue_func = extern_funcs.get("js_array_push_jsvalue")
                .ok_or_else(|| anyhow!("js_array_push_jsvalue not declared"))?;
            let push_jsvalue_ref = module.declare_func_in_func(*push_jsvalue_func, builder.func);

            let length_func = extern_funcs.get("js_array_length")
                .ok_or_else(|| anyhow!("js_array_length not declared"))?;
            let length_ref = module.declare_func_in_func(*length_func, builder.func);

            let get_func = extern_funcs.get("js_array_get_f64")
                .ok_or_else(|| anyhow!("js_array_get_f64 not declared"))?;
            let get_ref = module.declare_func_in_func(*get_func, builder.func);

            for element in elements {
                match element {
                    ArrayElement::Expr(expr) => {
                        // Regular element - just push it
                        let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;
                        let arr_ptr = builder.use_var(arr_var);
                        // Use the appropriate push function based on value type
                        let val_type = builder.func.dfg.value_type(val);
                        let call = if val_type == types::I64 {
                            // Value is a pointer (i64) - use js_array_push_jsvalue
                            builder.ins().call(push_jsvalue_ref, &[arr_ptr, val])
                        } else {
                            // Value is f64 - use js_array_push_f64
                            builder.ins().call(push_f64_ref, &[arr_ptr, val])
                        };
                        let new_arr_ptr = builder.inst_results(call)[0];
                        builder.def_var(arr_var, new_arr_ptr);
                    }
                    ArrayElement::Spread(spread_expr) => {
                        // Spread element - iterate over source array and push each element
                        let spread_arr_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, spread_expr, this_ctx)?;
                        let spread_arr_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), spread_arr_val);

                        // Get length of spread array
                        let len_call = builder.ins().call(length_ref, &[spread_arr_ptr]);
                        let spread_len = builder.inst_results(len_call)[0];

                        // Create loop to iterate over spread array
                        let loop_header = builder.create_block();
                        let loop_body = builder.create_block();
                        let loop_exit = builder.create_block();

                        // Initialize loop counter
                        let idx_var = Variable::new(next_temp_var_id());
                        builder.declare_var(idx_var, types::I32);
                        let zero = builder.ins().iconst(types::I32, 0);
                        builder.def_var(idx_var, zero);

                        // Jump to loop header
                        builder.ins().jump(loop_header, &[]);

                        // Loop header: check if idx < length
                        builder.switch_to_block(loop_header);
                        let idx = builder.use_var(idx_var);
                        let cmp = builder.ins().icmp(IntCC::SignedLessThan, idx, spread_len);
                        builder.ins().brif(cmp, loop_body, &[], loop_exit, &[]);

                        // Loop body: get element and push it
                        builder.switch_to_block(loop_body);
                        let idx = builder.use_var(idx_var);
                        let get_call = builder.ins().call(get_ref, &[spread_arr_ptr, idx]);
                        let elem_val = builder.inst_results(get_call)[0];

                        let arr_ptr = builder.use_var(arr_var);
                        // js_array_get_f64 returns f64, so use push_f64
                        let push_call = builder.ins().call(push_f64_ref, &[arr_ptr, elem_val]);
                        let new_arr_ptr = builder.inst_results(push_call)[0];
                        builder.def_var(arr_var, new_arr_ptr);

                        // Increment counter
                        let idx = builder.use_var(idx_var);
                        let one = builder.ins().iconst(types::I32, 1);
                        let next_idx = builder.ins().iadd(idx, one);
                        builder.def_var(idx_var, next_idx);

                        // Jump back to header
                        builder.ins().jump(loop_header, &[]);

                        // Seal the loop blocks now that all predecessors are known
                        builder.seal_block(loop_header);
                        builder.seal_block(loop_body);
                        builder.seal_block(loop_exit);

                        // Continue after loop
                        builder.switch_to_block(loop_exit);
                    }
                }
            }

            // Return final array pointer as f64-bitcasted value
            let final_arr_ptr = builder.use_var(arr_var);
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), final_arr_ptr))
        }
        Expr::Object(props) => {
            // Create an object literal
            // 1. Allocate an object with js_object_alloc (class_id=0 for anonymous, field_count=props.len())
            // 2. Set each field value with js_object_set_field
            // 3. Create a keys array and set it on the object (for Object.keys() support)
            // 4. Return the object pointer as f64-bitcasted value

            let field_count = props.len();

            // Allocate the object (class_id = 0 for anonymous objects)
            // Use fast allocation (bump allocator, no field initialization)
            let alloc_func = extern_funcs.get("js_object_alloc_fast")
                .ok_or_else(|| anyhow!("js_object_alloc_fast not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
            let class_id_val = builder.ins().iconst(types::I32, 0);
            let field_count_val = builder.ins().iconst(types::I32, field_count as i64);
            let call = builder.ins().call(alloc_ref, &[class_id_val, field_count_val]);
            let obj_ptr = builder.inst_results(call)[0];

            // Set each field
            let set_field_func = extern_funcs.get("js_object_set_field_f64")
                .ok_or_else(|| anyhow!("js_object_set_field_f64 not declared"))?;
            let set_field_ref = module.declare_func_in_func(*set_field_func, builder.func);

            for (i, (_key, value_expr)) in props.iter().enumerate() {
                // Compile the value expression
                let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value_expr, this_ctx)?;

                // Check if this is a string value that needs NaN-boxing for dynamic storage
                let is_string = match value_expr {
                    Expr::String(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|info| info.is_string).unwrap_or(false),
                    _ => false,
                };

                let final_val = if is_string {
                    // NaN-box the string pointer
                    let str_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let nanbox_call = builder.ins().call(nanbox_ref, &[str_ptr]);
                    builder.inst_results(nanbox_call)[0]
                } else {
                    // Ensure value is f64 for object field storage
                    let val_type = builder.func.dfg.value_type(val);
                    if val_type == types::I64 {
                        builder.ins().bitcast(types::F64, MemFlags::new(), val)
                    } else {
                        val
                    }
                };

                // Set the field at index i
                let field_idx = builder.ins().iconst(types::I32, i as i64);
                // Ensure obj_ptr is i64 (it should be, but make it explicit)
                let obj_ptr_i64 = ensure_i64(builder, obj_ptr);
                builder.ins().call(set_field_ref, &[obj_ptr_i64, field_idx, final_val]);
            }

            // Create a keys array containing the property names as strings
            // This enables Object.keys() to work at runtime
            if !props.is_empty() {
                // Allocate array for keys
                let arr_alloc_func = extern_funcs.get("js_array_alloc")
                    .ok_or_else(|| anyhow!("js_array_alloc not declared"))?;
                let arr_alloc_ref = module.declare_func_in_func(*arr_alloc_func, builder.func);
                let keys_capacity = builder.ins().iconst(types::I32, field_count as i64);
                let keys_call = builder.ins().call(arr_alloc_ref, &[keys_capacity]);
                let keys_arr_ptr = builder.inst_results(keys_call)[0];

                // Push each key string to the array
                let string_from_bytes = extern_funcs.get("js_string_from_bytes")
                    .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
                let string_from_bytes_ref = module.declare_func_in_func(*string_from_bytes, builder.func);

                let arr_push_func = extern_funcs.get("js_array_push_f64")
                    .ok_or_else(|| anyhow!("js_array_push_f64 not declared"))?;
                let arr_push_ref = module.declare_func_in_func(*arr_push_func, builder.func);

                // We need to track the current keys array pointer as push may reallocate
                let keys_arr_var = Variable::new(next_temp_var_id());
                builder.declare_var(keys_arr_var, types::I64);
                builder.def_var(keys_arr_var, keys_arr_ptr);

                for (key, _value_expr) in props.iter() {
                    // Create string from key bytes
                    let key_bytes = key.as_bytes();
                    let key_len = key_bytes.len();

                    // For each key, we need to create a string at runtime
                    // Store the key bytes in a data section and pass to js_string_from_bytes
                    let data_id = {
                        let mut data_desc = DataDescription::new();
                        data_desc.define(key_bytes.to_vec().into_boxed_slice());
                        let name = format!("__key_str_{}_{}", key, next_temp_var_id());
                        let id = module.declare_data(&name, Linkage::Local, false, false)?;
                        module.define_data(id, &data_desc)?;
                        id
                    };

                    let data_ptr = module.declare_data_in_func(data_id, builder.func);
                    let data_addr = builder.ins().global_value(types::I64, data_ptr);
                    let len_val = builder.ins().iconst(types::I32, key_len as i64);

                    let string_call = builder.ins().call(string_from_bytes_ref, &[data_addr, len_val]);
                    let key_string_ptr = builder.inst_results(string_call)[0];

                    // NaN-box the string pointer for proper array storage
                    let nanbox_string_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_string_ref = module.declare_func_in_func(*nanbox_string_func, builder.func);
                    let nanbox_call = builder.ins().call(nanbox_string_ref, &[key_string_ptr]);
                    let key_string_f64 = builder.inst_results(nanbox_call)[0];

                    // Push to keys array
                    let current_keys_arr = builder.use_var(keys_arr_var);
                    let push_call = builder.ins().call(arr_push_ref, &[current_keys_arr, key_string_f64]);
                    let new_keys_arr = builder.inst_results(push_call)[0];
                    builder.def_var(keys_arr_var, new_keys_arr);
                }

                // Set the keys array on the object
                let set_keys_func = extern_funcs.get("js_object_set_keys")
                    .ok_or_else(|| anyhow!("js_object_set_keys not declared"))?;
                let set_keys_ref = module.declare_func_in_func(*set_keys_func, builder.func);
                let final_keys_arr = builder.use_var(keys_arr_var);
                // Ensure both arguments are i64 (they should be, but make it explicit)
                let obj_ptr_i64 = ensure_i64(builder, obj_ptr);
                let keys_arr_i64 = ensure_i64(builder, final_keys_arr);
                builder.ins().call(set_keys_ref, &[obj_ptr_i64, keys_arr_i64]);
            }

            // NaN-box the object pointer with POINTER_TAG for proper runtime identification
            let nanbox_ptr_func = extern_funcs.get("js_nanbox_pointer")
                .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
            let nanbox_ptr_ref = module.declare_func_in_func(*nanbox_ptr_func, builder.func);
            let obj_ptr_i64 = ensure_i64(builder, obj_ptr);
            let nanbox_call = builder.ins().call(nanbox_ptr_ref, &[obj_ptr_i64]);
            Ok(builder.inst_results(nanbox_call)[0])
        }
        Expr::IndexGet { object, index } => {
            // Handle array indexing: arr[i]
            // First, check if we have a known local array for optimized access
            if let Expr::LocalGet(id) = object.as_ref() {
                if let Some(info) = locals.get(id) {
                    if info.is_array {
                        // Get the array pointer - may be NaN-boxed from await results
                        let arr_val = builder.use_var(info.var);
                        let arr_f64 = ensure_f64(builder, arr_val);
                        // Extract pointer from NaN-boxed value (handles both raw and boxed)
                        let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                            .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                        let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                        let call = builder.ins().call(get_ptr_ref, &[arr_f64]);
                        let arr_ptr = builder.inst_results(call)[0];
                        // OPTIMIZATION: Use native i32 or i32 shadow for integer variables, avoiding f64->i32 conversion
                        let idx_i32 = if let Expr::Integer(n) = index.as_ref() {
                            // Integer literal - compile directly as i32
                            builder.ins().iconst(types::I32, *n)
                        } else if let Expr::LocalGet(idx_id) = index.as_ref() {
                            // Check if we have a native i32 or i32 shadow for this variable
                            if let Some(idx_info) = locals.get(idx_id) {
                                if idx_info.is_i32 {
                                    // Use the native i32 directly - no conversion needed!
                                    builder.use_var(idx_info.var)
                                } else if let Some(shadow_var) = idx_info.i32_shadow {
                                    // Use the i32 shadow directly - no conversion needed!
                                    builder.use_var(shadow_var)
                                } else {
                                    let idx_val = builder.use_var(idx_info.var);
                                    let idx_f64 = ensure_f64(builder, idx_val);
                                    builder.ins().fcvt_to_sint(types::I32, idx_f64)
                                }
                            } else {
                                let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                                let idx_f64 = ensure_f64(builder, idx_val);
                                builder.ins().fcvt_to_sint(types::I32, idx_f64)
                            }
                        } else {
                            let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                            let idx_f64 = ensure_f64(builder, idx_val);
                            builder.ins().fcvt_to_sint(types::I32, idx_f64)
                        };

                        // Use safe js_array_get_jsvalue for:
                        // - Mixed-type arrays (explicitly marked)
                        // - Union-typed arrays (from await, JSON.parse, etc.)
                        // - Arrays that might contain NaN-boxed pointers (objects/strings)
                        // The inline optimization is only safe for pure number arrays
                        if info.is_mixed_array || info.is_union {
                            // For mixed-type arrays, use js_array_get_jsvalue which returns u64 (JSValue bits)
                            // The result is used as-is since it's already NaN-boxed
                            let get_func = extern_funcs.get("js_array_get_jsvalue")
                                .ok_or_else(|| anyhow!("js_array_get_jsvalue not declared"))?;
                            let func_ref = module.declare_func_in_func(*get_func, builder.func);
                            let call = builder.ins().call(func_ref, &[arr_ptr, idx_i32]);
                            let jsvalue_bits = builder.inst_results(call)[0];
                            // Convert u64 to f64 for uniform value representation
                            return Ok(builder.ins().bitcast(types::F64, MemFlags::new(), jsvalue_bits));
                        } else {
                            // OPTIMIZED inline array access:
                            // element address = arr_ptr + 8 + index * 8
                            let idx_i64 = builder.ins().uextend(types::I64, idx_i32);
                            let byte_offset = builder.ins().ishl_imm(idx_i64, 3); // index * 8
                            let data_ptr = builder.ins().iadd_imm(arr_ptr, 8); // arr + 8
                            let element_ptr = builder.ins().iadd(data_ptr, byte_offset);
                            let value = builder.ins().load(types::F64, MemFlags::new(), element_ptr, 0);
                            return Ok(value);
                        }
                    } else if info.is_string {
                        // String character access: str[i] returns single-character string
                        let str_val = builder.use_var(info.var);
                        let str_f64 = ensure_f64(builder, str_val);

                        // Extract string pointer (handles both raw and NaN-boxed)
                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                        let call = builder.ins().call(get_str_ptr_ref, &[str_f64]);
                        let str_ptr = builder.inst_results(call)[0];

                        // Get the index
                        let idx_i32 = if let Expr::Integer(n) = index.as_ref() {
                            builder.ins().iconst(types::I32, *n)
                        } else {
                            let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                            let idx_f64 = ensure_f64(builder, idx_val);
                            builder.ins().fcvt_to_sint(types::I32, idx_f64)
                        };

                        // Call js_string_char_at to get single-char string
                        let char_at_func = extern_funcs.get("js_string_char_at")
                            .ok_or_else(|| anyhow!("js_string_char_at not declared"))?;
                        let char_at_ref = module.declare_func_in_func(*char_at_func, builder.func);
                        let call = builder.ins().call(char_at_ref, &[str_ptr, idx_i32]);
                        let result_ptr = builder.inst_results(call)[0];

                        // NaN-box the result string pointer
                        let nanbox_func = extern_funcs.get("js_nanbox_string")
                            .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                        let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                        let call = builder.ins().call(nanbox_ref, &[result_ptr]);
                        return Ok(builder.inst_results(call)[0]);
                    }
                }
            }

            // Fallback: generic index access via runtime function
            // This handles cases like: result.rows[0], obj[key], or variables not marked as arrays

            // Helper to check if an expression produces a string
            fn is_string_index_expr_get(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                    Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                    Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                    Expr::Binary { op: BinaryOp::Add, left, right } => {
                        is_string_index_expr_get(left, locals) || is_string_index_expr_get(right, locals)
                    }
                    Expr::PropertyGet { .. } => {
                        // Property access might return a string - treat as dynamic
                        true
                    }
                    _ => false,
                }
            }

            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
            let obj_f64 = ensure_f64(builder, obj_val);

            if is_string_index_expr_get(index, locals) {
                // String key - use js_object_get_field_by_name_f64
                // Need to extract pointer first for string keys
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[obj_f64]);
                let obj_ptr = builder.inst_results(call)[0];

                let key_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                // String keys are now NaN-boxed - extract the actual pointer
                let key_f64 = ensure_f64(builder, key_val);
                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                let str_call = builder.ins().call(get_str_ptr_ref, &[key_f64]);
                let key_ptr = builder.inst_results(str_call)[0];

                let get_func = extern_funcs.get("js_object_get_field_by_name_f64")
                    .ok_or_else(|| anyhow!("js_object_get_field_by_name_f64 not declared"))?;
                let func_ref = module.declare_func_in_func(*get_func, builder.func);
                let call = builder.ins().call(func_ref, &[obj_ptr, key_ptr]);
                let result = builder.inst_results(call)[0];
                Ok(result)
            } else {
                // Integer index - check if object is a string for character access
                // Helper to check if an expression is a string (for character access)
                fn is_string_object_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                    match expr {
                        Expr::String(_) => true,
                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                        Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                        // Method calls like str.substring(), str.trim(), etc.
                        Expr::Call { callee, .. } => {
                            if let Expr::PropertyGet { property, .. } = callee.as_ref() {
                                // String methods that return strings
                                matches!(property.as_str(),
                                    "substring" | "slice" | "trim" | "toLowerCase" | "toUpperCase" |
                                    "padStart" | "padEnd" | "repeat" | "charAt" | "replace")
                            } else {
                                false
                            }
                        }
                        Expr::PropertyGet { .. } => {
                            // PropertyGet might return a string - handle dynamically at runtime
                            false  // Let it fall through to dynamic handling
                        }
                        _ => false,
                    }
                }

                if is_string_object_expr(object, locals) {
                    // String character access: str[i]
                    // Extract string pointer (handles both raw and NaN-boxed)
                    let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                        .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                    let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                    let call = builder.ins().call(get_str_ptr_ref, &[obj_f64]);
                    let str_ptr = builder.inst_results(call)[0];

                    // Get the index
                    let idx_i32 = if let Expr::Integer(n) = index.as_ref() {
                        builder.ins().iconst(types::I32, *n)
                    } else {
                        let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                        let idx_f64 = ensure_f64(builder, idx_val);
                        builder.ins().fcvt_to_sint(types::I32, idx_f64)
                    };

                    // Call js_string_char_at to get single-char string
                    let char_at_func = extern_funcs.get("js_string_char_at")
                        .ok_or_else(|| anyhow!("js_string_char_at not declared"))?;
                    let char_at_ref = module.declare_func_in_func(*char_at_func, builder.func);
                    let call = builder.ins().call(char_at_ref, &[str_ptr, idx_i32]);
                    let result_ptr = builder.inst_results(call)[0];

                    // NaN-box the result string pointer
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result_ptr]);
                    return Ok(builder.inst_results(call)[0]);
                }

                let idx_i32 = if let Expr::Integer(n) = index.as_ref() {
                    builder.ins().iconst(types::I32, *n)
                } else {
                    let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                    let idx_f64 = ensure_f64(builder, idx_val);
                    builder.ins().fcvt_to_sint(types::I32, idx_f64)
                };

                // Use the unified dynamic array access that handles both JS handles and native arrays
                let get_func = extern_funcs.get("js_dynamic_array_get")
                    .ok_or_else(|| anyhow!("js_dynamic_array_get not declared"))?;
                let func_ref = module.declare_func_in_func(*get_func, builder.func);
                let call = builder.ins().call(func_ref, &[obj_f64, idx_i32]);
                Ok(builder.inst_results(call)[0])
            }
        }
        Expr::IndexSet { object, index, value } => {
            // Handle array element assignment: arr[i] = value
            if let Expr::LocalGet(id) = object.as_ref() {
                if let Some(info) = locals.get(id) {
                    if info.is_array {
                        let arr_val = builder.use_var(info.var);
                        let arr_ptr = ensure_i64(builder, arr_val);
                        let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

                        // OPTIMIZATION: Use native i32 or i32 shadow for integer variables, avoiding f64->i32 conversion
                        let idx_i32 = if let Expr::Integer(n) = index.as_ref() {
                            // Integer literal - compile directly as i32
                            builder.ins().iconst(types::I32, *n)
                        } else if let Expr::LocalGet(idx_id) = index.as_ref() {
                            // Check if we have a native i32 or i32 shadow for this variable
                            if let Some(idx_info) = locals.get(idx_id) {
                                if idx_info.is_i32 {
                                    // Use the native i32 directly - no conversion needed!
                                    builder.use_var(idx_info.var)
                                } else if let Some(shadow_var) = idx_info.i32_shadow {
                                    // Use the i32 shadow directly - no conversion needed!
                                    builder.use_var(shadow_var)
                                } else {
                                    let idx_val = builder.use_var(idx_info.var);
                                    let idx_f64 = ensure_f64(builder, idx_val);
                                    builder.ins().fcvt_to_sint(types::I32, idx_f64)
                                }
                            } else {
                                let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                                let idx_f64 = ensure_f64(builder, idx_val);
                                builder.ins().fcvt_to_sint(types::I32, idx_f64)
                            }
                        } else {
                            let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                            let idx_f64 = ensure_f64(builder, idx_val);
                            builder.ins().fcvt_to_sint(types::I32, idx_f64)
                        };

                        if info.is_mixed_array {
                            // For mixed-type arrays, we need to properly encode the value
                            // Check if the value being assigned is a string (needs NaN-boxing)
                            fn is_string_value(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                                match expr {
                                    Expr::String(_) => true,
                                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                                    _ => false,
                                }
                            }

                            let jsvalue_bits = if is_string_value(value, locals) {
                                // String pointer needs NaN-boxing with STRING_TAG
                                let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                                let nanbox_func = extern_funcs.get("js_nanbox_string")
                                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                let call = builder.ins().call(nanbox_ref, &[ptr]);
                                let boxed_f64 = builder.inst_results(call)[0];
                                builder.ins().bitcast(types::I64, MemFlags::new(), boxed_f64)
                            } else {
                                // Numbers: f64 bits stored as-is
                                builder.ins().bitcast(types::I64, MemFlags::new(), val)
                            };

                            let set_func = extern_funcs.get("js_array_set_jsvalue")
                                .ok_or_else(|| anyhow!("js_array_set_jsvalue not declared"))?;
                            let func_ref = module.declare_func_in_func(*set_func, builder.func);
                            builder.ins().call(func_ref, &[arr_ptr, idx_i32, jsvalue_bits]);
                        } else {
                            // BOUNDS CHECK ELIMINATION: Check if index is bounded by this array or constant
                            let (is_bounded, has_constant_bound) = if let Expr::LocalGet(idx_id) = index.as_ref() {
                                if let Some(idx_info) = locals.get(idx_id) {
                                    let by_array = idx_info.bounded_by_array == Some(*id);
                                    let by_const = idx_info.bounded_by_constant.is_some();
                                    (by_array || by_const, by_const)
                                } else {
                                    (false, false)
                                }
                            } else {
                                (false, false)
                            };

                            if is_bounded {
                                // BOUNDS CHECK ELIMINATED: Index is guaranteed < arr.length or < CONSTANT
                                // For constant bounds, we assume the array was initialized to that size
                                // (This is the case for sieve-style code that initializes then accesses)
                                if has_constant_bound {
                                    // With constant bound, do a single check at loop entry instead
                                    // For now, just do inline write (safe if array was pre-sized)
                                }
                                // Just do the inline write without any branching
                                let idx_i64 = builder.ins().uextend(types::I64, idx_i32);
                                let byte_offset = builder.ins().ishl_imm(idx_i64, 3);
                                let data_ptr = builder.ins().iadd_imm(arr_ptr, 8);
                                let element_ptr = builder.ins().iadd(data_ptr, byte_offset);
                                builder.ins().store(MemFlags::new(), val, element_ptr, 0);
                            } else {
                            // ULTRA-FAST array write with minimal overhead:
                            // In-bounds path: just store, skip merge block (array ptr unchanged)
                            // Out-of-bounds: go through merge to update array variable

                            let length = builder.ins().load(types::I32, MemFlags::new(), arr_ptr, 0);
                            let in_bounds = builder.ins().icmp(IntCC::UnsignedLessThan, idx_i32, length);

                            let in_bounds_block = builder.create_block();
                            let check_capacity_block = builder.create_block();
                            let continue_block = builder.create_block();

                            builder.ins().brif(in_bounds, in_bounds_block, &[], check_capacity_block, &[]);

                            // FASTEST path: index < length - just store, no merge needed
                            builder.switch_to_block(in_bounds_block);
                            builder.seal_block(in_bounds_block);
                            {
                                let idx_i64 = builder.ins().uextend(types::I64, idx_i32);
                                let byte_offset = builder.ins().ishl_imm(idx_i64, 3);
                                let data_ptr = builder.ins().iadd_imm(arr_ptr, 8);
                                let element_ptr = builder.ins().iadd(data_ptr, byte_offset);
                                builder.ins().store(MemFlags::new(), val, element_ptr, 0);
                            }
                            // Jump directly to continue - no variable update needed
                            builder.ins().jump(continue_block, &[]);

                            // Check capacity for extension case
                            builder.switch_to_block(check_capacity_block);
                            builder.seal_block(check_capacity_block);
                            let capacity = builder.ins().load(types::I32, MemFlags::new(), arr_ptr, 4);
                            let within_capacity = builder.ins().icmp(IntCC::UnsignedLessThan, idx_i32, capacity);

                            let extend_inline_block = builder.create_block();
                            let realloc_block = builder.create_block();

                            builder.ins().brif(within_capacity, extend_inline_block, &[], realloc_block, &[]);

                            // Medium path: extend within capacity (ptr unchanged)
                            builder.switch_to_block(extend_inline_block);
                            builder.seal_block(extend_inline_block);
                            {
                                let idx_i64 = builder.ins().uextend(types::I64, idx_i32);
                                let byte_offset = builder.ins().ishl_imm(idx_i64, 3);
                                let data_ptr = builder.ins().iadd_imm(arr_ptr, 8);
                                let element_ptr = builder.ins().iadd(data_ptr, byte_offset);
                                builder.ins().store(MemFlags::new(), val, element_ptr, 0);
                                let new_length = builder.ins().iadd_imm(idx_i32, 1);
                                builder.ins().store(MemFlags::new(), new_length, arr_ptr, 0);
                            }
                            builder.ins().jump(continue_block, &[]);

                            // Slow path: reallocation needed - update variable
                            builder.switch_to_block(realloc_block);
                            builder.seal_block(realloc_block);
                            {
                                let set_func = extern_funcs.get("js_array_set_f64_extend")
                                    .ok_or_else(|| anyhow!("js_array_set_f64_extend not declared"))?;
                                let func_ref = module.declare_func_in_func(*set_func, builder.func);
                                let call = builder.ins().call(func_ref, &[arr_ptr, idx_i32, val]);
                                let new_arr_ptr = builder.inst_results(call)[0];
                                // Only update variable when reallocation happens
                                // Convert back to the variable's storage type
                                let store_val = if info.is_pointer && !info.is_union {
                                    new_arr_ptr
                                } else {
                                    builder.ins().bitcast(types::F64, MemFlags::new(), new_arr_ptr)
                                };
                                builder.def_var(info.var, store_val);
                            }
                            builder.ins().jump(continue_block, &[]);

                            // Continue block - all paths merge here
                            builder.switch_to_block(continue_block);
                            builder.seal_block(continue_block);
                            } // end of else (not bounded)
                        }

                        return Ok(val);
                    }
                }
            }

            // Fallback: generic index set via runtime function
            // This handles cases like: obj[key] = value, params[name] = val, etc.
            // where the object is not a simple LocalGet with known array type

            // Helper to check if an expression produces a string
            fn is_string_index_expr(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                match expr {
                    Expr::String(_) => true,
                    Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                    Expr::EnvGet(_) | Expr::EnvGetDynamic(_) => true,
                    Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                    Expr::PathExtname(_) | Expr::PathResolve(_) => true,
                    Expr::Binary { op: BinaryOp::Add, left, right } => {
                        is_string_index_expr(left, locals) || is_string_index_expr(right, locals)
                    }
                    Expr::PropertyGet { .. } => {
                        // Property access might return a string - treat as dynamic
                        true
                    }
                    _ => false,
                }
            }

            // Compile the object expression
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;

            // The value may be NaN-boxed (from await, property access, etc).
            // Use js_nanbox_get_pointer to extract the actual pointer.
            let obj_f64 = ensure_f64(builder, obj_val);
            let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
            let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
            let call = builder.ins().call(get_ptr_ref, &[obj_f64]);
            let obj_ptr = builder.inst_results(call)[0];

            // Compile the value expression
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            if is_string_index_expr(index, locals) {
                // String key - use js_object_set_field_by_name
                // Compile the index as a string pointer
                let key_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                // String keys are now NaN-boxed - extract the actual pointer
                let key_f64 = ensure_f64(builder, key_val);
                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                let str_call = builder.ins().call(get_str_ptr_ref, &[key_f64]);
                let key_ptr = builder.inst_results(str_call)[0];

                // Ensure value is f64 as the runtime function expects f64
                let val_f64 = ensure_f64(builder, val);

                let set_func = extern_funcs.get("js_object_set_field_by_name")
                    .ok_or_else(|| anyhow!("js_object_set_field_by_name not declared"))?;
                let func_ref = module.declare_func_in_func(*set_func, builder.func);
                builder.ins().call(func_ref, &[obj_ptr, key_ptr, val_f64]);

                Ok(val)
            } else {
                // Integer index - use js_array_set_jsvalue
                let idx_i32 = if let Expr::Integer(n) = index.as_ref() {
                    builder.ins().iconst(types::I32, *n)
                } else {
                    let idx_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, index, this_ctx)?;
                    let idx_f64 = ensure_f64(builder, idx_val);
                    builder.ins().fcvt_to_sint(types::I32, idx_f64)
                };

                // Convert value to JSValue bits (u64)
                let jsvalue_bits = builder.ins().bitcast(types::I64, MemFlags::new(), val);

                let set_func = extern_funcs.get("js_array_set_jsvalue")
                    .ok_or_else(|| anyhow!("js_array_set_jsvalue not declared"))?;
                let func_ref = module.declare_func_in_func(*set_func, builder.func);
                builder.ins().call(func_ref, &[obj_ptr, idx_i32, jsvalue_bits]);

                Ok(val)
            }
        }
        Expr::Closure { func_id, captures, mutable_captures, captures_this, enclosing_class, .. } => {
            // Create a closure object at runtime
            // 1. Get the function pointer for the closure function
            // 2. Allocate a closure object with space for captures (and `this` if captured)
            // 3. Store captured values into the closure (boxing mutable ones)

            // The closure function should already be declared in closure_func_ids
            // We need to get its address
            let clif_func_id = closure_func_ids.get(func_id)
                .ok_or_else(|| anyhow!("Closure function {} not found in closure_func_ids. Available: {:?}", func_id, closure_func_ids.keys().collect::<Vec<_>>()))?;

            // Get the function reference in this function
            let func_ref = module.declare_func_in_func(*clif_func_id, builder.func);

            // Get the function address as a pointer
            let func_ptr = builder.ins().func_addr(types::I64, func_ref);

            let alloc_func = extern_funcs.get("js_closure_alloc")
                .ok_or_else(|| anyhow!("js_closure_alloc not declared"))?;
            let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);

            // If captures_this, we need an extra slot for `this`
            let total_captures = if *captures_this { captures.len() + 1 } else { captures.len() };
            let capture_count = builder.ins().iconst(types::I32, total_captures as i64);

            let call = builder.ins().call(alloc_ref, &[func_ptr, capture_count]);
            let closure_ptr = builder.inst_results(call)[0];

            // Get set_capture function reference (needed for both `this` and regular captures)
            let set_capture_func = extern_funcs.get("js_closure_set_capture_f64")
                .ok_or_else(|| anyhow!("js_closure_set_capture_f64 not declared"))?;
            let set_ref = module.declare_func_in_func(*set_capture_func, builder.func);

            // If captures_this, store `this` at slot 0
            // Note: capture_offset is 1 only if we actually stored `this`
            let capture_offset = if *captures_this {
                if let Some(ctx) = this_ctx {
                    // Get the `this` pointer from ThisContext
                    let this_ptr = builder.use_var(ctx.this_var);
                    // Convert to f64 for storage
                    let this_f64 = builder.ins().bitcast(types::F64, MemFlags::new(), this_ptr);
                    // Store at index 0
                    let idx = builder.ins().iconst(types::I32, 0);
                    builder.ins().call(set_ref, &[closure_ptr, idx, this_f64]);
                    1 // Offset other captures by 1 (we stored `this` at slot 0)
                } else {
                    // No this_ctx available - this can happen when method bodies are inlined
                    // Try to find a local variable of the enclosing class type to use as `this`
                    let mut found_this = false;
                    if let Some(class_name) = enclosing_class {
                        // Search locals for a variable of this class type
                        for (_, info) in locals.iter() {
                            if let Some(ref var_class) = info.class_name {
                                if var_class == class_name {
                                    // Found a variable of the right class type - use it as `this`
                                    let this_ptr = builder.use_var(info.var);
                                    let this_f64 = builder.ins().bitcast(types::F64, MemFlags::new(), this_ptr);
                                    let idx = builder.ins().iconst(types::I32, 0);
                                    builder.ins().call(set_ref, &[closure_ptr, idx, this_f64]);
                                    found_this = true;
                                    break;
                                }
                            }
                        }
                    }
                    if !found_this {
                        // Fallback: store null pointer (will crash if used)
                        let null_ptr = builder.ins().iconst(types::I64, 0);
                        let null_f64 = builder.ins().bitcast(types::F64, MemFlags::new(), null_ptr);
                        let idx = builder.ins().iconst(types::I32, 0);
                        builder.ins().call(set_ref, &[closure_ptr, idx, null_f64]);
                    }
                    1 // Offset by 1 since we stored something at slot 0
                }
            } else {
                0
            };

            // Build a set of mutable capture IDs for fast lookup
            let mutable_set: std::collections::HashSet<_> = mutable_captures.iter().copied().collect();

            // Store captured variables
            if !captures.is_empty() {
                let box_alloc_func = extern_funcs.get("js_box_alloc")
                    .ok_or_else(|| anyhow!("js_box_alloc not declared"))?;
                let box_alloc_ref = module.declare_func_in_func(*box_alloc_func, builder.func);

                for (i, capture_id) in captures.iter().enumerate() {
                    if let Some(info) = locals.get(capture_id) {
                        let val = builder.use_var(info.var);

                        let val_to_store = if mutable_set.contains(capture_id) {
                            // For mutable captures, allocate a box and store the box pointer
                            // Ensure value is f64 for js_box_alloc
                            let val_type = builder.func.dfg.value_type(val);
                            let val_f64 = if val_type == types::I64 {
                                builder.ins().bitcast(types::F64, MemFlags::new(), val)
                            } else {
                                val
                            };
                            // Allocate box with current value
                            let box_call = builder.ins().call(box_alloc_ref, &[val_f64]);
                            let box_ptr = builder.inst_results(box_call)[0];
                            // Convert box pointer to f64 for storage
                            builder.ins().bitcast(types::F64, MemFlags::new(), box_ptr)
                        } else {
                            // For immutable captures, store the value directly
                            // Ensure it's f64 for closure storage
                            let val_type = builder.func.dfg.value_type(val);
                            if val_type == types::I64 {
                                // If capturing a string pointer, NaN-box it with STRING_TAG
                                // so it can be properly identified and handled later
                                if info.is_string {
                                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                                        .expect("js_nanbox_string not declared");
                                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                    let call = builder.ins().call(nanbox_ref, &[val]);
                                    builder.inst_results(call)[0]
                                } else if info.is_closure {
                                    // Closure pointers can be bitcast directly
                                    builder.ins().bitcast(types::F64, MemFlags::new(), val)
                                } else {
                                    // Other pointer types (arrays, objects) - NaN-box with POINTER_TAG
                                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                        .expect("js_nanbox_pointer not declared");
                                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                                    let call = builder.ins().call(nanbox_ref, &[val]);
                                    builder.inst_results(call)[0]
                                }
                            } else {
                                val
                            }
                        };

                        // Index is offset by capture_offset (1 if captures_this, 0 otherwise)
                        let idx = builder.ins().iconst(types::I32, (i + capture_offset) as i64);
                        builder.ins().call(set_ref, &[closure_ptr, idx, val_to_store]);
                    }
                }
            }

            // Return closure pointer as i64 (pointers are i64)
            Ok(closure_ptr)
        }
        Expr::Await(inner) => {
            // Evaluate the inner expression (should be a Promise pointer)
            let promise_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, inner, this_ctx)?;

            // Get the promise pointer. The value could be:
            // - I64: raw pointer (from function returning Promise type, or async function call)
            // - F64: NaN-boxed pointer (from Promise.resolve/reject, variables, etc.)
            let promise_val_type = builder.func.dfg.value_type(promise_val);
            let promise_ptr = if promise_val_type == types::I64 {
                // Already an I64 pointer, use directly
                promise_val
            } else {
                // F64 - need to extract the pointer from NaN-boxed value
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[promise_val]);
                builder.inst_results(call)[0]
            };

            // Implement a busy-wait loop that runs microtasks until the promise settles
            //
            // Structure:
            //   check_block: check state, if pending -> wait_block, else -> settled_block
            //   wait_block: run microtasks, jump to check_block
            //   settled_block: check if rejected -> reject_block, else -> done_block
            //   reject_block: get reason and throw
            //   done_block: get value and continue

            let check_block = builder.create_block();
            let wait_block = builder.create_block();
            let settled_block = builder.create_block();
            let reject_block = builder.create_block();
            let done_block = builder.create_block();

            // Pass the promise pointer as a block parameter to maintain SSA
            builder.append_block_param(check_block, types::I64);
            builder.append_block_param(settled_block, types::I64);
            builder.append_block_param(reject_block, types::I64);
            builder.append_block_param(done_block, types::I64);

            // Jump to check_block with the promise pointer
            builder.ins().jump(check_block, &[promise_ptr]);

            // === check_block: check if promise is still pending ===
            builder.switch_to_block(check_block);
            let check_promise_ptr = builder.block_params(check_block)[0];

            // Call js_promise_state to get the state (0=pending, 1=fulfilled, 2=rejected)
            let state_func = extern_funcs.get("js_promise_state")
                .ok_or_else(|| anyhow!("js_promise_state not declared"))?;
            let state_ref = module.declare_func_in_func(*state_func, builder.func);
            let call = builder.ins().call(state_ref, &[check_promise_ptr]);
            let state = builder.inst_results(call)[0];

            // Check if state == 0 (pending)
            let zero = builder.ins().iconst(types::I32, 0);
            let is_pending = builder.ins().icmp(IntCC::Equal, state, zero);

            // If pending, go to wait_block; otherwise go to settled_block
            builder.ins().brif(is_pending, wait_block, &[], settled_block, &[check_promise_ptr]);

            // === wait_block: run microtasks, sleep briefly, and loop back ===
            builder.switch_to_block(wait_block);
            builder.seal_block(wait_block);

            // Call js_promise_run_microtasks to process any pending callbacks (including timers)
            let microtasks_func = extern_funcs.get("js_promise_run_microtasks")
                .ok_or_else(|| anyhow!("js_promise_run_microtasks not declared"))?;
            let microtasks_ref = module.declare_func_in_func(*microtasks_func, builder.func);
            builder.ins().call(microtasks_ref, &[]);

            // Also process stdlib async resolutions (mysql2, pg, etc.)
            if let Some(stdlib_pending_func) = extern_funcs.get("js_stdlib_process_pending") {
                let stdlib_ref = module.declare_func_in_func(*stdlib_pending_func, builder.func);
                builder.ins().call(stdlib_ref, &[]);
            }

            // Sleep for 1ms to avoid busy-waiting (allows timers to advance)
            let sleep_func = extern_funcs.get("js_sleep_ms")
                .ok_or_else(|| anyhow!("js_sleep_ms not declared"))?;
            let sleep_ref = module.declare_func_in_func(*sleep_func, builder.func);
            let one_ms = builder.ins().f64const(1.0);
            builder.ins().call(sleep_ref, &[one_ms]);

            // Jump back to check_block
            builder.ins().jump(check_block, &[check_promise_ptr]);

            // Now seal check_block since both predecessors (entry and wait_block) are done
            builder.seal_block(check_block);

            // === settled_block: check if promise was rejected ===
            builder.switch_to_block(settled_block);
            builder.seal_block(settled_block);
            let settled_promise_ptr = builder.block_params(settled_block)[0];

            // Get the state again to check if rejected
            let call = builder.ins().call(state_ref, &[settled_promise_ptr]);
            let settled_state = builder.inst_results(call)[0];

            // Check if state == 2 (rejected)
            let two = builder.ins().iconst(types::I32, 2);
            let is_rejected = builder.ins().icmp(IntCC::Equal, settled_state, two);

            // If rejected, go to reject_block; otherwise go to done_block
            builder.ins().brif(is_rejected, reject_block, &[settled_promise_ptr], done_block, &[settled_promise_ptr]);

            // === reject_block: get reason and throw ===
            builder.switch_to_block(reject_block);
            builder.seal_block(reject_block);
            let reject_promise_ptr = builder.block_params(reject_block)[0];

            // Get the rejection reason
            let reason_func = extern_funcs.get("js_promise_reason")
                .ok_or_else(|| anyhow!("js_promise_reason not declared"))?;
            let reason_ref = module.declare_func_in_func(*reason_func, builder.func);
            let call = builder.ins().call(reason_ref, &[reject_promise_ptr]);
            let reason = builder.inst_results(call)[0];

            // Throw the rejection reason
            let throw_func = extern_funcs.get("js_throw")
                .ok_or_else(|| anyhow!("js_throw not declared"))?;
            let throw_ref = module.declare_func_in_func(*throw_func, builder.func);
            builder.ins().call(throw_ref, &[reason]);

            // js_throw never returns, but Cranelift needs a terminator
            let unreachable_block = builder.create_block();
            builder.ins().jump(unreachable_block, &[]);
            builder.switch_to_block(unreachable_block);
            builder.seal_block(unreachable_block);
            builder.ins().trap(TrapCode::user(1).unwrap());

            // === done_block: promise is resolved, get the value ===
            builder.switch_to_block(done_block);
            builder.seal_block(done_block);
            let done_promise_ptr = builder.block_params(done_block)[0];

            // Get the resolved value
            let value_func = extern_funcs.get("js_promise_value")
                .ok_or_else(|| anyhow!("js_promise_value not declared"))?;
            let value_ref = module.declare_func_in_func(*value_func, builder.func);
            let call = builder.ins().call(value_ref, &[done_promise_ptr]);
            let value = builder.inst_results(call)[0];

            Ok(value)
        }
        Expr::NativeModuleRef(module_name) => {
            // Create a native module namespace object for `import * as X from 'module'`
            // This allows typeof to return "object" and console.log to show something meaningful
            let bytes = module_name.as_bytes();
            let len = bytes.len();

            // Create a stack slot for the module name bytes
            let slot = builder.create_sized_stack_slot(StackSlotData::new(
                StackSlotKind::ExplicitSlot,
                len.max(1) as u32,
                0,
            ));

            // Store the module name bytes
            let mut offset = 0usize;
            while offset + 8 <= len {
                let chunk = &bytes[offset..offset + 8];
                let val = u64::from_le_bytes(chunk.try_into().unwrap());
                let val_i64 = builder.ins().iconst(types::I64, val as i64);
                builder.ins().stack_store(val_i64, slot, offset as i32);
                offset += 8;
            }
            while offset < len {
                let byte_val = builder.ins().iconst(types::I8, bytes[offset] as i64);
                builder.ins().stack_store(byte_val, slot, offset as i32);
                offset += 1;
            }

            // Get pointer to the stack slot
            let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
            let len_val = builder.ins().iconst(types::I64, len as i64);

            // Call js_create_native_module_namespace(module_name_ptr, module_name_len)
            let create_func = extern_funcs.get("js_create_native_module_namespace")
                .ok_or_else(|| anyhow!("js_create_native_module_namespace not declared"))?;
            let create_ref = module.declare_func_in_func(*create_func, builder.func);
            let call = builder.ins().call(create_ref, &[slot_addr, len_val]);
            let result = builder.inst_results(call)[0];

            Ok(result)
        }
        Expr::NativeMethodCall { module: native_module, class_name, object, method, args } => {
            // Compile arguments first
            let arg_vals: Vec<Value> = args.iter()
                .map(|a| compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, a, this_ctx))
                .collect::<Result<_>>()?;

            // Check if this is a Pool, PoolConnection, or Connection instance
            let is_pool = class_name.as_deref() == Some("Pool");
            let is_pool_connection = class_name.as_deref() == Some("PoolConnection");

            // Determine which FFI function to call based on module, class, and method
            let func_name = match (native_module.as_str(), object.is_some(), method.as_str()) {
                // mysql2 module functions (no object)
                ("mysql2" | "mysql2/promise", false, "createConnection") => "js_mysql2_create_connection",
                ("mysql2" | "mysql2/promise", false, "createPool") => "js_mysql2_create_pool",

                // mysql2 methods - use Pool, PoolConnection, or Connection functions based on class_name
                ("mysql2" | "mysql2/promise", true, "query") if is_pool => "js_mysql2_pool_query",
                ("mysql2" | "mysql2/promise", true, "query") if is_pool_connection => "js_mysql2_pool_connection_query",
                ("mysql2" | "mysql2/promise", true, "query") => "js_mysql2_connection_query",
                ("mysql2" | "mysql2/promise", true, "execute") if is_pool => "js_mysql2_pool_execute",
                ("mysql2" | "mysql2/promise", true, "execute") if is_pool_connection => "js_mysql2_pool_connection_execute",
                ("mysql2" | "mysql2/promise", true, "execute") => "js_mysql2_connection_execute",
                ("mysql2" | "mysql2/promise", true, "end") if is_pool => "js_mysql2_pool_end",
                ("mysql2" | "mysql2/promise", true, "end") => "js_mysql2_connection_end",
                ("mysql2" | "mysql2/promise", true, "getConnection") => "js_mysql2_pool_get_connection",
                ("mysql2" | "mysql2/promise", true, "release") => "js_mysql2_pool_connection_release",
                ("mysql2" | "mysql2/promise", true, "beginTransaction") => "js_mysql2_connection_begin_transaction",
                ("mysql2" | "mysql2/promise", true, "commit") => "js_mysql2_connection_commit",
                ("mysql2" | "mysql2/promise", true, "rollback") => "js_mysql2_connection_rollback",

                // uuid module functions (no object)
                ("uuid", false, "v4") => "js_uuid_v4",
                ("uuid", false, "v1") => "js_uuid_v1",
                ("uuid", false, "v7") => "js_uuid_v7",
                ("uuid", false, "validate") => "js_uuid_validate",
                ("uuid", false, "version") => "js_uuid_version",

                // bcrypt module functions (no object)
                ("bcrypt", false, "hash") => "js_bcrypt_hash",
                ("bcrypt", false, "compare") => "js_bcrypt_compare",
                ("bcrypt", false, "genSalt") => "js_bcrypt_gen_salt",
                ("bcrypt", false, "hashSync") => "js_bcrypt_hash_sync",
                ("bcrypt", false, "compareSync") => "js_bcrypt_compare_sync",

                // ioredis module functions (constructor handled via New expr)
                ("ioredis", true, "set") => "js_ioredis_set",
                ("ioredis", true, "get") => "js_ioredis_get",
                ("ioredis", true, "del") => "js_ioredis_del",
                ("ioredis", true, "exists") => "js_ioredis_exists",
                ("ioredis", true, "incr") => "js_ioredis_incr",
                ("ioredis", true, "decr") => "js_ioredis_decr",
                ("ioredis", true, "expire") => "js_ioredis_expire",
                ("ioredis", true, "quit") => "js_ioredis_quit",

                // crypto module functions (no object)
                ("crypto", false, "sha256") => "js_crypto_sha256",
                ("crypto", false, "md5") => "js_crypto_md5",
                ("crypto", false, "randomBytes") => "js_crypto_random_bytes_hex",
                ("crypto", false, "randomUUID") => "js_crypto_random_uuid",
                ("crypto", false, "hmacSha256") => "js_crypto_hmac_sha256",

                // zlib module functions (no object)
                ("zlib", false, "gzipSync") => "js_zlib_gzip_sync",
                ("zlib", false, "gunzipSync") => "js_zlib_gunzip_sync",
                ("zlib", false, "deflateSync") => "js_zlib_deflate_sync",
                ("zlib", false, "inflateSync") => "js_zlib_inflate_sync",
                ("zlib", false, "gzip") => "js_zlib_gzip",
                ("zlib", false, "gunzip") => "js_zlib_gunzip",

                // node-fetch module functions (no object for fetch itself)
                ("node-fetch", false, "fetch") => "js_fetch_get",
                ("node-fetch", false, "fetchText") => "js_fetch_text",
                // Response methods (with object)
                ("node-fetch", true, "text") => "js_fetch_response_text",
                ("node-fetch", true, "json") => "js_fetch_response_json",
                ("node-fetch", true, "status") => "js_fetch_response_status",
                ("node-fetch", true, "ok") => "js_fetch_response_ok",
                ("node-fetch", true, "statusText") => "js_fetch_response_status_text",

                // Global fetch Response methods (from await fetch(...))
                ("fetch", true, "text") => "js_fetch_response_text",
                ("fetch", true, "json") => "js_fetch_response_json",
                ("fetch", true, "status") => "js_fetch_response_status",
                ("fetch", true, "ok") => "js_fetch_response_ok",
                ("fetch", true, "statusText") => "js_fetch_response_status_text",

                // ws module functions
                ("ws", false, "connect") => "js_ws_connect",
                ("ws", true, "send") => "js_ws_send",
                ("ws", true, "close") => "js_ws_close",
                ("ws", true, "isOpen") => "js_ws_is_open",
                ("ws", true, "receive") => "js_ws_receive",
                ("ws", true, "messageCount") => "js_ws_message_count",
                ("ws", true, "waitForMessage") => "js_ws_wait_for_message",

                // events module (EventEmitter)
                ("events", true, "on") => "js_event_emitter_on",
                ("events", true, "emit") => "js_event_emitter_emit",
                ("events", true, "removeListener") => "js_event_emitter_remove_listener",
                ("events", true, "off") => "js_event_emitter_remove_listener", // alias
                ("events", true, "removeAllListeners") => "js_event_emitter_remove_all_listeners",
                ("events", true, "listenerCount") => "js_event_emitter_listener_count",

                // lru-cache module (LRUCache)
                ("lru-cache", true, "get") => "js_lru_cache_get",
                ("lru-cache", true, "set") => "js_lru_cache_set",
                ("lru-cache", true, "has") => "js_lru_cache_has",
                ("lru-cache", true, "delete") => "js_lru_cache_delete",
                ("lru-cache", true, "clear") => "js_lru_cache_clear",
                ("lru-cache", true, "size") => "js_lru_cache_size",
                ("lru-cache", true, "peek") => "js_lru_cache_peek",

                // commander module (Command)
                ("commander", true, "name") => "js_commander_name",
                ("commander", true, "description") => "js_commander_description",
                ("commander", true, "version") => "js_commander_version",
                ("commander", true, "option") => "js_commander_option",
                ("commander", true, "parse") => "js_commander_parse",
                ("commander", true, "opts") => "js_commander_opts",

                // big.js / decimal.js / bignumber.js module
                ("big.js", true, "plus") => "js_decimal_plus",
                ("big.js", true, "minus") => "js_decimal_minus",
                ("big.js", true, "times") => "js_decimal_times",
                ("big.js", true, "div") => "js_decimal_div",
                ("big.js", true, "toFixed") => "js_decimal_to_fixed",
                ("big.js", true, "toString") => "js_decimal_to_string",
                ("big.js", true, "toNumber") => "js_decimal_to_number",
                ("big.js", true, "sqrt") => "js_decimal_sqrt",
                ("big.js", true, "abs") => "js_decimal_abs",
                ("big.js", true, "eq") => "js_decimal_eq",
                ("big.js", true, "lt") => "js_decimal_lt",
                ("big.js", true, "gt") => "js_decimal_gt",
                ("decimal.js", true, "plus") => "js_decimal_plus",
                ("decimal.js", true, "minus") => "js_decimal_minus",
                ("decimal.js", true, "times") => "js_decimal_times",
                ("decimal.js", true, "div") => "js_decimal_div",
                ("decimal.js", true, "toFixed") => "js_decimal_to_fixed",
                ("decimal.js", true, "toString") => "js_decimal_to_string",
                ("decimal.js", true, "toNumber") => "js_decimal_to_number",
                ("decimal.js", true, "sqrt") => "js_decimal_sqrt",
                ("decimal.js", true, "abs") => "js_decimal_abs",
                ("decimal.js", true, "eq") => "js_decimal_eq",
                ("decimal.js", true, "lt") => "js_decimal_lt",
                ("decimal.js", true, "gt") => "js_decimal_gt",
                ("bignumber.js", true, "plus") => "js_decimal_plus",
                ("bignumber.js", true, "minus") => "js_decimal_minus",
                ("bignumber.js", true, "times") => "js_decimal_times",
                ("bignumber.js", true, "div") => "js_decimal_div",
                ("bignumber.js", true, "toFixed") => "js_decimal_to_fixed",
                ("bignumber.js", true, "toString") => "js_decimal_to_string",
                ("bignumber.js", true, "toNumber") => "js_decimal_to_number",

                // Tier 3: dotenv module
                ("dotenv", false, "config") => "js_dotenv_config",
                ("dotenv", false, "parse") => "js_dotenv_parse",

                // Tier 3: jsonwebtoken module
                ("jsonwebtoken", false, "sign") => "js_jwt_sign",
                ("jsonwebtoken", false, "verify") => "js_jwt_verify",
                ("jsonwebtoken", false, "decode") => "js_jwt_decode",

                // Tier 3: nanoid module
                ("nanoid", false, "nanoid") => "js_nanoid",
                ("nanoid", false, "customAlphabet") => "js_nanoid_custom",

                // Tier 3: slugify module
                ("slugify", false, "slugify") => "js_slugify",
                ("slugify", true, "strict") => "js_slugify_strict",

                // Tier 3: validator module
                ("validator", false, "isEmail") => "js_validator_is_email",
                ("validator", false, "isURL") => "js_validator_is_url",
                ("validator", false, "isUUID") => "js_validator_is_uuid",
                ("validator", false, "isAlpha") => "js_validator_is_alpha",
                ("validator", false, "isAlphanumeric") => "js_validator_is_alphanumeric",
                ("validator", false, "isNumeric") => "js_validator_is_numeric",
                ("validator", false, "isHexadecimal") => "js_validator_is_hexadecimal",
                ("validator", false, "isInt") => "js_validator_is_int",
                ("validator", false, "isFloat") => "js_validator_is_float",
                ("validator", false, "isEmpty") => "js_validator_is_empty",
                ("validator", false, "isJSON") => "js_validator_is_json",
                ("validator", false, "isLowercase") => "js_validator_is_lowercase",
                ("validator", false, "isUppercase") => "js_validator_is_uppercase",
                ("validator", false, "contains") => "js_validator_contains",
                ("validator", false, "equals") => "js_validator_equals",
                ("validator", false, "isLength") => "js_validator_is_length",

                // Tier 4: pg (PostgreSQL) module
                ("pg", false, "connect") => "js_pg_connect",
                ("pg", false, "Pool") => "js_pg_create_pool",
                ("pg", true, "query") => "js_pg_client_query",
                ("pg", true, "end") => "js_pg_client_end",

                // Tier 4: nodemailer module
                ("nodemailer", false, "createTransport") => "js_nodemailer_create_transport",
                ("nodemailer", true, "sendMail") => "js_nodemailer_send_mail",
                ("nodemailer", true, "verify") => "js_nodemailer_verify",

                // Tier 4: crypto extended
                ("crypto", false, "aes256Encrypt") => "js_crypto_aes256_encrypt",
                ("crypto", false, "aes256Decrypt") => "js_crypto_aes256_decrypt",
                ("crypto", false, "pbkdf2Sync") => "js_crypto_pbkdf2",
                ("crypto", false, "scryptSync") => "js_crypto_scrypt",

                // Tier 4: dayjs module
                ("dayjs", false, "dayjs") => "js_dayjs_now",
                ("dayjs", true, "format") => "js_dayjs_format",
                ("dayjs", true, "toISOString") => "js_dayjs_to_iso_string",
                ("dayjs", true, "valueOf") => "js_dayjs_value_of",
                ("dayjs", true, "unix") => "js_dayjs_unix",
                ("dayjs", true, "year") => "js_dayjs_year",
                ("dayjs", true, "month") => "js_dayjs_month",
                ("dayjs", true, "date") => "js_dayjs_date",
                ("dayjs", true, "day") => "js_dayjs_day",
                ("dayjs", true, "hour") => "js_dayjs_hour",
                ("dayjs", true, "minute") => "js_dayjs_minute",
                ("dayjs", true, "second") => "js_dayjs_second",
                ("dayjs", true, "millisecond") => "js_dayjs_millisecond",
                ("dayjs", true, "add") => "js_dayjs_add",
                ("dayjs", true, "subtract") => "js_dayjs_subtract",
                ("dayjs", true, "startOf") => "js_dayjs_start_of",
                ("dayjs", true, "endOf") => "js_dayjs_end_of",
                ("dayjs", true, "diff") => "js_dayjs_diff",
                ("dayjs", true, "isBefore") => "js_dayjs_is_before",
                ("dayjs", true, "isAfter") => "js_dayjs_is_after",
                ("dayjs", true, "isSame") => "js_dayjs_is_same",
                ("dayjs", true, "isValid") => "js_dayjs_is_valid",

                // Tier 4: date-fns module
                ("date-fns", false, "format") => "js_datefns_format",
                ("date-fns", false, "parseISO") => "js_datefns_parse_iso",
                ("date-fns", false, "addDays") => "js_datefns_add_days",
                ("date-fns", false, "addMonths") => "js_datefns_add_months",
                ("date-fns", false, "addYears") => "js_datefns_add_years",
                ("date-fns", false, "differenceInDays") => "js_datefns_difference_in_days",
                ("date-fns", false, "differenceInHours") => "js_datefns_difference_in_hours",
                ("date-fns", false, "differenceInMinutes") => "js_datefns_difference_in_minutes",
                ("date-fns", false, "isAfter") => "js_datefns_is_after",
                ("date-fns", false, "isBefore") => "js_datefns_is_before",
                ("date-fns", false, "startOfDay") => "js_datefns_start_of_day",
                ("date-fns", false, "endOfDay") => "js_datefns_end_of_day",

                // ========================================================================
                // Tier 5: axios (HTTP client)
                // ========================================================================
                ("axios", false, "get") => "js_axios_get",
                ("axios", false, "post") => "js_axios_post",
                ("axios", false, "put") => "js_axios_put",
                ("axios", false, "delete") => "js_axios_delete",
                ("axios", false, "request") => "js_axios_request",
                ("axios", false, "create") => "js_axios_create",

                // ========================================================================
                // Tier 5: argon2 (password hashing)
                // ========================================================================
                ("argon2", false, "hash") => "js_argon2_hash",
                ("argon2", false, "hashOptions") => "js_argon2_hash_options",
                ("argon2", false, "verify") => "js_argon2_verify",

                // ========================================================================
                // Tier 5: mongodb
                // ========================================================================
                ("mongodb", false, "connect") => "js_mongodb_connect",
                ("mongodb", true, "db") => "js_mongodb_client_db",
                ("mongodb", true, "collection") => "js_mongodb_db_collection",
                ("mongodb", true, "findOne") => "js_mongodb_collection_find_one",
                ("mongodb", true, "find") => "js_mongodb_collection_find",
                ("mongodb", true, "insertOne") => "js_mongodb_collection_insert_one",
                ("mongodb", true, "insertMany") => "js_mongodb_collection_insert_many",
                ("mongodb", true, "updateOne") => "js_mongodb_collection_update_one",
                ("mongodb", true, "updateMany") => "js_mongodb_collection_update_many",
                ("mongodb", true, "deleteOne") => "js_mongodb_collection_delete_one",
                ("mongodb", true, "deleteMany") => "js_mongodb_collection_delete_many",
                ("mongodb", true, "countDocuments") => "js_mongodb_collection_count",
                ("mongodb", true, "close") => "js_mongodb_client_close",

                // ========================================================================
                // Tier 5: better-sqlite3 (SQLite)
                // ========================================================================
                ("better-sqlite3", false, "open") => "js_sqlite_open",
                ("better-sqlite3", true, "prepare") => "js_sqlite_prepare",
                ("better-sqlite3", true, "run") => "js_sqlite_stmt_run",
                ("better-sqlite3", true, "get") => "js_sqlite_stmt_get",
                ("better-sqlite3", true, "all") => "js_sqlite_stmt_all",
                ("better-sqlite3", true, "exec") => "js_sqlite_exec",
                ("better-sqlite3", true, "close") => "js_sqlite_close",
                ("better-sqlite3", true, "transaction") => "js_sqlite_transaction",
                ("better-sqlite3", true, "commit") => "js_sqlite_transaction_commit",
                ("better-sqlite3", true, "rollback") => "js_sqlite_transaction_rollback",

                // ========================================================================
                // Tier 5: sharp (image processing)
                // ========================================================================
                ("sharp", false, "fromFile") => "js_sharp_from_file",
                ("sharp", false, "fromBuffer") => "js_sharp_from_buffer",
                ("sharp", true, "resize") => "js_sharp_resize",
                ("sharp", true, "rotate") => "js_sharp_rotate",
                ("sharp", true, "blur") => "js_sharp_blur",
                ("sharp", true, "grayscale") => "js_sharp_grayscale",
                ("sharp", true, "flip") => "js_sharp_flip",
                ("sharp", true, "flop") => "js_sharp_flop",
                ("sharp", true, "negate") => "js_sharp_negate",
                ("sharp", true, "toFormat") => "js_sharp_to_format",
                ("sharp", true, "quality") => "js_sharp_quality",
                ("sharp", true, "toFile") => "js_sharp_to_file",
                ("sharp", true, "toBuffer") => "js_sharp_to_buffer",
                ("sharp", true, "metadata") => "js_sharp_metadata",

                // ========================================================================
                // Tier 5: cheerio (HTML parsing)
                // ========================================================================
                ("cheerio", false, "load") => "js_cheerio_load",
                ("cheerio", false, "loadFragment") => "js_cheerio_load_fragment",
                ("cheerio", true, "select") => "js_cheerio_select",
                ("cheerio", true, "text") => "js_cheerio_selection_text",
                ("cheerio", true, "html") => "js_cheerio_selection_html",
                ("cheerio", true, "attr") => "js_cheerio_selection_attr",
                ("cheerio", true, "length") => "js_cheerio_selection_length",
                ("cheerio", true, "first") => "js_cheerio_selection_first",
                ("cheerio", true, "last") => "js_cheerio_selection_last",
                ("cheerio", true, "eq") => "js_cheerio_selection_eq",
                ("cheerio", true, "find") => "js_cheerio_selection_find",
                ("cheerio", true, "children") => "js_cheerio_selection_children",
                ("cheerio", true, "parent") => "js_cheerio_selection_parent",
                ("cheerio", true, "hasClass") => "js_cheerio_selection_has_class",
                ("cheerio", true, "is") => "js_cheerio_selection_is",
                ("cheerio", true, "toArray") => "js_cheerio_selection_to_array",
                ("cheerio", true, "texts") => "js_cheerio_selection_texts",
                ("cheerio", true, "attrs") => "js_cheerio_selection_attrs",

                // ========================================================================
                // Tier 5: lodash (utility functions)
                // ========================================================================
                // Array functions
                ("lodash", false, "chunk") => "js_lodash_chunk",
                ("lodash", false, "compact") => "js_lodash_compact",
                ("lodash", false, "concat") => "js_lodash_concat",
                ("lodash", false, "difference") => "js_lodash_difference",
                ("lodash", false, "drop") => "js_lodash_drop",
                ("lodash", false, "dropRight") => "js_lodash_drop_right",
                ("lodash", false, "first") | ("lodash", false, "head") => "js_lodash_first",
                ("lodash", false, "last") => "js_lodash_last",
                ("lodash", false, "flatten") => "js_lodash_flatten",
                ("lodash", false, "initial") => "js_lodash_initial",
                ("lodash", false, "tail") => "js_lodash_tail",
                ("lodash", false, "take") => "js_lodash_take",
                ("lodash", false, "takeRight") => "js_lodash_take_right",
                ("lodash", false, "uniq") => "js_lodash_uniq",
                ("lodash", false, "reverse") => "js_lodash_reverse",
                ("lodash", false, "size") => "js_lodash_size",
                // String functions
                ("lodash", false, "camelCase") => "js_lodash_camel_case",
                ("lodash", false, "capitalize") => "js_lodash_capitalize",
                ("lodash", false, "kebabCase") => "js_lodash_kebab_case",
                ("lodash", false, "lowerCase") => "js_lodash_lower_case",
                ("lodash", false, "snakeCase") => "js_lodash_snake_case",
                ("lodash", false, "startCase") => "js_lodash_start_case",
                ("lodash", false, "upperCase") => "js_lodash_upper_case",
                ("lodash", false, "upperFirst") => "js_lodash_upper_first",
                ("lodash", false, "lowerFirst") => "js_lodash_lower_first",
                ("lodash", false, "trim") => "js_lodash_trim",
                ("lodash", false, "trimStart") => "js_lodash_trim_start",
                ("lodash", false, "trimEnd") => "js_lodash_trim_end",
                ("lodash", false, "pad") => "js_lodash_pad",
                ("lodash", false, "padStart") => "js_lodash_pad_start",
                ("lodash", false, "padEnd") => "js_lodash_pad_end",
                ("lodash", false, "repeat") => "js_lodash_repeat",
                ("lodash", false, "truncate") => "js_lodash_truncate",
                ("lodash", false, "startsWith") => "js_lodash_starts_with",
                ("lodash", false, "endsWith") => "js_lodash_ends_with",
                ("lodash", false, "includes") => "js_lodash_includes",
                ("lodash", false, "split") => "js_lodash_split",
                ("lodash", false, "replace") => "js_lodash_replace",
                ("lodash", false, "escape") => "js_lodash_escape",
                ("lodash", false, "unescape") => "js_lodash_unescape",
                // Number functions
                ("lodash", false, "clamp") => "js_lodash_clamp",
                ("lodash", false, "inRange") => "js_lodash_in_range",
                ("lodash", false, "random") => "js_lodash_random",

                // ========================================================================
                // Tier 5: moment (date manipulation)
                // ========================================================================
                ("moment", false, "moment") => "js_moment_now",
                ("moment", false, "fromTimestamp") => "js_moment_from_timestamp",
                ("moment", false, "parse") => "js_moment_parse",
                ("moment", true, "format") => "js_moment_format",
                ("moment", true, "valueOf") => "js_moment_value_of",
                ("moment", true, "unix") => "js_moment_unix",
                ("moment", true, "year") => "js_moment_year",
                ("moment", true, "month") => "js_moment_month",
                ("moment", true, "date") => "js_moment_date",
                ("moment", true, "day") => "js_moment_day",
                ("moment", true, "hour") => "js_moment_hour",
                ("moment", true, "minute") => "js_moment_minute",
                ("moment", true, "second") => "js_moment_second",
                ("moment", true, "millisecond") => "js_moment_millisecond",
                ("moment", true, "isValid") => "js_moment_is_valid",
                ("moment", true, "add") => "js_moment_add",
                ("moment", true, "subtract") => "js_moment_subtract",
                ("moment", true, "startOf") => "js_moment_start_of",
                ("moment", true, "endOf") => "js_moment_end_of",
                ("moment", true, "diff") => "js_moment_diff",

                // ========================================================================
                // Tier 5: node-cron (job scheduling)
                // ========================================================================
                ("node-cron", false, "validate") => "js_cron_validate",
                ("node-cron", false, "schedule") => "js_cron_schedule",
                ("node-cron", true, "start") => "js_cron_job_start",
                ("node-cron", true, "stop") => "js_cron_job_stop",
                ("node-cron", true, "isRunning") => "js_cron_job_is_running",
                ("node-cron", true, "nextDate") => "js_cron_next_date",
                ("node-cron", true, "nextDates") => "js_cron_next_dates",
                ("node-cron", false, "describe") => "js_cron_describe",
                // Timer helpers
                ("node-cron", false, "setInterval") => "js_cron_set_interval",
                ("node-cron", false, "clearInterval") => "js_cron_clear_interval",
                ("node-cron", false, "setTimeout") => "js_cron_set_timeout",
                ("node-cron", false, "clearTimeout") => "js_cron_clear_timeout",

                // ========================================================================
                // Tier 5: rate-limiter-flexible
                // ========================================================================
                ("rate-limiter-flexible", false, "create") => "js_ratelimit_create",
                ("rate-limiter-flexible", true, "consume") => "js_ratelimit_consume",
                ("rate-limiter-flexible", true, "get") => "js_ratelimit_get",
                ("rate-limiter-flexible", true, "delete") => "js_ratelimit_delete",
                ("rate-limiter-flexible", true, "block") => "js_ratelimit_block",
                ("rate-limiter-flexible", true, "penalty") => "js_ratelimit_penalty",
                ("rate-limiter-flexible", true, "reward") => "js_ratelimit_reward",

                // ========================================================================
                // ethers.js (blockchain utilities)
                // ========================================================================
                ("ethers", false, "formatUnits") => "js_ethers_format_units",
                ("ethers", false, "parseUnits") => "js_ethers_parse_units",
                ("ethers", false, "getAddress") => "js_ethers_get_address",
                ("ethers", false, "parseEther") => "js_ethers_parse_ether",
                ("ethers", false, "formatEther") => "js_ethers_format_ether",

                // ========================================================================
                // Fastify HTTP Framework
                // ========================================================================
                // Constructor (default export called as function)
                // Always uses _with_opts, passing undefined if no args
                ("fastify", false, "default") => "js_fastify_create_with_opts",
                // App methods (object = app instance)
                ("fastify", true, "get") => "js_fastify_get",
                ("fastify", true, "post") => "js_fastify_post",
                ("fastify", true, "put") => "js_fastify_put",
                ("fastify", true, "delete") => "js_fastify_delete",
                ("fastify", true, "patch") => "js_fastify_patch",
                ("fastify", true, "head") => "js_fastify_head",
                ("fastify", true, "options") => "js_fastify_options",
                ("fastify", true, "all") => "js_fastify_all",
                ("fastify", true, "route") => "js_fastify_route",
                ("fastify", true, "addHook") => "js_fastify_add_hook",
                ("fastify", true, "setErrorHandler") => "js_fastify_set_error_handler",
                ("fastify", true, "register") => "js_fastify_register",
                ("fastify", true, "listen") => "js_fastify_listen",
                // Request methods (on context.request or context)
                ("fastify", true, "method") => "js_fastify_req_method",
                ("fastify", true, "url") => "js_fastify_req_url",
                ("fastify", true, "params") => "js_fastify_req_params",
                ("fastify", true, "param") => "js_fastify_req_param",
                ("fastify", true, "query") => "js_fastify_req_query",
                ("fastify", true, "body") => "js_fastify_req_body",
                ("fastify", true, "json") => "js_fastify_req_json",
                ("fastify", true, "headers") => "js_fastify_req_headers",
                ("fastify", true, "header") => "js_fastify_req_header",
                // Reply methods (on context.reply or context)
                ("fastify", true, "status") => "js_fastify_reply_status",
                ("fastify", true, "send") => "js_fastify_reply_send",
                // Hono-style context methods
                ("fastify", true, "text") => "js_fastify_ctx_text",
                ("fastify", true, "html") => "js_fastify_ctx_html",
                ("fastify", true, "redirect") => "js_fastify_ctx_redirect",

                // ========================================================================
                // Node.js built-in: fs (file system)
                // ========================================================================
                ("fs", false, "existsSync") => "js_fs_exists_sync",
                ("fs", false, "readFileSync") => "js_fs_read_file_sync",
                ("fs", false, "writeFileSync") => "js_fs_write_file_sync",
                ("fs", false, "appendFileSync") => "js_fs_append_file_sync",
                ("fs", false, "mkdirSync") => "js_fs_mkdir_sync",
                ("fs", false, "unlinkSync") => "js_fs_unlink_sync",

                // ========================================================================
                // Node.js built-in: path
                // ========================================================================
                ("path", false, "dirname") => "js_path_dirname",
                ("path", false, "basename") => "js_path_basename",
                ("path", false, "extname") => "js_path_extname",
                ("path", false, "join") => "js_path_join",
                ("path", false, "resolve") => "js_path_resolve",

                _ => {
                    // If JS runtime is enabled, fall back to JS runtime for unsupported native methods
                    // For module-level calls (object is None), use js_call_function
                    // For instance method calls (object is Some), use js_native_call_method
                    if object.is_none() && extern_funcs.contains_key("js_call_function") {
                        // Module-level function call (e.g., ethers.id(...))
                        // Load the module and call the function via JS runtime

                        // Create string data for the module path
                        let path_bytes = native_module.as_bytes();
                        let path_len = path_bytes.len();

                        let path_data_id = module.declare_data(
                            &format!("__native_module_path_{}_{}", native_module.replace(['/', '.', '-'], "_"), next_js_data_id()),
                            Linkage::Local,
                            false,
                            false,
                        )?;
                        let mut data_desc = cranelift_module::DataDescription::new();
                        data_desc.define(path_bytes.to_vec().into_boxed_slice());
                        module.define_data(path_data_id, &data_desc)?;

                        let path_gv = module.declare_data_in_func(path_data_id, builder.func);
                        let path_ptr = builder.ins().global_value(types::I64, path_gv);
                        let path_len_val = builder.ins().iconst(types::I64, path_len as i64);

                        // Call js_load_module to get module handle
                        let load_func = extern_funcs.get("js_load_module")
                            .ok_or_else(|| anyhow!("js_load_module not declared"))?;
                        let load_ref = module.declare_func_in_func(*load_func, builder.func);
                        let load_call = builder.ins().call(load_ref, &[path_ptr, path_len_val]);
                        let module_handle = builder.inst_results(load_call)[0];

                        // Create string constant for function name
                        let name_bytes = method.as_bytes();
                        let name_len = name_bytes.len();

                        let name_data_id = module.declare_data(
                            &format!("__native_fallback_func_{}_{}", method, next_js_data_id()),
                            Linkage::Local,
                            false,
                            false,
                        )?;
                        let mut data_desc = cranelift_module::DataDescription::new();
                        data_desc.define(name_bytes.to_vec().into_boxed_slice());
                        module.define_data(name_data_id, &data_desc)?;

                        let name_gv = module.declare_data_in_func(name_data_id, builder.func);
                        let name_ptr = builder.ins().global_value(types::I64, name_gv);
                        let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

                        // Prepare arguments
                        let args_count = arg_vals.len();
                        if args_count > 0 {
                            let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                                cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                                (args_count * 8) as u32,
                                8,
                            ));
                            let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                            for (i, &arg_val_raw) in arg_vals.iter().enumerate() {
                                // Ensure argument is f64 for JS interop
                                let arg_val_type = builder.func.dfg.value_type(arg_val_raw);
                                let arg_val = if arg_val_type == types::I64 {
                                    builder.ins().bitcast(types::F64, MemFlags::new(), arg_val_raw)
                                } else {
                                    arg_val_raw
                                };
                                let offset = (i * 8) as i32;
                                builder.ins().store(MemFlags::new(), arg_val, args_ptr, offset);
                            }

                            let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                            let call_func = extern_funcs.get("js_call_function").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[module_handle, name_ptr, name_len_val, args_ptr, args_count_val]);
                            return Ok(builder.inst_results(call)[0]);
                        } else {
                            let null_ptr = builder.ins().iconst(types::I64, 0);
                            let zero_count = builder.ins().iconst(types::I64, 0);

                            let call_func = extern_funcs.get("js_call_function").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[module_handle, name_ptr, name_len_val, null_ptr, zero_count]);
                            return Ok(builder.inst_results(call)[0]);
                        }
                    } else if extern_funcs.contains_key("js_native_call_method") {
                        // Instance method call - compile object and use js_native_call_method
                        let obj_val_raw = if let Some(obj_expr) = object {
                            compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, obj_expr, this_ctx)?
                        } else {
                            return Err(anyhow!("Unsupported native method: {}.{}() - no object for js_native_call_method fallback", native_module, method));
                        };
                        // Ensure object value is f64 for JS interop
                        let obj_val_type = builder.func.dfg.value_type(obj_val_raw);
                        let obj_val = if obj_val_type == types::I64 {
                            builder.ins().bitcast(types::F64, MemFlags::new(), obj_val_raw)
                        } else {
                            obj_val_raw
                        };

                        // Create string constant for method name
                        let name_bytes = method.as_bytes();
                        let name_len = name_bytes.len();

                        let name_data_id = module.declare_data(
                            &format!("__native_fallback_method_{}_{}", method, next_js_data_id()),
                            Linkage::Local,
                            false,
                            false,
                        )?;
                        let mut data_desc = cranelift_module::DataDescription::new();
                        data_desc.define(name_bytes.to_vec().into_boxed_slice());
                        module.define_data(name_data_id, &data_desc)?;

                        let name_gv = module.declare_data_in_func(name_data_id, builder.func);
                        let name_ptr = builder.ins().global_value(types::I64, name_gv);
                        let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

                        // Compile arguments
                        let args_count = arg_vals.len();
                        if args_count > 0 {
                            let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                                cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                                (args_count * 8) as u32,
                                8,
                            ));
                            let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                            for (i, &arg_val_raw) in arg_vals.iter().enumerate() {
                                // Ensure argument is f64 for JS interop
                                let arg_val_type = builder.func.dfg.value_type(arg_val_raw);
                                let arg_val = if arg_val_type == types::I64 {
                                    builder.ins().bitcast(types::F64, MemFlags::new(), arg_val_raw)
                                } else {
                                    arg_val_raw
                                };
                                let offset = (i * 8) as i32;
                                builder.ins().store(MemFlags::new(), arg_val, args_ptr, offset);
                            }

                            let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                            let call_func = extern_funcs.get("js_native_call_method").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[obj_val, name_ptr, name_len_val, args_ptr, args_count_val]);
                            return Ok(builder.inst_results(call)[0]);
                        } else {
                            let null_ptr = builder.ins().iconst(types::I64, 0);
                            let zero_count = builder.ins().iconst(types::I64, 0);

                            let call_func = extern_funcs.get("js_native_call_method").unwrap();
                            let call_ref = module.declare_func_in_func(*call_func, builder.func);
                            let call = builder.ins().call(call_ref, &[obj_val, name_ptr, name_len_val, null_ptr, zero_count]);
                            return Ok(builder.inst_results(call)[0]);
                        }
                    }
                    return Err(anyhow!("Unsupported native method: {}.{}()", native_module, method));
                }
            };

            // Get the extern function
            let ext_func = extern_funcs.get(func_name)
                .ok_or_else(|| anyhow!("{} not declared", func_name))?;
            let func_ref = module.declare_func_in_func(*ext_func, builder.func);

            // Build call arguments based on the function
            let call_args = if let Some(obj_expr) = object {
                // Method call with object - object handle is first arg
                // Special handling for ExternFuncRef (imported native instance from another module)
                let obj_val = if let Expr::ExternFuncRef { name, .. } = obj_expr.as_ref() {
                    // This is an imported variable - look up the exported global from the other module
                    let global_name = format!("__export_{}", name);
                    // Declare the data as imported (will be resolved by linker)
                    let data_id = module.declare_data(&global_name, Linkage::Import, true, false)
                        .map_err(|e| anyhow!("Failed to import global {}: {}", global_name, e))?;
                    let global_val = module.declare_data_in_func(data_id, builder.func);
                    let ptr = builder.ins().global_value(types::I64, global_val);
                    builder.ins().load(types::F64, MemFlags::new(), ptr, 0)
                } else {
                    compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, obj_expr, this_ctx)?
                };

                // Handle (i64) is passed as first argument
                // For fetch module, the handle is a numeric ID (1, 2, 3...) stored as f64,
                // so we need to convert using fcvt_to_sint instead of bitcast.
                let handle = if native_module == "fetch" || native_module == "node-fetch" {
                    // Convert f64 response/connection ID to i64 using truncation
                    let obj_type = builder.func.dfg.value_type(obj_val);
                    if obj_type == types::F64 {
                        builder.ins().fcvt_to_sint(types::I64, obj_val)
                    } else {
                        obj_val
                    }
                } else if native_module == "mysql2" || native_module == "mysql2/promise" ||
                          native_module == "ioredis" ||
                          native_module == "ws" ||
                          native_module == "events" || native_module == "lru-cache" ||
                          native_module == "commander" || native_module == "ethers" ||
                          native_module == "decimal.js" || native_module == "big.js" ||
                          native_module == "bignumber.js" || native_module == "pg" ||
                          native_module == "mongodb" || native_module == "better-sqlite3" ||
                          native_module == "sharp" || native_module == "cheerio" ||
                          native_module == "nodemailer" || native_module == "dayjs" ||
                          native_module == "moment" || native_module == "node-cron" ||
                          native_module == "rate-limiter-flexible" ||
                          native_module == "fastify" {
                    // These modules return NaN-boxed pointers, extract the raw pointer
                    let obj_f64 = ensure_f64(builder, obj_val);
                    let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                    let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                    let call = builder.ins().call(get_ptr_ref, &[obj_f64]);
                    builder.inst_results(call)[0]
                } else {
                    ensure_i64(builder, obj_val)
                };

                let mut call_args = vec![handle];

                // For query/execute, convert string argument to pointer
                if method == "query" || method == "execute" {
                    if !arg_vals.is_empty() {
                        // SQL string is NaN-boxed, extract the raw string pointer
                        let sql_f64 = ensure_f64(builder, arg_vals[0]);
                        let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                            .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                        let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                        let str_call = builder.ins().call(get_str_ptr_ref, &[sql_f64]);
                        let sql_ptr = builder.inst_results(str_call)[0];
                        call_args.push(sql_ptr);
                    }
                    // For execute, always add params array (as i64 pointer)
                    // If no params provided, use null (0)
                    if method == "execute" {
                        if arg_vals.len() > 1 {
                            // Params array is NaN-boxed, extract the raw pointer
                            let params_f64 = ensure_f64(builder, arg_vals[1]);
                            let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                                .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                            let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                            let ptr_call = builder.ins().call(get_ptr_ref, &[params_f64]);
                            let params_ptr = builder.inst_results(ptr_call)[0];
                            call_args.push(params_ptr);
                        } else {
                            // No params provided - pass null
                            call_args.push(builder.ins().iconst(types::I64, 0));
                        }
                    }
                } else if native_module == "ioredis" {
                    // ioredis methods: set(key, value), get(key), del(key), exists(key), incr(key), decr(key), expire(key, secs), quit()
                    match method.as_str() {
                        "set" => {
                            // set(key, value) - both are NaN-boxed strings
                            if arg_vals.len() >= 2 {
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);

                                let key_f64 = ensure_f64(builder, arg_vals[0]);
                                let key_call = builder.ins().call(get_str_ptr_ref, &[key_f64]);
                                let key_ptr = builder.inst_results(key_call)[0];

                                let val_f64 = ensure_f64(builder, arg_vals[1]);
                                let val_call = builder.ins().call(get_str_ptr_ref, &[val_f64]);
                                let val_ptr = builder.inst_results(val_call)[0];

                                call_args.push(key_ptr);
                                call_args.push(val_ptr);
                            }
                        }
                        "get" | "del" | "exists" | "incr" | "decr" => {
                            // Single key argument - NaN-boxed string
                            if !arg_vals.is_empty() {
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                let key_f64 = ensure_f64(builder, arg_vals[0]);
                                let key_call = builder.ins().call(get_str_ptr_ref, &[key_f64]);
                                let key_ptr = builder.inst_results(key_call)[0];
                                call_args.push(key_ptr);
                            }
                        }
                        "expire" => {
                            // expire(key, seconds) - key is NaN-boxed string
                            if arg_vals.len() >= 2 {
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                let key_f64 = ensure_f64(builder, arg_vals[0]);
                                let key_call = builder.ins().call(get_str_ptr_ref, &[key_f64]);
                                let key_ptr = builder.inst_results(key_call)[0];
                                call_args.push(key_ptr);
                                call_args.push(arg_vals[1]); // seconds as f64
                            }
                        }
                        "quit" => {
                            // quit() - no additional args
                        }
                        _ => {}
                    }
                } else if native_module == "ws" {
                    // ws methods: send(message), close(), isOpen(), receive(), messageCount(), waitForMessage(timeout)
                    match method.as_str() {
                        "send" => {
                            // send(message) - message is NaN-boxed string
                            if !arg_vals.is_empty() {
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                let msg_f64 = ensure_f64(builder, arg_vals[0]);
                                let msg_call = builder.ins().call(get_str_ptr_ref, &[msg_f64]);
                                let msg_ptr = builder.inst_results(msg_call)[0];
                                call_args.push(msg_ptr);
                            }
                        }
                        "waitForMessage" => {
                            // waitForMessage(timeoutMs) - timeout is number
                            if !arg_vals.is_empty() {
                                call_args.push(arg_vals[0]); // timeout as f64
                            }
                        }
                        "close" | "isOpen" | "receive" | "messageCount" => {
                            // No additional args - just the handle
                        }
                        _ => {}
                    }
                } else if native_module == "events" {
                    // EventEmitter methods: on(event, callback), emit(event, arg), removeListener(event, callback), etc.
                    match method.as_str() {
                        "on" | "removeListener" | "off" => {
                            // on(eventName, callback) - eventName is NaN-boxed string, callback is closure
                            if arg_vals.len() >= 2 {
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                let event_f64 = ensure_f64(builder, arg_vals[0]);
                                let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                let event_ptr = builder.inst_results(event_call)[0];
                                let callback_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[1]);
                                call_args.push(event_ptr);
                                call_args.push(callback_ptr);
                            }
                        }
                        "emit" => {
                            // emit(eventName, arg) - eventName is NaN-boxed string, arg is any
                            if !arg_vals.is_empty() {
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                let event_f64 = ensure_f64(builder, arg_vals[0]);
                                let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                let event_ptr = builder.inst_results(event_call)[0];
                                call_args.push(event_ptr);
                                if arg_vals.len() >= 2 {
                                    // Ensure arg is f64 (objects/pointers need bitcast)
                                    call_args.push(ensure_f64(builder, arg_vals[1]));
                                } else {
                                    call_args.push(builder.ins().f64const(0.0)); // no argument
                                }
                            }
                        }
                        "removeAllListeners" => {
                            // removeAllListeners(eventName?) - eventName is optional NaN-boxed string
                            if !arg_vals.is_empty() {
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                let event_f64 = ensure_f64(builder, arg_vals[0]);
                                let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                let event_ptr = builder.inst_results(event_call)[0];
                                call_args.push(event_ptr);
                            } else {
                                call_args.push(builder.ins().iconst(types::I64, 0)); // null for no event name
                            }
                        }
                        "listenerCount" => {
                            // listenerCount(eventName) - eventName is NaN-boxed string
                            if !arg_vals.is_empty() {
                                let get_str_ptr_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ptr_ref = module.declare_func_in_func(*get_str_ptr_func, builder.func);
                                let event_f64 = ensure_f64(builder, arg_vals[0]);
                                let event_call = builder.ins().call(get_str_ptr_ref, &[event_f64]);
                                let event_ptr = builder.inst_results(event_call)[0];
                                call_args.push(event_ptr);
                            }
                        }
                        _ => {}
                    }
                } else if native_module == "lru-cache" {
                    // LRUCache methods: get(key), set(key, value), has(key), delete(key), clear(), size, peek(key)
                    match method.as_str() {
                        "get" | "has" | "delete" | "peek" => {
                            // Single key argument (number)
                            if !arg_vals.is_empty() {
                                call_args.push(arg_vals[0]); // key as f64
                            }
                        }
                        "set" => {
                            // set(key, value) - both numbers
                            if arg_vals.len() >= 2 {
                                call_args.push(arg_vals[0]); // key as f64
                                call_args.push(arg_vals[1]); // value as f64
                            }
                        }
                        "clear" | "size" => {
                            // No additional args - just the handle
                        }
                        _ => {}
                    }
                } else if native_module == "commander" {
                    // Commander methods: name(s), description(s), version(s), option(flags, desc, default?), parse()
                    match method.as_str() {
                        "name" | "description" | "version" => {
                            // Single string argument
                            if !arg_vals.is_empty() {
                                let str_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                call_args.push(str_ptr);
                            }
                        }
                        "option" => {
                            // option(flags, description, default?) - all strings
                            if arg_vals.len() >= 2 {
                                let flags_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                let desc_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[1]);
                                call_args.push(flags_ptr);
                                call_args.push(desc_ptr);
                                if arg_vals.len() >= 3 {
                                    let default_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[2]);
                                    call_args.push(default_ptr);
                                } else {
                                    call_args.push(builder.ins().iconst(types::I64, 0)); // null for no default
                                }
                            }
                        }
                        "parse" | "opts" => {
                            // No additional args - just the handle
                        }
                        _ => {}
                    }
                } else if native_module == "big.js" || native_module == "decimal.js" || native_module == "bignumber.js" {
                    // Decimal methods: plus(other), minus(other), times(other), div(other), toFixed(dp), toString(), toNumber()
                    match method.as_str() {
                        "plus" | "minus" | "times" | "div" | "eq" | "lt" | "gt" | "lte" | "gte" | "cmp" => {
                            // Binary operations - other is a Decimal handle or number
                            if !arg_vals.is_empty() {
                                // Assume it's another Decimal handle for now
                                let other_handle = builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]);
                                call_args.push(other_handle);
                            }
                        }
                        "toFixed" | "pow" => {
                            // Takes a number argument
                            if !arg_vals.is_empty() {
                                call_args.push(arg_vals[0]); // decimals/exponent as f64
                            } else {
                                call_args.push(builder.ins().f64const(0.0)); // default
                            }
                        }
                        "toString" | "toNumber" | "sqrt" | "abs" | "neg" | "round" | "floor" | "ceil" | "isZero" | "isPositive" | "isNegative" => {
                            // No additional args - just the handle
                        }
                        _ => {}
                    }
                } else if native_module == "node-fetch" {
                    // fetch response methods: text(), json(), status(), ok(), statusText()
                    // All response methods just take the handle - no additional args
                } else if native_module == "fastify" {
                    // Fastify instance methods
                    // NOTE: Fastify runtime expects NaN-boxed values as i64 bits, NOT extracted pointers.
                    // The runtime calls js_get_string_pointer_unified itself to extract strings.
                    match method.as_str() {
                        // Route methods: get(path, handler), post(path, handler), etc.
                        "get" | "post" | "put" | "delete" | "patch" | "head" | "options" | "all" => {
                            // (path: string, handler: closure)
                            if arg_vals.len() >= 2 {
                                // Pass NaN-boxed path string as i64 bits (runtime extracts it)
                                let path_f64 = ensure_f64(builder, arg_vals[0]);
                                let path_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), path_f64);
                                call_args.push(path_i64);

                                // Handler closure - pass as i64
                                call_args.push(ensure_i64(builder, arg_vals[1]));
                            }
                        }
                        "route" => {
                            // route(method, path, handler)
                            if arg_vals.len() >= 3 {
                                // Method string - NaN-boxed as i64 bits
                                let method_f64 = ensure_f64(builder, arg_vals[0]);
                                let method_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), method_f64);
                                call_args.push(method_i64);

                                // Path string - NaN-boxed as i64 bits
                                let path_f64 = ensure_f64(builder, arg_vals[1]);
                                let path_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), path_f64);
                                call_args.push(path_i64);

                                // Handler closure
                                call_args.push(ensure_i64(builder, arg_vals[2]));
                            }
                        }
                        "addHook" => {
                            // addHook(hookName, handler)
                            if arg_vals.len() >= 2 {
                                // Hook name - NaN-boxed as i64 bits
                                let name_f64 = ensure_f64(builder, arg_vals[0]);
                                let name_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), name_f64);
                                call_args.push(name_i64);
                                call_args.push(ensure_i64(builder, arg_vals[1]));
                            }
                        }
                        "setErrorHandler" => {
                            // setErrorHandler(handler)
                            if !arg_vals.is_empty() {
                                call_args.push(ensure_i64(builder, arg_vals[0]));
                            }
                        }
                        "register" => {
                            // register(plugin, opts)
                            if !arg_vals.is_empty() {
                                call_args.push(ensure_i64(builder, arg_vals[0])); // plugin closure
                            }
                            if arg_vals.len() >= 2 {
                                call_args.push(ensure_f64(builder, arg_vals[1])); // opts object
                            } else {
                                // No opts - pass undefined
                                const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                                call_args.push(builder.ins().f64const(f64::from_bits(TAG_UNDEFINED)));
                            }
                        }
                        "listen" => {
                            // listen(opts, callback)
                            if !arg_vals.is_empty() {
                                call_args.push(ensure_f64(builder, arg_vals[0])); // opts
                            } else {
                                const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                                call_args.push(builder.ins().f64const(f64::from_bits(TAG_UNDEFINED)));
                            }
                            if arg_vals.len() >= 2 {
                                call_args.push(ensure_i64(builder, arg_vals[1])); // callback
                            } else {
                                call_args.push(builder.ins().iconst(types::I64, 0)); // no callback
                            }
                        }
                        // Request/context methods - these take the context handle
                        "status" => {
                            // reply.status(code) - returns handle for chaining
                            if !arg_vals.is_empty() {
                                call_args.push(ensure_f64(builder, arg_vals[0])); // status code
                            }
                        }
                        "header" => {
                            // reply.header(name, value)
                            if arg_vals.len() >= 2 {
                                // Pass NaN-boxed strings as i64 bits
                                let name_f64 = ensure_f64(builder, arg_vals[0]);
                                let name_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), name_f64);
                                call_args.push(name_i64);

                                let val_f64 = ensure_f64(builder, arg_vals[1]);
                                let val_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), val_f64);
                                call_args.push(val_i64);
                            }
                        }
                        "send" => {
                            // reply.send(data)
                            if !arg_vals.is_empty() {
                                call_args.push(ensure_f64(builder, arg_vals[0]));
                            }
                        }
                        "json" => {
                            // c.json(data, status?) - Hono style
                            if !arg_vals.is_empty() {
                                call_args.push(ensure_f64(builder, arg_vals[0])); // data
                            }
                            if arg_vals.len() >= 2 {
                                call_args.push(ensure_f64(builder, arg_vals[1])); // status
                            } else {
                                call_args.push(builder.ins().f64const(0.0)); // default (use context's status)
                            }
                        }
                        "text" | "html" => {
                            // c.text(text, status?) or c.html(html, status?)
                            if !arg_vals.is_empty() {
                                // Pass NaN-boxed text as i64 bits
                                let text_f64 = ensure_f64(builder, arg_vals[0]);
                                let text_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), text_f64);
                                call_args.push(text_i64);
                            }
                            if arg_vals.len() >= 2 {
                                call_args.push(ensure_f64(builder, arg_vals[1])); // status
                            } else {
                                call_args.push(builder.ins().f64const(0.0));
                            }
                        }
                        "redirect" => {
                            // c.redirect(url, status?)
                            if !arg_vals.is_empty() {
                                // Pass NaN-boxed URL as i64 bits
                                let url_f64 = ensure_f64(builder, arg_vals[0]);
                                let url_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), url_f64);
                                call_args.push(url_i64);
                            }
                            if arg_vals.len() >= 2 {
                                call_args.push(ensure_f64(builder, arg_vals[1])); // status
                            } else {
                                call_args.push(builder.ins().f64const(0.0)); // default 302
                            }
                        }
                        "param" => {
                            // c.req.param(name) - get single param
                            if !arg_vals.is_empty() {
                                // Pass NaN-boxed name as i64 bits
                                let name_f64 = ensure_f64(builder, arg_vals[0]);
                                let name_i64 = builder.ins().bitcast(types::I64, MemFlags::new(), name_f64);
                                call_args.push(name_i64);
                            }
                        }
                        // Methods with no additional args
                        "method" | "url" | "params" | "query" | "body" | "headers" => {
                            // These just take the context handle - no additional args
                        }
                        _ => {}
                    }
                }

                call_args
            } else {
                // Module-level function call (e.g., createConnection, createPool, uuid.v4, etc.)
                // Convert f64 args to i64 for FFI calls
                if method == "createConnection" || method == "createPool" {
                    // Config object pointer - needs to be NaN-boxed as a pointer for JSValue
                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                        .expect("js_nanbox_pointer not declared");
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);

                    arg_vals.iter().map(|&val| {
                        // Get the raw pointer as i64
                        let ptr = builder.ins().bitcast(types::I64, MemFlags::new(), val);
                        // NaN-box it using js_nanbox_pointer
                        let call = builder.ins().call(nanbox_ref, &[ptr]);
                        let nanboxed = builder.inst_results(call)[0];
                        // The result is f64, bitcast to i64 for the FFI call
                        builder.ins().bitcast(types::I64, MemFlags::new(), nanboxed)
                    }).collect()
                } else if native_module == "uuid" && (method == "validate" || method == "version") {
                    // uuid.validate and uuid.version take a string pointer
                    arg_vals.iter().map(|&val| {
                        builder.ins().bitcast(types::I64, MemFlags::new(), val)
                    }).collect()
                } else if native_module == "uuid" {
                    // uuid.v4, uuid.v1, uuid.v7 take no arguments
                    vec![]
                } else if native_module == "bcrypt" {
                    // bcrypt functions
                    match method.as_str() {
                        "hash" => {
                            // hash(password, saltRounds) - password is string, saltRounds is number
                            let mut args = Vec::new();
                            if !arg_vals.is_empty() {
                                args.push(builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]));
                            }
                            if arg_vals.len() > 1 {
                                args.push(arg_vals[1]); // saltRounds as f64
                            }
                            args
                        }
                        "compare" | "compareSync" => {
                            // compare(password, hash) - both strings
                            arg_vals.iter().map(|&val| {
                                builder.ins().bitcast(types::I64, MemFlags::new(), val)
                            }).collect()
                        }
                        "genSalt" => {
                            // genSalt(rounds) - rounds is number
                            arg_vals.clone()
                        }
                        "hashSync" => {
                            // hashSync(password, saltRounds)
                            let mut args = Vec::new();
                            if !arg_vals.is_empty() {
                                args.push(builder.ins().bitcast(types::I64, MemFlags::new(), arg_vals[0]));
                            }
                            if arg_vals.len() > 1 {
                                args.push(arg_vals[1]); // saltRounds as f64
                            }
                            args
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "crypto" {
                    // crypto functions
                    match method.as_str() {
                        "sha256" | "md5" => {
                            // sha256(data), md5(data) - data is string
                            arg_vals.iter().map(|&val| {
                                builder.ins().bitcast(types::I64, MemFlags::new(), val)
                            }).collect()
                        }
                        "randomBytes" => {
                            // randomBytes(size) - size is number
                            arg_vals.clone()
                        }
                        "randomUUID" => {
                            // randomUUID() - no args
                            vec![]
                        }
                        "hmacSha256" => {
                            // hmacSha256(data, key) - both strings
                            arg_vals.iter().map(|&val| {
                                builder.ins().bitcast(types::I64, MemFlags::new(), val)
                            }).collect()
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "zlib" {
                    // zlib functions - all take data as string/buffer
                    match method.as_str() {
                        "gzipSync" | "gunzipSync" | "deflateSync" | "inflateSync" | "gzip" | "gunzip" => {
                            // All take data buffer as argument
                            arg_vals.iter().map(|&val| {
                                builder.ins().bitcast(types::I64, MemFlags::new(), val)
                            }).collect()
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "node-fetch" {
                    // fetch functions
                    match method.as_str() {
                        "fetch" | "fetchText" => {
                            // fetch(url) - url is NaN-boxed string, extract pointer
                            let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                            let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
                            arg_vals.iter().map(|&val| {
                                let val_f64 = ensure_f64(builder, val);
                                let call = builder.ins().call(get_str_ref, &[val_f64]);
                                builder.inst_results(call)[0]
                            }).collect()
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "ws" {
                    // ws module functions
                    match method.as_str() {
                        "connect" => {
                            // connect(url) - url is NaN-boxed string, extract pointer
                            let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                                .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                            let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
                            arg_vals.iter().map(|&val| {
                                let val_f64 = ensure_f64(builder, val);
                                let call = builder.ins().call(get_str_ref, &[val_f64]);
                                builder.inst_results(call)[0]
                            }).collect()
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "ethers" {
                    // ethers module functions
                    match method.as_str() {
                        "formatUnits" => {
                            // formatUnits(bigint, decimals) - bigint is NaN-boxed, decimals is f64
                            let mut args = Vec::new();
                            if !arg_vals.is_empty() {
                                // BigInt is NaN-boxed - extract raw pointer
                                let bigint_f64 = ensure_f64(builder, arg_vals[0]);
                                let get_bigint_func = extern_funcs.get("js_nanbox_get_bigint")
                                    .ok_or_else(|| anyhow!("js_nanbox_get_bigint not declared"))?;
                                let get_bigint_ref = module.declare_func_in_func(*get_bigint_func, builder.func);
                                let call = builder.ins().call(get_bigint_ref, &[bigint_f64]);
                                args.push(builder.inst_results(call)[0]);
                            }
                            if arg_vals.len() > 1 {
                                args.push(arg_vals[1]); // decimals as f64
                            } else {
                                args.push(builder.ins().f64const(18.0)); // default 18 decimals
                            }
                            args
                        }
                        "parseUnits" => {
                            // parseUnits(string, decimals) - string is NaN-boxed, decimals is f64
                            let mut args = Vec::new();
                            if !arg_vals.is_empty() {
                                // String is NaN-boxed - extract raw pointer
                                let str_f64 = ensure_f64(builder, arg_vals[0]);
                                let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
                                let call = builder.ins().call(get_str_ref, &[str_f64]);
                                args.push(builder.inst_results(call)[0]);
                            }
                            if arg_vals.len() > 1 {
                                args.push(arg_vals[1]); // decimals as f64
                            } else {
                                args.push(builder.ins().f64const(18.0)); // default 18 decimals
                            }
                            args
                        }
                        "getAddress" => {
                            // getAddress(address) - address is NaN-boxed string
                            let mut args = Vec::new();
                            if !arg_vals.is_empty() {
                                // String is NaN-boxed - extract raw pointer
                                let str_f64 = ensure_f64(builder, arg_vals[0]);
                                let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
                                let call = builder.ins().call(get_str_ref, &[str_f64]);
                                args.push(builder.inst_results(call)[0]);
                            }
                            args
                        }
                        "parseEther" => {
                            // parseEther(value) - value is NaN-boxed string
                            let mut args = Vec::new();
                            if !arg_vals.is_empty() {
                                // String is NaN-boxed - extract raw pointer
                                let str_f64 = ensure_f64(builder, arg_vals[0]);
                                let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                                let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
                                let call = builder.ins().call(get_str_ref, &[str_f64]);
                                args.push(builder.inst_results(call)[0]);
                            }
                            args
                        }
                        "formatEther" => {
                            // formatEther(bigint) - bigint is NaN-boxed
                            let mut args = Vec::new();
                            if !arg_vals.is_empty() {
                                // BigInt is NaN-boxed - extract raw pointer
                                let bigint_f64 = ensure_f64(builder, arg_vals[0]);
                                let get_bigint_func = extern_funcs.get("js_nanbox_get_bigint")
                                    .ok_or_else(|| anyhow!("js_nanbox_get_bigint not declared"))?;
                                let get_bigint_ref = module.declare_func_in_func(*get_bigint_func, builder.func);
                                let call = builder.ins().call(get_bigint_ref, &[bigint_f64]);
                                args.push(builder.inst_results(call)[0]);
                            }
                            args
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "jsonwebtoken" {
                    // jsonwebtoken module functions
                    match method.as_str() {
                        "sign" => {
                            // sign(payload, secret, options?)
                            // js_jwt_sign(payload: i64, secret: i64, expiry: f64) -> i64
                            let mut args = Vec::new();
                            if !arg_vals.is_empty() {
                                // payload (object) - needs to be i64
                                args.push(ensure_i64(builder, arg_vals[0]));
                            }
                            if arg_vals.len() > 1 {
                                // secret (string) - needs to be i64
                                args.push(ensure_i64(builder, arg_vals[1]));
                            }
                            // expiry - if options provided, try to extract expiresIn
                            // For now, default to 0.0 which means no expiry in the runtime
                            if arg_vals.len() > 2 {
                                // Third arg is options object with expiresIn
                                // For simplicity, pass 0.0 (no expiry) - full implementation would parse options
                                args.push(builder.ins().f64const(0.0));
                            } else {
                                args.push(builder.ins().f64const(0.0)); // default no expiry
                            }
                            args
                        }
                        "verify" => {
                            // verify(token, secret) -> payload
                            // js_jwt_verify(token: i64, secret: i64) -> i64
                            arg_vals.iter().map(|&val| {
                                ensure_i64(builder, val)
                            }).collect()
                        }
                        "decode" => {
                            // decode(token) -> payload
                            // js_jwt_decode(token: i64) -> i64
                            arg_vals.iter().map(|&val| {
                                ensure_i64(builder, val)
                            }).collect()
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "fs" {
                    // fs module functions - all path arguments are strings (pointers)
                    match method.as_str() {
                        "existsSync" | "mkdirSync" | "unlinkSync" => {
                            // Single path argument
                            arg_vals.iter().map(|&val| {
                                ensure_i64(builder, val)
                            }).collect()
                        }
                        "readFileSync" => {
                            // readFileSync(path, options?) - we only need the path
                            if !arg_vals.is_empty() {
                                vec![ensure_i64(builder, arg_vals[0])]
                            } else {
                                vec![]
                            }
                        }
                        "writeFileSync" => {
                            // writeFileSync(path, content) - both strings
                            arg_vals.iter().map(|&val| {
                                ensure_i64(builder, val)
                            }).collect()
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "path" {
                    // path module functions - all arguments are strings (pointers)
                    match method.as_str() {
                        "dirname" | "basename" | "extname" | "resolve" => {
                            // Single path argument
                            arg_vals.iter().map(|&val| {
                                ensure_i64(builder, val)
                            }).collect()
                        }
                        "join" => {
                            // join(a, b, ...) - takes exactly 2 arguments at a time
                            // For more than 2 args, we'd need to chain calls (not yet implemented)
                            // For now, take only first 2 arguments
                            arg_vals.iter().take(2).map(|&val| {
                                ensure_i64(builder, val)
                            }).collect()
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "dotenv" {
                    // dotenv module functions
                    match method.as_str() {
                        "config" => {
                            // config() takes no args, config({ path: ... }) needs path extracted
                            // If there are args, we need to use js_dotenv_config_path instead
                            if !arg_vals.is_empty() {
                                // The arg is an options object - we need to extract the 'path' property
                                // For now, just pass 0 args and let the default path be used
                                // TODO: Extract path from options object
                                vec![]
                            } else {
                                vec![]
                            }
                        }
                        "parse" => {
                            // parse(content) - content is string
                            arg_vals.iter().map(|&val| {
                                builder.ins().bitcast(types::I64, MemFlags::new(), val)
                            }).collect()
                        }
                        _ => arg_vals.clone()
                    }
                } else if native_module == "fastify" {
                    // fastify module functions
                    match method.as_str() {
                        "default" => {
                            // Fastify(opts?) - create app with optional config
                            // js_fastify_create_with_opts(opts: f64) -> Handle
                            if !arg_vals.is_empty() {
                                // Pass the options object as f64
                                vec![ensure_f64(builder, arg_vals[0])]
                            } else {
                                // Pass undefined (TAG_UNDEFINED)
                                const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                                vec![builder.ins().f64const(f64::from_bits(TAG_UNDEFINED))]
                            }
                        }
                        _ => arg_vals.clone()
                    }
                } else {
                    arg_vals.clone()
                }
            };

            // Make the call
            let call = builder.ins().call(func_ref, &call_args);

            // Get result
            if builder.inst_results(call).is_empty() {
                Ok(builder.ins().f64const(0.0))
            } else {
                let result = builder.inst_results(call)[0];
                // Functions that return f64 directly (not pointers)
                if native_module == "uuid" && (method == "validate" || method == "version") {
                    Ok(result)
                } else if native_module == "uuid" && (method == "v4" || method == "v1" || method == "v7") {
                    // uuid.v4/v1/v7 return string pointers - NaN-box with STRING_TAG
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result]);
                    Ok(builder.inst_results(call)[0])
                } else if native_module == "bcrypt" && method == "compareSync" {
                    // compareSync returns boolean as f64
                    Ok(result)
                } else if native_module == "node-fetch" && (method == "status" || method == "ok") {
                    // status returns number, ok returns boolean
                    Ok(result)
                } else if native_module == "ws" && (method == "isOpen" || method == "messageCount") {
                    // isOpen returns boolean, messageCount returns number
                    Ok(result)
                } else if (native_module == "decimal.js" || native_module == "big.js" || native_module == "bignumber.js") &&
                          (method == "toNumber" || method == "eq" || method == "lt" || method == "gt" ||
                           method == "lte" || method == "gte" || method == "cmp" ||
                           method == "isZero" || method == "isPositive" || method == "isNegative") {
                    // Decimal methods that return f64 directly (numbers or booleans)
                    Ok(result)
                } else if native_module == "lru-cache" && (method == "get" || method == "has" || method == "size" || method == "peek") {
                    // LRUCache methods that return f64 directly
                    Ok(result)
                } else if native_module == "fs" && (method == "existsSync" || method == "mkdirSync" || method == "unlinkSync" || method == "writeFileSync") {
                    // fs functions return i32 boolean - convert to f64
                    // result is already i32, extend to i64 then convert to f64
                    let extended = builder.ins().uextend(types::I64, result);
                    Ok(builder.ins().fcvt_from_uint(types::F64, extended))
                } else if native_module == "fs" && method == "readFileSync" {
                    // readFileSync returns string pointer - NaN-box with STRING_TAG
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result]);
                    Ok(builder.inst_results(call)[0])
                } else if native_module == "path" {
                    // path functions all return string pointers - NaN-box with STRING_TAG
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result]);
                    Ok(builder.inst_results(call)[0])
                } else if native_module == "events" && (method == "emit" || method == "listenerCount") {
                    // emit and listenerCount return f64 directly (boolean/number)
                    Ok(result)
                } else if native_module == "ethers" && method == "formatUnits" {
                    // formatUnits returns string pointer - NaN-box with STRING_TAG
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result]);
                    Ok(builder.inst_results(call)[0])
                } else if native_module == "ethers" && method == "parseUnits" {
                    // parseUnits returns BigInt pointer - NaN-box with BIGINT_TAG
                    let nanbox_func = extern_funcs.get("js_nanbox_bigint")
                        .ok_or_else(|| anyhow!("js_nanbox_bigint not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result]);
                    Ok(builder.inst_results(call)[0])
                } else if native_module == "ethers" && (method == "getAddress" || method == "formatEther") {
                    // getAddress and formatEther return string pointer - NaN-box with STRING_TAG
                    let nanbox_func = extern_funcs.get("js_nanbox_string")
                        .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result]);
                    Ok(builder.inst_results(call)[0])
                } else if native_module == "ethers" && method == "parseEther" {
                    // parseEther returns BigInt pointer - NaN-box with BIGINT_TAG
                    let nanbox_func = extern_funcs.get("js_nanbox_bigint")
                        .ok_or_else(|| anyhow!("js_nanbox_bigint not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result]);
                    Ok(builder.inst_results(call)[0])
                } else if native_module == "mysql2" || native_module == "mysql2/promise" ||
                          native_module == "ioredis" || native_module == "ws" ||
                          native_module == "events" || native_module == "lru-cache" ||
                          native_module == "commander" ||
                          native_module == "decimal.js" || native_module == "big.js" ||
                          native_module == "bignumber.js" {
                    // These modules return object pointers - NaN-box with POINTER_TAG
                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[result]);
                    Ok(builder.inst_results(call)[0])
                } else if native_module == "fastify" {
                    // Fastify methods have mixed return types:
                    // - Constructor (default): returns Handle (i64) - needs NaN-boxing
                    // - Route methods (get, post, etc.): return bool (i32) - convert to f64
                    // - listen: returns void
                    // - Other methods: may return Handle for chaining
                    match method.as_str() {
                        // Route methods return bool (i32)
                        "get" | "post" | "put" | "delete" | "patch" | "head" | "options" | "all" | "route" |
                        "addHook" | "setErrorHandler" | "register" => {
                            // Convert i32 bool to f64 (0.0 or 1.0)
                            let result_i64 = builder.ins().uextend(types::I64, result);
                            Ok(builder.ins().fcvt_from_sint(types::F64, result_i64))
                        }
                        "listen" => {
                            // listen returns void, return undefined
                            const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
                            Ok(builder.ins().f64const(f64::from_bits(TAG_UNDEFINED)))
                        }
                        _ => {
                            // Constructor (default) and other methods return Handle (i64) - NaN-box
                            let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                                .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                            let call = builder.ins().call(nanbox_ref, &[result]);
                            Ok(builder.inst_results(call)[0])
                        }
                    }
                } else {
                    // Other functions return pointers (i64) - convert to f64 for NaN-boxing ABI
                    Ok(builder.ins().bitcast(types::F64, MemFlags::new(), result))
                }
            }
        }
        Expr::FuncRef(func_id) => {
            // Named function being used as a value (passed as callback)
            // Create a closure object pointing to the wrapper function
            if let Some(&wrapper_func_id) = func_wrapper_ids.get(func_id) {
                // Get the wrapper function reference
                let func_ref = module.declare_func_in_func(wrapper_func_id, builder.func);
                let func_ptr = builder.ins().func_addr(types::I64, func_ref);

                // Allocate a closure with 0 captures
                let alloc_func = extern_funcs.get("js_closure_alloc")
                    .ok_or_else(|| anyhow!("js_closure_alloc not declared"))?;
                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);

                let capture_count = builder.ins().iconst(types::I32, 0);
                let call = builder.ins().call(alloc_ref, &[func_ptr, capture_count]);
                let closure_ptr = builder.inst_results(call)[0];

                // Return closure pointer as i64
                Ok(closure_ptr)
            } else {
                Err(anyhow!("No wrapper found for function {} used as value", func_id))
            }
        }
        Expr::Null => {
            // Null is represented as NaN-boxed TAG_NULL (0x7FFC_0000_0000_0002)
            const TAG_NULL: u64 = 0x7FFC_0000_0000_0002;
            Ok(builder.ins().f64const(f64::from_bits(TAG_NULL)))
        }
        Expr::Undefined => {
            // Undefined is represented as NaN-boxed TAG_UNDEFINED (0x7FFC_0000_0000_0001)
            const TAG_UNDEFINED: u64 = 0x7FFC_0000_0000_0001;
            Ok(builder.ins().f64const(f64::from_bits(TAG_UNDEFINED)))
        }
        Expr::ObjectKeys(obj_expr) => {
            // Object.keys(obj) - returns an array of string keys
            // Call js_dynamic_object_keys runtime function (handles Error objects too)
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, obj_expr, this_ctx)?;
            // Extract pointer from NaN-boxed value if needed
            let obj_ptr = if builder.func.dfg.value_type(obj_val) == types::I64 {
                obj_val
            } else {
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[obj_val]);
                builder.inst_results(call)[0]
            };

            let func = extern_funcs.get("js_dynamic_object_keys")
                .ok_or_else(|| anyhow!("js_dynamic_object_keys not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[obj_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            // NaN-box the array pointer with POINTER_TAG for proper handling
            let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
            Ok(builder.inst_results(nanbox_call)[0])
        }
        Expr::ObjectValues(obj_expr) => {
            // Object.values(obj) - returns an array of property values
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, obj_expr, this_ctx)?;
            // Extract pointer from NaN-boxed value if needed
            let obj_ptr = if builder.func.dfg.value_type(obj_val) == types::I64 {
                obj_val
            } else {
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[obj_val]);
                builder.inst_results(call)[0]
            };

            let func = extern_funcs.get("js_object_values")
                .ok_or_else(|| anyhow!("js_object_values not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[obj_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            // NaN-box the array pointer with POINTER_TAG for proper handling
            let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
            Ok(builder.inst_results(nanbox_call)[0])
        }
        Expr::ObjectEntries(obj_expr) => {
            // Object.entries(obj) - returns an array of [key, value] pairs
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, obj_expr, this_ctx)?;
            // Extract pointer from NaN-boxed value if needed
            let obj_ptr = if builder.func.dfg.value_type(obj_val) == types::I64 {
                obj_val
            } else {
                let get_ptr_func = extern_funcs.get("js_nanbox_get_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_get_pointer not declared"))?;
                let get_ptr_ref = module.declare_func_in_func(*get_ptr_func, builder.func);
                let call = builder.ins().call(get_ptr_ref, &[obj_val]);
                builder.inst_results(call)[0]
            };

            let func = extern_funcs.get("js_object_entries")
                .ok_or_else(|| anyhow!("js_object_entries not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[obj_ptr]);
            let result_ptr = builder.inst_results(call)[0];

            // NaN-box the array pointer with POINTER_TAG for proper handling
            let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
            let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
            let nanbox_call = builder.ins().call(nanbox_ref, &[result_ptr]);
            Ok(builder.inst_results(nanbox_call)[0])
        }
        Expr::ArrayIsArray(value_expr) => {
            // Array.isArray(value) - returns boolean
            let value = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value_expr, this_ctx)?;

            // Check if the value is an array local (stored as i64) and needs NaN-boxing
            let is_array_local = match value_expr.as_ref() {
                Expr::LocalGet(id) => locals.get(id).map(|i| i.is_array).unwrap_or(false),
                Expr::Array(_) | Expr::ArraySpread(_) => true,
                _ => false,
            };

            let value_f64 = if is_array_local && builder.func.dfg.value_type(value) == types::I64 {
                // Array stored as raw i64 pointer - NaN-box it with POINTER_TAG
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[value]);
                builder.inst_results(call)[0]
            } else {
                ensure_f64(builder, value)
            };

            let func = extern_funcs.get("js_array_is_array")
                .ok_or_else(|| anyhow!("js_array_is_array not declared"))?;
            let func_ref = module.declare_func_in_func(*func, builder.func);
            let call = builder.ins().call(func_ref, &[value_f64]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::TypeOf(inner) => {
            // Compile the inner expression
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, inner, this_ctx)?;

            // For static type analysis, we can return a constant string in some cases
            // But for dynamic values (union types), we need to call js_value_typeof

            // Check if the inner expression is a local with known static type
            let static_type = match inner.as_ref() {
                Expr::LocalGet(id) => {
                    if let Some(info) = locals.get(id) {
                        if info.is_string {
                            Some("string")
                        } else if info.is_array {
                            Some("object") // typeof array === "object"
                        } else if info.is_closure {
                            Some("function")
                        } else if info.is_union {
                            None // Need runtime check for union types
                        } else if info.is_pointer {
                            Some("object")
                        } else {
                            Some("number")
                        }
                    } else {
                        None
                    }
                }
                Expr::String(_) => Some("string"),
                Expr::Number(_) | Expr::Integer(_) => Some("number"),
                Expr::Bool(_) => Some("boolean"),
                Expr::Undefined => Some("undefined"),
                Expr::Null => Some("object"), // typeof null === "object"
                Expr::Array(_) | Expr::ArraySpread(_) | Expr::Object(_) => Some("object"),
                Expr::Closure { .. } | Expr::FuncRef(_) | Expr::ExternFuncRef { .. } => Some("function"),
                _ => None,
            };

            if let Some(type_str) = static_type {
                // Return a constant string
                let bytes = type_str.as_bytes();
                let len = bytes.len();

                let slot = builder.create_sized_stack_slot(StackSlotData::new(
                    StackSlotKind::ExplicitSlot,
                    len as u32,
                    0,
                ));

                for (i, &byte) in bytes.iter().enumerate() {
                    let byte_val = builder.ins().iconst(types::I8, byte as i64);
                    builder.ins().stack_store(byte_val, slot, i as i32);
                }

                let slot_addr = builder.ins().stack_addr(types::I64, slot, 0);
                let alloc_func = extern_funcs.get("js_string_from_bytes")
                    .ok_or_else(|| anyhow!("js_string_from_bytes not declared"))?;
                let alloc_ref = module.declare_func_in_func(*alloc_func, builder.func);
                let len_val = builder.ins().iconst(types::I32, len as i64);
                let call = builder.ins().call(alloc_ref, &[slot_addr, len_val]);
                let str_ptr = builder.inst_results(call)[0];
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), str_ptr))
            } else {
                // Need runtime type check - call js_value_typeof
                // js_value_typeof expects f64 (NaN-boxed value)
                // If val is i64 (e.g., any-typed pointer), NaN-box it first
                let val_type = builder.func.dfg.value_type(val);
                let val_f64 = if val_type == types::I64 {
                    // NaN-box the pointer for proper runtime type detection
                    let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                        .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                    let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                    let call = builder.ins().call(nanbox_ref, &[val]);
                    builder.inst_results(call)[0]
                } else {
                    val
                };
                let typeof_func = extern_funcs.get("js_value_typeof")
                    .ok_or_else(|| anyhow!("js_value_typeof not declared"))?;
                let typeof_ref = module.declare_func_in_func(*typeof_func, builder.func);
                let call = builder.ins().call(typeof_ref, &[val_f64]);
                let str_ptr = builder.inst_results(call)[0];
                Ok(builder.ins().bitcast(types::F64, MemFlags::new(), str_ptr))
            }
        }
        Expr::InstanceOf { expr, ty } => {
            // Check if value is an instance of a class
            // 1. Compile the expression to get the value
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, expr, this_ctx)?;

            // Check if the value is i64 (class instance pointer) and convert to f64 for js_instanceof
            let val_type = builder.func.dfg.value_type(val);
            let val_f64 = if val_type == types::I64 {
                // NaN-box the pointer for the runtime check
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[val]);
                builder.inst_results(call)[0]
            } else {
                val
            };

            // 2. Get the class_id for the target type
            let class_id = if let Some(class_meta) = classes.get(ty) {
                class_meta.id as i64
            } else {
                // Built-in types like Error, Array, etc.
                match ty.as_str() {
                    "Error" => 0xFFFF0001_i64, // Special ID for Error
                    "Array" => 0xFFFF0002_i64, // Special ID for Array
                    "Date" => 0xFFFF0003_i64,  // Special ID for Date
                    "Uint8Array" => 0xFFFF0004_i64, // Special ID for Uint8Array
                    "Buffer" => 0xFFFF0004_i64, // Buffer uses same ID as Uint8Array (similar types)
                    _ => {
                        // Unknown class - return false at runtime
                        return Ok(builder.ins().f64const(0.0));
                    }
                }
            };

            // 3. Call js_instanceof(value, class_id)
            let instanceof_func = extern_funcs.get("js_instanceof")
                .ok_or_else(|| anyhow!("js_instanceof not declared"))?;
            let instanceof_ref = module.declare_func_in_func(*instanceof_func, builder.func);
            let class_id_val = builder.ins().iconst(types::I32, class_id);
            let call = builder.ins().call(instanceof_ref, &[val_f64, class_id_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::In { property, object } => {
            // Compile the 'in' operator: "key" in obj
            // Returns true (1.0) if the property exists in the object, false (0.0) otherwise

            // Check if property is a string literal or string variable
            let is_string_property = matches!(property.as_ref(), Expr::String(_)) ||
                if let Expr::LocalGet(id) = property.as_ref() {
                    locals.get(id).map(|info| info.is_string).unwrap_or(false)
                } else {
                    false
                };

            // 1. Compile the property expression (usually a string literal)
            let prop_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, property, this_ctx)?;

            // Ensure property is f64 (NaN-boxed string)
            // String literals return raw pointers bitcast to f64 - we need to NaN-box them
            let prop_f64 = if is_string_property {
                // String value - need to NaN-box it as a string
                let prop_ptr = if builder.func.dfg.value_type(prop_val) == types::F64 {
                    builder.ins().bitcast(types::I64, MemFlags::new(), prop_val)
                } else {
                    prop_val
                };
                let nanbox_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[prop_ptr]);
                builder.inst_results(call)[0]
            } else if builder.func.dfg.value_type(prop_val) == types::I64 {
                // Non-string pointer - NaN-box as a generic pointer
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[prop_val]);
                builder.inst_results(call)[0]
            } else {
                // Already f64 (possibly a number key)
                prop_val
            };

            // 2. Compile the object expression
            let obj_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;

            // Ensure object is f64 (NaN-boxed pointer)
            let obj_f64 = if builder.func.dfg.value_type(obj_val) == types::F64 {
                // Object literals return raw pointers bitcast to f64 - need to NaN-box
                let obj_ptr = builder.ins().bitcast(types::I64, MemFlags::new(), obj_val);
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[obj_ptr]);
                builder.inst_results(call)[0]
            } else if builder.func.dfg.value_type(obj_val) == types::I64 {
                // Pointer value - NaN-box it
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[obj_val]);
                builder.inst_results(call)[0]
            } else {
                obj_val
            };

            // 3. Call js_object_has_property(obj, key) -> f64 (1.0 or 0.0)
            let has_prop_func = extern_funcs.get("js_object_has_property")
                .ok_or_else(|| anyhow!("js_object_has_property not declared"))?;
            let has_prop_ref = module.declare_func_in_func(*has_prop_func, builder.func);
            let call = builder.ins().call(has_prop_ref, &[obj_f64, prop_f64]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::ParseInt { string, radix } => {
            // Compile the string argument
            let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, string, this_ctx)?;

            // Get the string pointer (i64) - extract from NaN-boxed value if needed
            let str_ptr = if builder.func.dfg.value_type(str_val) == types::F64 {
                // NaN-boxed string pointer - use unified extraction function
                let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
                let call = builder.ins().call(get_str_ref, &[str_val]);
                builder.inst_results(call)[0]
            } else {
                str_val
            };

            // Compile radix argument or use NaN to indicate default
            let radix_val = if let Some(r) = radix {
                compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, r, this_ctx)?
            } else {
                builder.ins().f64const(f64::NAN)
            };

            // Call js_parse_int(str_ptr, radix)
            let parse_func = extern_funcs.get("js_parse_int")
                .ok_or_else(|| anyhow!("js_parse_int not declared"))?;
            let parse_ref = module.declare_func_in_func(*parse_func, builder.func);
            let call = builder.ins().call(parse_ref, &[str_ptr, radix_val]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::ParseFloat(string) => {
            // Compile the string argument
            let str_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, string, this_ctx)?;

            // Get the string pointer (i64) - extract from NaN-boxed value if needed
            let str_ptr = if builder.func.dfg.value_type(str_val) == types::F64 {
                // NaN-boxed string pointer - use unified extraction function
                let get_str_func = extern_funcs.get("js_get_string_pointer_unified")
                    .ok_or_else(|| anyhow!("js_get_string_pointer_unified not declared"))?;
                let get_str_ref = module.declare_func_in_func(*get_str_func, builder.func);
                let call = builder.ins().call(get_str_ref, &[str_val]);
                builder.inst_results(call)[0]
            } else {
                str_val
            };

            // Call js_parse_float(str_ptr)
            let parse_func = extern_funcs.get("js_parse_float")
                .ok_or_else(|| anyhow!("js_parse_float not declared"))?;
            let parse_ref = module.declare_func_in_func(*parse_func, builder.func);
            let call = builder.ins().call(parse_ref, &[str_ptr]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::NumberCoerce(value) => {
            // Compile the value
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Ensure it's f64 (NaN-boxed for runtime)
            let val_f64 = if builder.func.dfg.value_type(val) == types::F64 {
                val
            } else if builder.func.dfg.value_type(val) == types::I64 {
                // NaN-box the pointer
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[val]);
                builder.inst_results(call)[0]
            } else {
                val
            };

            // Call js_number_coerce(value)
            let coerce_func = extern_funcs.get("js_number_coerce")
                .ok_or_else(|| anyhow!("js_number_coerce not declared"))?;
            let coerce_ref = module.declare_func_in_func(*coerce_func, builder.func);
            let call = builder.ins().call(coerce_ref, &[val_f64]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::StringCoerce(value) => {
            // Compile the value
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Ensure it's f64 (NaN-boxed for runtime)
            let val_f64 = if builder.func.dfg.value_type(val) == types::F64 {
                val
            } else if builder.func.dfg.value_type(val) == types::I64 {
                // NaN-box the pointer
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[val]);
                builder.inst_results(call)[0]
            } else {
                val
            };

            // Call js_string_coerce(value) - returns string pointer
            let coerce_func = extern_funcs.get("js_string_coerce")
                .ok_or_else(|| anyhow!("js_string_coerce not declared"))?;
            let coerce_ref = module.declare_func_in_func(*coerce_func, builder.func);
            let call = builder.ins().call(coerce_ref, &[val_f64]);
            let str_ptr = builder.inst_results(call)[0];
            // Return as f64 (NaN-boxed pointer)
            Ok(builder.ins().bitcast(types::F64, MemFlags::new(), str_ptr))
        }
        Expr::IsNaN(value) => {
            // Compile the value
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Ensure it's f64
            let val_f64 = if builder.func.dfg.value_type(val) == types::F64 {
                val
            } else if builder.func.dfg.value_type(val) == types::I64 {
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[val]);
                builder.inst_results(call)[0]
            } else {
                val
            };

            // Call js_is_nan(value)
            let isnan_func = extern_funcs.get("js_is_nan")
                .ok_or_else(|| anyhow!("js_is_nan not declared"))?;
            let isnan_ref = module.declare_func_in_func(*isnan_func, builder.func);
            let call = builder.ins().call(isnan_ref, &[val_f64]);
            Ok(builder.inst_results(call)[0])
        }
        Expr::IsFinite(value) => {
            // Compile the value
            let val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;

            // Ensure it's f64
            let val_f64 = if builder.func.dfg.value_type(val) == types::F64 {
                val
            } else if builder.func.dfg.value_type(val) == types::I64 {
                let nanbox_func = extern_funcs.get("js_nanbox_pointer")
                    .ok_or_else(|| anyhow!("js_nanbox_pointer not declared"))?;
                let nanbox_ref = module.declare_func_in_func(*nanbox_func, builder.func);
                let call = builder.ins().call(nanbox_ref, &[val]);
                builder.inst_results(call)[0]
            } else {
                val
            };

            // Call js_is_finite(value)
            let isfinite_func = extern_funcs.get("js_is_finite")
                .ok_or_else(|| anyhow!("js_is_finite not declared"))?;
            let isfinite_ref = module.declare_func_in_func(*isfinite_func, builder.func);
            let call = builder.ins().call(isfinite_ref, &[val_f64]);
            Ok(builder.inst_results(call)[0])
        }

        // ============================================
        // V8 JavaScript Runtime expressions
        // ============================================

        Expr::JsLoadModule { path } => {
            // Create string data for the path
            let path_bytes = path.as_bytes();
            let path_len = path_bytes.len();

            // Allocate string constant for path (use unique ID to avoid duplicates)
            let path_data_id = module.declare_data(
                &format!("__js_module_path_{}_{}", path.replace(['/', '.', '-'], "_"), next_js_data_id()),
                Linkage::Local,
                false,
                false,
            )?;
            let mut data_desc = cranelift_module::DataDescription::new();
            data_desc.define(path_bytes.to_vec().into_boxed_slice());
            module.define_data(path_data_id, &data_desc)?;

            let path_gv = module.declare_data_in_func(path_data_id, builder.func);
            let path_ptr = builder.ins().global_value(types::I64, path_gv);
            let path_len_val = builder.ins().iconst(types::I64, path_len as i64);

            // Call js_load_module(path_ptr, path_len) -> module_handle
            let load_func = extern_funcs.get("js_load_module")
                .ok_or_else(|| anyhow!("js_load_module not declared"))?;
            let load_ref = module.declare_func_in_func(*load_func, builder.func);
            let call = builder.ins().call(load_ref, &[path_ptr, path_len_val]);
            let module_handle = builder.inst_results(call)[0];

            // Return module handle as f64 (will be treated as i64 internally)
            Ok(builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), module_handle))
        }

        Expr::JsGetExport { module_handle, export_name } => {
            // Compile module handle expression
            let handle_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, module_handle, this_ctx)?;
            let handle_i64 = builder.ins().bitcast(types::I64, cranelift_codegen::ir::MemFlags::new(), handle_val);

            // Create string constant for export name
            let name_bytes = export_name.as_bytes();
            let name_len = name_bytes.len();

            let name_data_id = module.declare_data(
                &format!("__js_export_{}_{}", export_name, next_js_data_id()),
                Linkage::Local,
                false,
                false,
            )?;
            let mut data_desc = cranelift_module::DataDescription::new();
            data_desc.define(name_bytes.to_vec().into_boxed_slice());
            module.define_data(name_data_id, &data_desc)?;

            let name_gv = module.declare_data_in_func(name_data_id, builder.func);
            let name_ptr = builder.ins().global_value(types::I64, name_gv);
            let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

            // Call js_get_export(module_handle, name_ptr, name_len) -> f64
            let get_func = extern_funcs.get("js_get_export")
                .ok_or_else(|| anyhow!("js_get_export not declared"))?;
            let get_ref = module.declare_func_in_func(*get_func, builder.func);
            let call = builder.ins().call(get_ref, &[handle_i64, name_ptr, name_len_val]);
            Ok(builder.inst_results(call)[0])
        }

        Expr::JsCallFunction { module_handle, func_name, args } => {
            // Compile module handle expression
            let handle_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, module_handle, this_ctx)?;
            let handle_i64 = builder.ins().bitcast(types::I64, cranelift_codegen::ir::MemFlags::new(), handle_val);

            // Create string constant for function name
            let name_bytes = func_name.as_bytes();
            let name_len = name_bytes.len();

            let name_data_id = module.declare_data(
                &format!("__js_func_{}_{}", func_name, next_js_data_id()),
                Linkage::Local,
                false,
                false,
            )?;
            let mut data_desc = cranelift_module::DataDescription::new();
            data_desc.define(name_bytes.to_vec().into_boxed_slice());
            module.define_data(name_data_id, &data_desc)?;

            let name_gv = module.declare_data_in_func(name_data_id, builder.func);
            let name_ptr = builder.ins().global_value(types::I64, name_gv);
            let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

            // Compile arguments and store in array on stack
            let args_count = args.len();
            if args_count > 0 {
                // Allocate stack space for args array
                let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                    cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                    (args_count * 8) as u32,
                    8,
                ));
                let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                // Helper to detect if an expression is a string
                fn is_string_js_arg(expr: &Expr, locals: &HashMap<LocalId, LocalInfo>) -> bool {
                    match expr {
                        Expr::String(_) => true,
                        Expr::LocalGet(id) => locals.get(id).map(|i| i.is_string).unwrap_or(false),
                        Expr::EnvGet(_) | Expr::EnvGetDynamic(_) | Expr::FsReadFileSync(_) => true,
                        Expr::PathJoin(_, _) | Expr::PathDirname(_) | Expr::PathBasename(_) |
                        Expr::PathExtname(_) | Expr::PathResolve(_) | Expr::JsonStringify(_) => true,
                        _ => false,
                    }
                }

                // Get nanbox_string function for string arguments
                let nanbox_string_func = extern_funcs.get("js_nanbox_string")
                    .ok_or_else(|| anyhow!("js_nanbox_string not declared"))?;
                let nanbox_string_ref = module.declare_func_in_func(*nanbox_string_func, builder.func);

                // Store each argument, NaN-boxing strings with STRING_TAG
                for (i, arg) in args.iter().enumerate() {
                    let arg_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;

                    // If argument is a string, NaN-box it with STRING_TAG for JS interop
                    let final_val = if is_string_js_arg(arg, locals) {
                        let ptr = builder.ins().bitcast(types::I64, cranelift_codegen::ir::MemFlags::new(), arg_val);
                        let call = builder.ins().call(nanbox_string_ref, &[ptr]);
                        builder.inst_results(call)[0]
                    } else {
                        // Ensure non-string arguments are f64 for JS interop
                        let arg_val_type = builder.func.dfg.value_type(arg_val);
                        if arg_val_type == types::I64 {
                            builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), arg_val)
                        } else {
                            arg_val
                        }
                    };

                    let offset = (i * 8) as i32;
                    builder.ins().store(cranelift_codegen::ir::MemFlags::new(), final_val, args_ptr, offset);
                }

                let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                // Call js_call_function
                let call_func = extern_funcs.get("js_call_function")
                    .ok_or_else(|| anyhow!("js_call_function not declared"))?;
                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                let call = builder.ins().call(call_ref, &[handle_i64, name_ptr, name_len_val, args_ptr, args_count_val]);
                Ok(builder.inst_results(call)[0])
            } else {
                // No args - pass null pointer and 0 count
                let null_ptr = builder.ins().iconst(types::I64, 0);
                let zero_count = builder.ins().iconst(types::I64, 0);

                let call_func = extern_funcs.get("js_call_function")
                    .ok_or_else(|| anyhow!("js_call_function not declared"))?;
                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                let call = builder.ins().call(call_ref, &[handle_i64, name_ptr, name_len_val, null_ptr, zero_count]);
                Ok(builder.inst_results(call)[0])
            }
        }

        Expr::JsCallMethod { object, method_name, args } => {
            // Compile object expression
            let obj_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
            // js_native_call_method expects f64 for object, ensure we have the right type
            let obj_val_type = builder.func.dfg.value_type(obj_val_raw);
            let obj_val = if obj_val_type == types::I64 {
                builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), obj_val_raw)
            } else {
                obj_val_raw
            };

            // Create string constant for method name
            let name_bytes = method_name.as_bytes();
            let name_len = name_bytes.len();

            let name_data_id = module.declare_data(
                &format!("__js_method_{}_{}", method_name, next_js_data_id()),
                Linkage::Local,
                false,
                false,
            )?;
            let mut data_desc = cranelift_module::DataDescription::new();
            data_desc.define(name_bytes.to_vec().into_boxed_slice());
            module.define_data(name_data_id, &data_desc)?;

            let name_gv = module.declare_data_in_func(name_data_id, builder.func);
            let name_ptr = builder.ins().global_value(types::I64, name_gv);
            let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

            // Compile arguments
            let args_count = args.len();
            if args_count > 0 {
                let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                    cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                    (args_count * 8) as u32,
                    8,
                ));
                let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                for (i, arg) in args.iter().enumerate() {
                    let arg_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                    // Ensure argument is f64 for JS interop
                    let arg_val_type = builder.func.dfg.value_type(arg_val_raw);
                    let arg_val = if arg_val_type == types::I64 {
                        builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), arg_val_raw)
                    } else {
                        arg_val_raw
                    };
                    let offset = (i * 8) as i32;
                    builder.ins().store(cranelift_codegen::ir::MemFlags::new(), arg_val, args_ptr, offset);
                }

                let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                let call_func = extern_funcs.get("js_native_call_method")
                    .ok_or_else(|| anyhow!("js_native_call_method not declared"))?;
                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                let call = builder.ins().call(call_ref, &[obj_val, name_ptr, name_len_val, args_ptr, args_count_val]);
                Ok(builder.inst_results(call)[0])
            } else {
                let null_ptr = builder.ins().iconst(types::I64, 0);
                let zero_count = builder.ins().iconst(types::I64, 0);

                let call_func = extern_funcs.get("js_native_call_method")
                    .ok_or_else(|| anyhow!("js_native_call_method not declared"))?;
                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                let call = builder.ins().call(call_ref, &[obj_val, name_ptr, name_len_val, null_ptr, zero_count]);
                Ok(builder.inst_results(call)[0])
            }
        }

        Expr::JsGetProperty { object, property_name } => {
            // Compile object expression
            let obj_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
            // js_get_property expects f64 for object, ensure we have the right type
            let obj_val_type = builder.func.dfg.value_type(obj_val_raw);
            let obj_val = if obj_val_type == types::I64 {
                builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), obj_val_raw)
            } else {
                obj_val_raw
            };

            // Create string constant for property name
            let name_bytes = property_name.as_bytes();
            let name_len = name_bytes.len();

            let name_data_id = module.declare_data(
                &format!("__js_prop_{}_{}", property_name, next_js_data_id()),
                Linkage::Local,
                false,
                false,
            )?;
            let mut data_desc = cranelift_module::DataDescription::new();
            data_desc.define(name_bytes.to_vec().into_boxed_slice());
            module.define_data(name_data_id, &data_desc)?;

            let name_gv = module.declare_data_in_func(name_data_id, builder.func);
            let name_ptr = builder.ins().global_value(types::I64, name_gv);
            let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

            let call_func = extern_funcs.get("js_get_property")
                .ok_or_else(|| anyhow!("js_get_property not declared"))?;
            let call_ref = module.declare_func_in_func(*call_func, builder.func);
            let call = builder.ins().call(call_ref, &[obj_val, name_ptr, name_len_val]);
            Ok(builder.inst_results(call)[0])
        }

        Expr::JsSetProperty { object, property_name, value } => {
            // Compile object expression
            let obj_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, object, this_ctx)?;
            // js_set_property expects f64 for object, ensure we have the right type
            let obj_val_type = builder.func.dfg.value_type(obj_val_raw);
            let obj_val = if obj_val_type == types::I64 {
                builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), obj_val_raw)
            } else {
                obj_val_raw
            };

            // Create string constant for property name
            let name_bytes = property_name.as_bytes();
            let name_len = name_bytes.len();

            let name_data_id = module.declare_data(
                &format!("__js_prop_set_{}_{}", property_name, next_js_data_id()),
                Linkage::Local,
                false,
                false,
            )?;
            let mut data_desc = cranelift_module::DataDescription::new();
            data_desc.define(name_bytes.to_vec().into_boxed_slice());
            module.define_data(name_data_id, &data_desc)?;

            let name_gv = module.declare_data_in_func(name_data_id, builder.func);
            let name_ptr = builder.ins().global_value(types::I64, name_gv);
            let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

            // Compile value expression
            let value_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, value, this_ctx)?;
            // Ensure value is f64 for JS interop
            let value_val_type = builder.func.dfg.value_type(value_val_raw);
            let value_val = if value_val_type == types::I64 {
                builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), value_val_raw)
            } else {
                value_val_raw
            };

            let call_func = extern_funcs.get("js_set_property")
                .ok_or_else(|| anyhow!("js_set_property not declared"))?;
            let call_ref = module.declare_func_in_func(*call_func, builder.func);
            builder.ins().call(call_ref, &[obj_val, name_ptr, name_len_val, value_val]);

            // Return undefined (set property returns void)
            let undefined = builder.ins().f64const(f64::from_bits(0x7FFC_0000_0000_0001));
            Ok(undefined)
        }

        Expr::JsNew { module_handle, class_name, args } => {
            // Compile module handle expression
            let handle_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, module_handle, this_ctx)?;
            // Convert f64 to i64 for module handle
            let handle_i64 = builder.ins().bitcast(types::I64, cranelift_codegen::ir::MemFlags::new(), handle_val);

            // Create string constant for class name
            let name_bytes = class_name.as_bytes();
            let name_len = name_bytes.len();

            let name_data_id = module.declare_data(
                &format!("__js_class_{}_{}", class_name, next_js_data_id()),
                Linkage::Local,
                false,
                false,
            )?;
            let mut data_desc = cranelift_module::DataDescription::new();
            data_desc.define(name_bytes.to_vec().into_boxed_slice());
            module.define_data(name_data_id, &data_desc)?;

            let name_gv = module.declare_data_in_func(name_data_id, builder.func);
            let name_ptr = builder.ins().global_value(types::I64, name_gv);
            let name_len_val = builder.ins().iconst(types::I64, name_len as i64);

            // Compile arguments
            let args_count = args.len();
            if args_count > 0 {
                let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                    cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                    (args_count * 8) as u32,
                    8,
                ));
                let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                for (i, arg) in args.iter().enumerate() {
                    let arg_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                    // Ensure argument is f64 for JS interop
                    let arg_val_type = builder.func.dfg.value_type(arg_val_raw);
                    let arg_val = if arg_val_type == types::I64 {
                        builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), arg_val_raw)
                    } else {
                        arg_val_raw
                    };
                    let offset = (i * 8) as i32;
                    builder.ins().store(cranelift_codegen::ir::MemFlags::new(), arg_val, args_ptr, offset);
                }

                let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                let call_func = extern_funcs.get("js_new_instance")
                    .ok_or_else(|| anyhow!("js_new_instance not declared"))?;
                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                let call = builder.ins().call(call_ref, &[handle_i64, name_ptr, name_len_val, args_ptr, args_count_val]);
                Ok(builder.inst_results(call)[0])
            } else {
                let null_ptr = builder.ins().iconst(types::I64, 0);
                let zero_count = builder.ins().iconst(types::I64, 0);

                let call_func = extern_funcs.get("js_new_instance")
                    .ok_or_else(|| anyhow!("js_new_instance not declared"))?;
                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                let call = builder.ins().call(call_ref, &[handle_i64, name_ptr, name_len_val, null_ptr, zero_count]);
                Ok(builder.inst_results(call)[0])
            }
        }

        Expr::JsNewFromHandle { constructor, args } => {
            // Compile constructor expression
            let ctor_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, constructor, this_ctx)?;
            // js_new_from_handle expects f64 for constructor, ensure we have the right type
            let ctor_val = ensure_f64(builder, ctor_val_raw);

            // Compile arguments
            let args_count = args.len();
            if args_count > 0 {
                let stack_slot = builder.create_sized_stack_slot(cranelift_codegen::ir::StackSlotData::new(
                    cranelift_codegen::ir::StackSlotKind::ExplicitSlot,
                    (args_count * 8) as u32,
                    8,
                ));
                let args_ptr = builder.ins().stack_addr(types::I64, stack_slot, 0);

                for (i, arg) in args.iter().enumerate() {
                    let arg_val_raw = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, arg, this_ctx)?;
                    // Ensure argument is f64 for JS interop
                    let arg_val_type = builder.func.dfg.value_type(arg_val_raw);
                    let arg_val = if arg_val_type == types::I64 {
                        builder.ins().bitcast(types::F64, cranelift_codegen::ir::MemFlags::new(), arg_val_raw)
                    } else {
                        arg_val_raw
                    };
                    let offset = (i * 8) as i32;
                    builder.ins().store(cranelift_codegen::ir::MemFlags::new(), arg_val, args_ptr, offset);
                }

                let args_count_val = builder.ins().iconst(types::I64, args_count as i64);

                let call_func = extern_funcs.get("js_new_from_handle")
                    .ok_or_else(|| anyhow!("js_new_from_handle not declared"))?;
                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                let call = builder.ins().call(call_ref, &[ctor_val, args_ptr, args_count_val]);
                Ok(builder.inst_results(call)[0])
            } else {
                let null_ptr = builder.ins().iconst(types::I64, 0);
                let zero_count = builder.ins().iconst(types::I64, 0);

                let call_func = extern_funcs.get("js_new_from_handle")
                    .ok_or_else(|| anyhow!("js_new_from_handle not declared"))?;
                let call_ref = module.declare_func_in_func(*call_func, builder.func);
                let call = builder.ins().call(call_ref, &[ctor_val, null_ptr, zero_count]);
                Ok(builder.inst_results(call)[0])
            }
        }

        Expr::JsCreateCallback { closure, param_count } => {
            // For now, compile the closure as a regular closure and get its function pointer
            // This is a simplified implementation - full support would require generating
            // a callback wrapper function that matches the expected signature
            let closure_val = compile_expr(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, closure, this_ctx)?;

            // Extract function pointer from closure (stored as NaN-boxed pointer)
            // The closure_val is a NaN-boxed value containing the closure struct pointer
            // For V8 callbacks, we need to extract the function pointer and environment

            // For now, return the closure as-is - the V8 callback will need to handle
            // calling back into native code through the trampoline
            let func_ptr = builder.ins().bitcast(types::I64, cranelift_codegen::ir::MemFlags::new(), closure_val);
            let closure_env = builder.ins().iconst(types::I64, 0); // No environment for now
            let param_count_val = builder.ins().iconst(types::I64, *param_count as i64);

            let call_func = extern_funcs.get("js_create_callback")
                .ok_or_else(|| anyhow!("js_create_callback not declared"))?;
            let call_ref = module.declare_func_in_func(*call_func, builder.func);
            let call = builder.ins().call(call_ref, &[func_ptr, closure_env, param_count_val]);
            Ok(builder.inst_results(call)[0])
        }

        // ExternFuncRef used as a value (e.g., imported and passed as argument)
        // Load the exported value from the other module's global
        Expr::ExternFuncRef { name, .. } => {
            let global_name = format!("__export_{}", name);
            // Declare the data as imported (will be resolved by linker)
            let data_id = module.declare_data(&global_name, Linkage::Import, true, false)
                .map_err(|e| anyhow!("Failed to import global {}: {}", global_name, e))?;
            let global_val = module.declare_data_in_func(data_id, builder.func);
            let ptr = builder.ins().global_value(types::I64, global_val);
            Ok(builder.ins().load(types::F64, MemFlags::new(), ptr, 0))
        }

        // Sequence expression (comma operator, used for destructuring assignments)
        // Evaluate all expressions, return the last one's value
        Expr::Sequence(exprs) => {
            if exprs.is_empty() {
                // Empty sequence returns undefined
                Ok(builder.ins().f64const(f64::from_bits(0x7FF8000000000001)))
            } else {
                let mut result = builder.ins().f64const(0.0);
                for e in exprs {
                    result = compile_expr(
                        builder,
                        module,
                        func_ids,
                        closure_func_ids,
                        func_wrapper_ids,
                        extern_funcs,
                        async_func_ids,
                        classes,
                        enums,
                        func_param_types,
                        func_union_params,
                        func_return_types,
                        func_hir_return_types,
                        func_rest_param_index,
                        imported_func_param_counts,
                        locals,
                        e,
                        this_ctx,
                    )?;
                }
                Ok(result)
            }
        }

        _ => Err(anyhow!("Unsupported expression: {:?}", expr)),
    }
}

/// Compile statement with this context for constructors
fn compile_stmt_with_this(
    builder: &mut FunctionBuilder,
    module: &mut ObjectModule,
    func_ids: &HashMap<u32, cranelift_module::FuncId>,
    closure_func_ids: &HashMap<u32, cranelift_module::FuncId>,
    func_wrapper_ids: &HashMap<u32, cranelift_module::FuncId>,
    extern_funcs: &HashMap<String, cranelift_module::FuncId>,
    async_func_ids: &std::collections::HashSet<u32>,
    closure_returning_funcs: &std::collections::HashSet<u32>,
    classes: &HashMap<String, ClassMeta>,
    enums: &HashMap<(String, String), EnumMemberValue>,
    func_param_types: &HashMap<u32, Vec<types::Type>>, func_union_params: &HashMap<u32, Vec<bool>>,
    func_return_types: &HashMap<u32, types::Type>,
    func_hir_return_types: &HashMap<u32, perry_types::Type>,
    func_rest_param_index: &HashMap<u32, usize>,
    imported_func_param_counts: &HashMap<String, usize>,
    locals: &mut HashMap<LocalId, LocalInfo>,
    next_var: &mut usize,
    stmt: &Stmt,
    this_var: Variable,
    class_meta: &ClassMeta,
    loop_ctx: Option<&LoopContext>,
    boxed_vars: &std::collections::HashSet<LocalId>,
) -> Result<()> {
    let this_ctx = ThisContext {
        this_var,
        class_meta: class_meta.clone(),
    };
    compile_stmt(builder, module, func_ids, closure_func_ids, func_wrapper_ids, extern_funcs, async_func_ids, closure_returning_funcs, classes, enums, func_param_types, func_union_params, func_return_types, func_hir_return_types, func_rest_param_index, imported_func_param_counts, locals, next_var, stmt, Some(&this_ctx), loop_ctx, boxed_vars)
}
